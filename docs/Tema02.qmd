---
title: "Tema 02 - Limpieza y Tratamiento de Datos"
subtitle: "De datos en bruto a información útil para decidir con `tidyverse`"
author:  
    - "Pedro Albarrán"
    - "Alberto Pérez"
institute: "Dpto. de Fundamentos del Análisis Económico. Universidad de Alicante"
format:
  revealjs:
    logo: figure/by-nc-sa2.png
    titlegraphic: figure/by-nc-sa.png
    theme:  
        - beige
        - custom.scss
    smaller: true
    scrollable: true
    embed-resources: true
    slide-number: true
    show-slide-number: all
    transition: slide
    background-transition: fade
    progress: true
    height: 800
    width: 1200
    show-notes: false
    notes-format: html
execute:
  enabled: true
  eval: true
  echo: true
  warning: false
  message: false
knitr:
  opts_chunk:
    results: hide
    fig.show: hide
lang: es
strip-comments: true
toc: true
toc-depth: 1
toc-expand: false
toc-title: "Contenidos"
css: styles.css
---

```{r setup, message=FALSE, warning=FALSE, include=FALSE}
knitr::opts_chunk$set(eval = TRUE, echo = TRUE, 
                      warning = FALSE, message = FALSE,
                      results = "hide", fig.show="hide")
rm(list = ls())
library(tidyverse)
library(lubridate)
library(kableExtra)
```

```{r generar-datos, include=FALSE}
#| eval: false
#| echo: false

# Crear directorio para datos
if (!dir.exists("data")) dir.create("data")

set.seed(2024)

# ========================================
# DATASET: CATEGORÍAS
# ========================================
categorias <- data.frame(
  id_categoria = 1:8,
  nombre_categoria = c("Electrónica", "Ropa", "Hogar", "Deportes", 
                      "Alimentación", "Juguetes", "Libros", "Belleza"),
  margen_promedio = c(0.25, 0.45, 0.35, 0.40, 0.15, 0.35, 0.30, 0.50)
)

# ========================================
# DATASET: PRODUCTOS
# ========================================
productos <- data.frame(
  id_producto = 1:150,
  nombre_producto = paste0("Producto_", sprintf("%03d", 1:150)),
  id_categoria = sample(1:8, 150, replace = TRUE),
  precio = round(runif(150, 10, 500), 2),
  costo = round(runif(150, 5, 400), 2)
) %>%
  mutate(
    precio = ifelse(precio < costo, costo * 1.2, precio),
    activo = sample(c(TRUE, FALSE), 150, replace = TRUE, prob = c(0.9, 0.1))
  )

# ========================================
# DATASET: TIENDAS
# ========================================
tiendas <- data.frame(
  id_tienda = 1:12,
  nombre_tienda = c("Madrid Centro", "Barcelona Diagonal", "Valencia Puerto",
                   "Sevilla Este", "Bilbao Centro", "Málaga Costa",
                   "Zaragoza Plaza", "Alicante Playa", "Valladolid Norte",
                   "Vigo Mar", "Gijón Centro", "Murcia Sur"),
  region = c("Centro", "Nordeste", "Levante", "Sur", "Norte", "Sur",
            "Centro", "Levante", "Norte", "Noroeste", "Norte", "Levante"),
  tamaño_m2 = c(800, 1200, 600, 750, 900, 650, 700, 850, 500, 550, 600, 700),
  fecha_apertura = as.Date(c("2015-01-15", "2014-06-20", "2016-03-10",
                            "2015-09-05", "2017-02-14", "2016-11-22",
                            "2018-04-03", "2017-08-17", "2019-01-25",
                            "2018-10-09", "2019-05-30", "2020-02-18"))
)

# ========================================
# DATASET: EMPLEADOS
# ========================================
empleados <- data.frame(
  id_empleado = 1:85,
  nombre = paste0("Empleado_", 1:85),
  id_tienda = sample(1:12, 85, replace = TRUE),
  puesto = sample(c("Vendedor", "Supervisor", "Gerente", "Almacén"),
                 85, replace = TRUE, prob = c(0.6, 0.2, 0.1, 0.1)),
  fecha_contratacion = sample(seq(as.Date("2015-01-01"), 
                                 as.Date("2023-12-31"), by = "day"),
                             85, replace = TRUE),
  salario_mensual = case_when(
    puesto == "Vendedor" ~ round(rnorm(85, 1400, 200), 0),
    puesto == "Supervisor" ~ round(rnorm(85, 2000, 300), 0),
    puesto == "Gerente" ~ round(rnorm(85, 3000, 400), 0),
    puesto == "Almacén" ~ round(rnorm(85, 1300, 150), 0)
  )
) %>%
  mutate(salario_mensual = pmax(salario_mensual, 1100))

# ========================================
# DATASET: CLIENTES
# ========================================
clientes <- data.frame(
  id_cliente = 1:2500,
  email = paste0("cliente", 1:2500, "@email.com"),
  fecha_registro = sample(seq(as.Date("2015-01-01"), 
                             as.Date("2024-01-31"), by = "day"),
                         2500, replace = TRUE),
  codigo_postal = sample(c("28001", "08001", "46001", "41001", "48001",
                          "29001", "50001", "03001", "47001", "36001",
                          "33001", "30001"), 2500, replace = TRUE),
  programa_fidelidad = sample(c("Básico", "Silver", "Gold", "Platinum", NA),
                             2500, replace = TRUE, 
                             prob = c(0.4, 0.25, 0.15, 0.05, 0.15))
)

# ========================================
# DATASET: VENTAS (Principal - ~5000 registros)
# ========================================
# Generar fechas con mayor concentración en años recientes
fechas_ventas <- c(
  sample(seq(as.Date("2020-01-01"), as.Date("2021-12-31"), by = "day"),
         1000, replace = TRUE),
  sample(seq(as.Date("2022-01-01"), as.Date("2022-12-31"), by = "day"),
         1500, replace = TRUE),
  sample(seq(as.Date("2023-01-01"), as.Date("2023-12-31"), by = "day"),
         2000, replace = TRUE),
  sample(seq(as.Date("2024-01-01"), as.Date("2024-01-31"), by = "day"),
         500, replace = TRUE)
)

ventas <- data.frame(
  id_venta = 1:5000,
  fecha = sample(fechas_ventas, 5000, replace = FALSE),
  id_cliente = sample(clientes$id_cliente, 5000, replace = TRUE),
  id_producto = sample(productos$id_producto, 5000, replace = TRUE),
  id_tienda = sample(tiendas$id_tienda, 5000, replace = TRUE),
  id_empleado = sample(empleados$id_empleado, 5000, replace = TRUE),
  cantidad = sample(1:5, 5000, replace = TRUE, prob = c(0.5, 0.25, 0.15, 0.07, 0.03)),
  descuento_porcentaje = sample(c(0, 5, 10, 15, 20, 25),
                               5000, replace = TRUE,
                               prob = c(0.5, 0.2, 0.15, 0.1, 0.04, 0.01))
) %>%
  left_join(productos %>% select(id_producto, precio), by = "id_producto") %>%
  mutate(
    precio_unitario = precio,
    subtotal = cantidad * precio_unitario,
    descuento_aplicado = round(subtotal * descuento_porcentaje / 100, 2),
    total = subtotal - descuento_aplicado,
    año = year(fecha),
    mes = month(fecha),
    trimestre = quarter(fecha),
    dia_semana = wday(fecha, label = TRUE, abbr = FALSE, week_start = 1)
  ) %>%
  select(-precio)

# ========================================
# DATASET: DEVOLUCIONES
# ========================================
# Aproximadamente 5% de ventas tienen devolución
ventas_con_devolucion <- sample(ventas$id_venta, 
                               round(nrow(ventas) * 0.05), 
                               replace = FALSE)

devoluciones <- ventas %>%
  filter(id_venta %in% ventas_con_devolucion) %>%
  mutate(
    id_devolucion = row_number(),
    fecha_devolucion = fecha + sample(1:30, n(), replace = TRUE),
    motivo = sample(c("Defectuoso", "No satisfecho", "Talla incorrecta", 
                     "Color diferente", "Cambio de opinión"),
                   n(), replace = TRUE,
                   prob = c(0.15, 0.25, 0.20, 0.15, 0.25)),
    cantidad_devuelta = pmin(cantidad, sample(1:3, n(), replace = TRUE)),
    reembolso = round(total * (cantidad_devuelta / cantidad), 2),
    procesado = sample(c(TRUE, FALSE), n(), replace = TRUE, prob = c(0.9, 0.1))
  ) %>%
  select(id_devolucion, id_venta, fecha_devolucion, motivo, 
         cantidad_devuelta, reembolso, procesado)

# ========================================
# INFORMACIÓN DE VARIABLES
# ========================================
ventas_info <- data.frame(
  variable = c("id_venta", "fecha", "id_cliente", "id_producto", "id_tienda",
              "id_empleado", "cantidad", "descuento_porcentaje", "precio_unitario",
              "subtotal", "descuento_aplicado", "total", "año", "mes",
              "trimestre", "dia_semana"),
  descripcion = c(
    "Identificador único de la transacción de venta",
    "Fecha de la venta (formato YYYY-MM-DD)",
    "Identificador del cliente que realizó la compra",
    "Identificador del producto vendido",
    "Identificador de la tienda donde se realizó la venta",
    "Identificador del empleado que atendió la venta",
    "Número de unidades vendidas",
    "Porcentaje de descuento aplicado (0-25%)",
    "Precio por unidad del producto en euros",
    "Precio total antes de descuento (cantidad × precio_unitario)",
    "Importe del descuento aplicado en euros",
    "Precio final pagado por el cliente en euros",
    "Año de la venta",
    "Mes de la venta (1-12)",
    "Trimestre del año (1-4)",
    "Día de la semana de la venta"
  ),
  tipo = c("Entero", "Fecha", "Entero", "Entero", "Entero", "Entero",
          "Entero", "Numérica", "Numérica", "Numérica", "Numérica",
          "Numérica", "Entero", "Entero", "Entero", "Factor")
)

productos_info <- data.frame(
  variable = c("id_producto", "nombre_producto", "id_categoria", 
              "precio", "costo", "activo"),
  descripcion = c(
    "Identificador único del producto",
    "Nombre descriptivo del producto",
    "Identificador de la categoría a la que pertenece",
    "Precio de venta al público en euros",
    "Costo de adquisición/producción en euros",
    "Indica si el producto está activo en catálogo (TRUE/FALSE)"
  ),
  tipo = c("Entero", "Carácter", "Entero", "Numérica", "Numérica", "Lógico")
)

clientes_info <- data.frame(
  variable = c("id_cliente", "email", "fecha_registro", 
              "codigo_postal", "programa_fidelidad"),
  descripcion = c(
    "Identificador único del cliente",
    "Dirección de correo electrónico del cliente",
    "Fecha de registro en el sistema",
    "Código postal de residencia del cliente",
    "Nivel en el programa de fidelidad (Básico/Silver/Gold/Platinum/NA)"
  ),
  tipo = c("Entero", "Carácter", "Fecha", "Carácter", "Factor")
)

empleados_info <- data.frame(
  variable = c("id_empleado", "nombre", "id_tienda", "puesto",
              "fecha_contratacion", "salario_mensual"),
  descripcion = c(
    "Identificador único del empleado",
    "Nombre del empleado",
    "Identificador de la tienda donde trabaja",
    "Puesto de trabajo (Vendedor/Supervisor/Gerente/Almacén)",
    "Fecha de contratación del empleado",
    "Salario mensual bruto en euros"
  ),
  tipo = c("Entero", "Carácter", "Entero", "Factor", "Fecha", "Numérica")
)

tiendas_info <- data.frame(
  variable = c("id_tienda", "nombre_tienda", "region", "tamaño_m2",
              "fecha_apertura"),
  descripcion = c(
    "Identificador único de la tienda",
    "Nombre comercial de la tienda",
    "Región geográfica (Centro/Norte/Sur/Nordeste/Levante/Noroeste)",
    "Superficie de la tienda en metros cuadrados",
    "Fecha de apertura de la tienda"
  ),
  tipo = c("Entero", "Carácter", "Factor", "Numérica", "Fecha")
)

categorias_info <- data.frame(
  variable = c("id_categoria", "nombre_categoria", "margen_promedio"),
  descripcion = c(
    "Identificador único de la categoría",
    "Nombre de la categoría de productos",
    "Margen de beneficio promedio de la categoría (proporción)"
  ),
  tipo = c("Entero", "Carácter", "Numérica")
)

devoluciones_info <- data.frame(
  variable = c("id_devolucion", "id_venta", "fecha_devolucion", "motivo",
              "cantidad_devuelta", "reembolso", "procesado"),
  descripcion = c(
    "Identificador único de la devolución",
    "Identificador de la venta original asociada",
    "Fecha en que se procesó la devolución",
    "Motivo de la devolución (Defectuoso/No satisfecho/etc.)",
    "Cantidad de unidades devueltas",
    "Importe reembolsado al cliente en euros",
    "Indica si la devolución ha sido procesada (TRUE/FALSE)"
  ),
  tipo = c("Entero", "Entero", "Fecha", "Factor", "Entero", "Numérica", "Lógico")
)

# Guardar todos los datasets
save(ventas, productos, clientes, empleados, tiendas, 
     categorias, devoluciones,
     ventas_info, productos_info, clientes_info, 
     empleados_info, tiendas_info, categorias_info, devoluciones_info,
     file = "data/retail_data.RData")

# Exportar también a CSV para otros usos
# write_csv(ventas, "data/ventas.csv")
# write_csv(productos, "data/productos.csv")
# write_csv(clientes, "data/clientes.csv")
# write_csv(empleados, "data/empleados.csv")
# write_csv(tiendas, "data/tiendas.csv")
# write_csv(categorias, "data/categorias.csv")
# write_csv(devoluciones, "data/devoluciones.csv")
```

# Introducción. Datos Ordenados

## Limpieza y "doma" de datos 

:::: {.notes}

-   En la vida real, los datos se tiene que recolectar, unir, limpiar, recodificar, etc.

::::

:::: {.columns}
::: {.column width=40%}
- El ciclo de vida de los datos
::: 
::: {.column width=60%}
![](figure/data-science-wrangle.png){width=75% fig-align="center"}
:::
::::

- El desafío real del análisis de datos:

  - 80% del tiempo de [trabajo "sucio"](https://www.nytimes.com/2014/08/18/technology/for-big-data-scientists-hurdle-to-insights-is-janitor-work.html) : limpieza y preparación

  - 20% del tiempo: análisis y modelización

- `tidyverse` incluye una colección de bibliotecas con herramientes eficientes para el proceso de "tratamiento de datos" ("data wrangling")

:::: {.notes}
- ofrece herramientas eficientes inspiradas en  declaraciones de consulta **SQL** 

- basadas en una *gramática de manipulación de datos*

::::


- El objetivo es obtener un conjunto de datos **ordenado** y **limpio** para realizar el análisis eficientemente y obtener información útil para la toma de decisiones


## Datos ordenados ('tidy data'): Principios fundamentales

1.- Cada columna es una **variable**: mide el mismo *atributo* entre unidades
  
2.- Cada fila es una **observación** (caso): misma *unidad* a través de atributos

3.- Cada celda es un **valor**

:::: {.notes}

- atributos (cuantitativos o cualitativos) o características

- **observación** (caso): valores de la misma *unidad* a través de atributos

- Una tabla puede completar la información con uniones a tablas adicionales (ej., para variables codificadas)

::::

![](figure/tidy-1.png){width=65% fig-align="center"}

* Tenemos información similar y no redundante en una misma tabla 

* Es una forma natural (variable = vector columna) para trabajar con datos <!-- en R y otros lenguajes-->
 
```{r}
#| echo: false
#| eval: false

# Para acceder al vector valores de `cases`

table1$cases                   # table1 %>% select(cases)
table2$count[c(1,3,5,7,9,11)]  # table2 %>% filter(type == "cases") %>%
                               #            select(count)
c(table4a$`1999`, table4a$`2000`)
# crear variables es fácil
table1 %>% mutate(rate = cases / population * 10000)  
```

* `tidyverse` es eficiente con datos ordenados 


```{r}
#| echo: false
#| eval: false

# Ej. gráfico temporal

ggplot(table1, aes(x = year, y = cases)) +  
  geom_line(aes(colour = country))
```


:::: {.notes}

1. Atributos diferentes en columnas diferentes; p.e., nombres de columnas no deben ser valores

2. Mismo nivel de agregación en toda la tabla

3. No mezclar tipos de datos Ni almacenar múltiples valores

```{r}
#| eval: false
#| echo: false
# Ejemplo de datos ORDENADOS
head(ventas, 3)
```

::::

## Datos no ordenados

:::: {.columns}
::: {.column width=50%}
![](figure/tablaNOordenados.png){width=110% fig-align="center"}
::: 

::: {.column width=50%}
* Otras estructuras como [esta](https://datos.gob.es/es/catalogo/conjuntos-datos?q=hombres-segun-si-tienen-hijos-o-no-situacion-sentimental-y-edad&sort=score+desc%2C+metadata_created+desc) pueden tener sentido para *mostrar información* (o por convenciones)<!--para almacenar información -->


* La visualización es atractiva, PERO sobran filas para **analizar** los datos: ej., total de personas con hijos y sin pareja entre 30 y 39 años

::: 
::::


:::: {.notes}
```{r}
#| eval: false
#| echo: false
# Ejemplo de datos NO ORDENADOS (comunes en Excel)
ventas_desordenadas <- data.frame(
  Tienda = c("Madrid Centro", "Barcelona", "Total"),
  Ene_2023 = c(45000, 52000, 97000),
  Feb_2023 = c(48000, 54000, 102000),
  Mar_2023 = c(51000, 56000, 107000)
)
ventas_desordenadas
```

**Problemas de estos datos:**

- Meses están en columnas (son valores, no variables)

- Fila "Total" mezcla niveles de agregación

- Difícil filtrar, agrupar o visualizar

**Por Qué Importan los Datos Ordenados**

:::: {.columns}

::: {.column width="50%"}
**Ventajas:**

✓ Consistencia en todas las operaciones

✓ Fácil manipulación con `dplyr`

✓ Visualización directa con `ggplot2`

✓ Compatible con modelización

✓ Facilita colaboración

:::

::: {.column width="50%"}
**Ejemplo Práctico:**

```{r eval=FALSE}
# Con datos ordenados: FÁCIL
ventas %>%
  group_by(id_tienda, mes) %>%
  summarize(ventas_total = sum(total))

# Con datos desordenados: COMPLEJO
# Requiere reshape, limpieza, etc.
```
:::

::::


::::



## Caso de Estudio: RetailCorp

- **Contexto:** Cadena de venta al por menor scon 12 tiendas en España

- **Objetivo:** Analizar rendimiento de ventas para toma de decisiones estratégicas

. . .

```{r}
load("data/retail_data.RData")
```

:::: {.columns}
::: {.column width=50%}
- Recibe datos de 

  - Sistema de ventas (POS)
  
  - CRM de clientes
  
  - Inventario de productos
  
  - RRHH de empleados
  
  - Informes Excel de gerentes
  
:::

::: {.column width=40%}
**Problemas Típicos:**

- Formatos inconsistentes

- Datos duplicados

- Valores ausentes

- Estructuras inadecuadas

- Tablas dispersas
:::
::::


# Transformación de datos (una tabla)

:::: {.notes}
* `dplyr` frente R `base`

* sencillez, rapidez con big data, estilo SQL etc.

1.  select()  =  data[, c("name") / pos] 
              =  subset()

2.  filter()  =  data[c("name") / pos, ] 
              =  subset()

3.  mutate()  = data$newvar <- 
              = with(data, newvar = y - x)

4.  arrange() = order()
              [sort() es para vectores]

5.  summarize() = aggregate(data,income, FUN=mean)

6. groub_by() %>% summarize = aggregate(data,income~año, FUN=mean)
::::

## Funciones de transformación de datos

- La mayoría de operaciones pueden realizarse combinando 5 "verbos": 

  1. `select()`: selecciona columnas (variables)
  
  2. `filter()`: filtra (extraer) filas
  
  3. `mutate()`: crea nuevas columnas
  
  4. `arrange()`: ordena filas
  
  5. `summarize()`: crea resúmenes de la tabla
  
  - Más la tubería `%>%` o `|>` 
  
  - y `group_by()`

- NOTA: existe una colección de ["chuletas"](https://rstudio.com/resources/cheatsheets/) de R, p.e., para transformación.

- Todos tienen como primer argumento un *data frame*, los siguientes describen qué hacer (con columnas o filas) y devuelven otro *data frame*

:::: {.notes}

1.- `select()`: **selecciona variables** por nombres o posiciones de columnas, separados por comas

![](figure/select.png){width=55% fig-align="center"}


```{r}
select(presidential, name, party)
select(presidential, 1:2, 4)
```


```{r}
#| echo: false
presidential[,c("name", "party")]
presidential[,c(1:2,4)]
```

::::


## 1. `select()`

- **Selecciona variables** por nombres o posiciones de columnas, separados por comas


![](figure/select.png){width=100% fig-align="center"}


- Ej., un analista solo necesita información básica de ventas

```{r}
select(ventas, id_venta, fecha, id_tienda, id_producto, total)

select(ventas, 1:2, 5, 4, 12)
```

- Aplicación Empresarial:  el equipo de marketing solo necesita información de cliente y venta
```{r}
ventas_mkt <- select(ventas, 
                fecha, id_cliente, id_producto, total)
```



## 2. `filter()`

- Conserva filas en las que una *condición lógica* (o varias separadas por comas) es verdadera

![](figure/mutate.png){width=70% fig-align="center"}


- **Caso de Uso:** Gerente quiere analizar ventas específicas con determinadas características

```{r}
ventas_top      <- filter(ventas, total > 100)

ventas_ene_2024 <- filter(ventas, año == 2024, mes == 1)

ventas_mad_bcn  <- filter(ventas, id_tienda %in% c(1, 2))

ventas_premium  <- filter(ventas, 
                     total > 100 & descuento_porcentaje == 0)
```



```{r}
#| echo: false
#| eval: false
# Ventas superiores a 100€
ventas_altas <- ventas %>%
  filter(total > 100)

# Ventas con descuento
ventas_con_descuento <- ventas %>%
  filter(descuento_porcentaje > 0)

# Filtro simple: ventas del último mes
ventas_enero_2024 <- ventas %>%
  filter(año == 2024, mes == 1)

nrow(ventas_enero_2024)  # ¿Cuántas ventas hubo?

# Ventas en tiendas específicas
ventas_madrid_bcn <- ventas %>%
  filter(id_tienda %in% c(1, 2))

# Combinando condiciones: ventas altas sin descuento
ventas_premium <- ventas %>%
  filter(total > 100, descuento_porcentaje == 0)

# Análisis de fin de semana vs días laborables
ventas_finde <- ventas %>%
  filter(dia_semana %in% c("sábado", "domingo"))

# Ventas problemáticas (alta cantidad + alto descuento)
ventas_revisar <- ventas %>%
  filter(cantidad > 3, descuento_porcentaje >= 20)

# Campaña de verano 2023
ventas_verano_2023 <- ventas %>%
  filter(año == 2023, mes %in% c(6, 7, 8))
```


## Encadenando operaciones con tuberías: `%>%` o `|>`

::: {style="font-size: 95%;"}

- Las operaciones encadenadas no son legibles o crean objetos intermedios

```{r}
ventas_top_markt <- select(filter(ventas, total > 100),
                      fecha, id_cliente, id_producto, total)

ventas_top        <- filter(ventas, total > 100)
ventas_top_markt  <- select(ventas_top, 
                       fecha, id_cliente, id_producto, total)
```

:::

. . .

::: {style="font-size: 95%;"}

- `datos %>% filter(condicion)` equivale a `filter(datos, condicion)`

:::: {.notes}

- Los objetos intermedios son basura innecesaria

- Aplicable a cualquier función: `10 %>% log()` es `log(10)`

- Se pueden anidar operaciones: siempre toman y devuelve un *data frame*

- Fáci y legible
::::

- El anidamiento con tuberías sigue el flujo natural de lectura

  - Toma una tabla y pásala a un comando que acepta y produce un *data frame*
  - Toma la nueva tabla resultante y pásala a otro comando


```{r}
ventas_top_markt <- ventas |>                   
                     filter(total > 100) |>     
                     select(fecha, id_cliente, id_producto, total)
```

:::: {.notes}

* `ggplot2` uwa `+` en lugar de `%>%` (desarrollado antes)

* Atajo de teclado: `Cmd / Ctrl + Mays + M `

* También existe una tubería en R base: `|>`

::::

:::

## Funciones auxiliares de selección (de columnas)


```{r}
# Por rango de columnas
ventas |> select(id_venta:id_tienda)

# Excluir columnas
ventas |> select(-descuento_porcentaje, -descuento_aplicado)

# Por patrón de nombre
ventas |> select(starts_with("id_"))
ventas |> select(ends_with("_porcentaje"))
ventas |> select(contains("descuento"))

# Por tipo de dato
ventas |> select(where(is.numeric))
ventas |> select(where(is.character))
```

-  `pull()`: extrae una única columna, como **vector**
```{r}
ventas |> pull(cantidad) |> mean()
```


:::: {.notes}
- `select()` para muchas variables usando `:` y `-` con nombres

```{r}
library(nycflights13)           # incluye flights:  19 variables
select(flights, year:arr_time)  # desde variable "year" hasta "arr_time"
select(flights, -(year:day))    # todas menos "year, month, day"
```

- `num_range("x", 1:3)`: para x1, x2 y x3.
- `matches()`: nombres que coinciden con una [expresión regular](https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular)

- `matches("(.)\\1")`: selecciona las variables que coinciden con una expresión regular (en este caso, cualquier variable que contenga caracteres repetidos).

::::

## 3. `mutate()`


:::: {.columns}

::: {.column width=55%}

- Crea o modifica variables mediante una *fórmula* a partir de otras columnas

:::

::: {.column width=45%}

![](figure/mutate.png){width=95% fig-align="center"}
::: 

::::

```{r}
ventas2 <- ventas |>
  mutate(
    precio_final_unitario = total / cantidad,
    es_inicio_mes         = day(fecha) <= 7
  )
```

- Funciones para operar con fechas (usando `lubridate`)

:::: {.notes}
- `lubridate` es parte de `tidyverse`
::::

```{r}
ventas_tiempo <- ventas |>
  mutate(
    fecha_completa = as.Date(fecha),  # tipo de objeto "fecha"
    semana_año = week(fecha),
    nombre_mes = month(fecha, label = TRUE),
    dias_desde_venta = as.numeric(Sys.Date() - fecha)
  )
```


## 4. `arrange()`

:::: {.columns}
::: {.column width=55%}
- re-ordena las filas todas las columnas de un *data frame*
  - en orden ascendente (por defecto) o descendente con `desc()`
:::

::: {.column width=45%}
![](figure/arrange.png){width=50% fig-align="center"}
::: 
::::

:::: {.notes}
- similar a Excel
- sort() es para un vector
::::

- *Caso de Uso:* Top 10 ventas más altas
```{r}
ventas |> 
  arrange(desc(total)) |> 
  select(id_venta, fecha, total) |> head(10) 
```

- Ordenamientos **múltiples**: ordena por la primera variable y luego, en caso de empate, por la siguiente, etc.
```{r}
ventas |>
  arrange(id_tienda, desc(total)) |>
  select(id_tienda, id_venta, total) |> head(10)
```

## 5. `summarize()`


:::: {.columns}
::: {.column width=55%}
- Crea un nuevo conjunto de datos de **una sola fila**, con variables nuevas de un solo valor que resumen los datos completos
:::
::: {.column width=45%}
![](figure/summarise.png){width=80% fig-align="center"}
:::
::::
- *Caso de Uso:* KPIs para el dashboard ejecutivo

```{r}
ventas |>
  summarize(
    total_ventas       = n(),           # Volumen (núm. de filas)
    ingresos_totales   = sum(total),    # Ingresos
    ingresos_promedio  = mean(total),
    ingresos_mediano   = median(total),
    descuento_promedio = mean(descuento_porcentaje), # Descuentos
    descuento_total    = sum(descuento_aplicado),
    unidades_vendidas  = sum(cantidad),             # Productos
    clientes_unicos    = n_distinct(id_cliente)     # Clientes 
                         # (núm. de filas distintas)
  )
```


```{r}
#| echo: false
#| eval: false
# **Métricas de Distribución:**
# Análisis de dispersión de ventas
dispersion_ventas <- ventas %>%
  summarize(
    media = mean(total),
    desv_std = sd(total),
    minimo = min(total),
    q25 = quantile(total, 0.25),
    mediana = median(total),
    q75 = quantile(total, 0.75),
    maximo = max(total),
    rango_intercuartil = IQR(total)
  )

dispersion_ventas
```


## `group_by()`: Análisis por Grupos

- Cambia el alcance de *cada función* para que no actúe sobre todo el *data frame* sino en grupos individuales

. . .

- `group_by()` + `summarize()` = el poder de la agregación

  - **Concepto:** cambiar el nivel de análisis: de transacciones a tiendas, productos, etc.)
  
  - En Excel: *Tablas dinámicas*, *AGRUPARPOR()* (y *SUMAR.SI*/*SUMIF*) 

```{r}
ventas                             # tabla a nivel de transacción

ventas |>
  summarize(ingresos = sum(total)) # resumen global

ventas |>
  group_by(id_tienda) |>
  summarize(ingresos = sum(total)) # resumen por tienda
                                   # tabla a nivel de tienda
                                     
```

:::: {.notes}

- `group_by()` similar a facet

-  Ver  `ventas |> group_by(id_tienda)`: tibble muestra que hay dos grupos

- datos de información/ventas por empleado a información por tienda

- DEBEN INCLUIRSE variables que se quieran mantener
::::


## Combinando `mutate()` con `group_by()`

- **Diferencia Clave:**

  - `group_by() + summarize()`: Reduce filas (nuevo dataset agregado a nivel de los grupos)
  
  - `group_by() + mutate()`: Mantiene filas (añade columnas calculadas por grupo a nivel de la tabla original)

- Ejemplo: Porcentaje de las ventas mensuales que representa cada transacción

```{r}
ventas |>
  group_by(id_tienda, mes) |>
  mutate(
    ventas_tienda_mes = sum(total),
    pct_de_ventas_mes = total / ventas_tienda_mes * 100
  ) |>
  slice_max(pct_de_ventas_mes) |> 
  select(id_tienda, mes, id_venta, total, pct_de_ventas_mes)
```

## Análisis multinivel y `ungroup()`

::: {style="font-size: 92%;"}
- Encontrar la fecha con la mayor venta por tienda

```{r}
ventas |>
  group_by(id_tienda) |>
  arrange(desc(total)) |>  
  slice(1) |>                     # Primera fila (de cada grupo)
  select(id_tienda, fecha, total)
# alternativa: slice_max()
```


- **IMPORTANTE:** No olvidar `ungroup()` o `.groups = "drop"` después de terminar operaciones agrupadas


:::: {.notes}
- Después de group_by() + mutate():

  - Si tu siguiente operación debe ser GLOBAL → usa ungroup()

  - Si debe seguir POR GRUPO → no uses ungroup()

- Después de group_by() + summarize():

  - summarize() ya reduce un nivel de agrupación

  - Si tenías múltiples grupos, sigue agrupado por los anteriores

  - Usa .groups = "drop" o ungroup() para estar seguro
::::

- Cálculo de Porcentajes Globales: sin desagrupar, `sum(total)` suma *por tienda* → siempre da 100%


```{r}
ventas |>
  group_by(id_tienda) |>
  mutate(ventas_tienda = sum(total)) |>
  ungroup() |>
  mutate(porcentaje = ventas_tienda / sum(total) * 100)
```

:::

## Análisis multinivel y  `ungroup()` (cont.)

::: {style="font-size: 92%;"}
- Filtrar Top Global: sin desagrupar, será top 5 de *cada* tienda

```{r}
ventas |>
  group_by(id_tienda) |>
  mutate(ventas_tienda = sum(total), 
         .groups = "drop" ) |>
  arrange(desc(ventas_tienda)) |>
  slice_head(n = 5)
```


- Media Global después de agrupar: sin desagrupar, 1 fila por tienda (media mensual de cada tienda)

```{r}
# Ventas por tienda y mes
ventas_mes_por_tienda <- ventas |>
  group_by(id_tienda, mes) |>
  summarize(total_mes = sum(total))

ventas_mensuales_medias <- ventas_mes_por_tienda |>
  ungroup() |>
  summarize(media = mean(total_mes))
# Resultado: 1 fila (media de todos los meses de todas las tiendas)
```
:::

:::: {.notes}

- Ranking de Productos

```{r}
#| echo: false
#| eval: false
ventas |>
  group_by(id_producto) |>
  summarize(
    unidades_vendidas = sum(cantidad),
    ingresos_totales = sum(total),
    .groups = "drop"                  # en este caso ungroup no es necesario
  ) |>
  arrange(desc(ingresos_totales))
```

```{r}
ventas |>
  group_by(id_producto) |>
  summarize(
    unidades_vendidas = sum(cantidad),
    ingresos_totales = sum(total)
  ) |>
  ungroup() |>                     # posteriores NO por grupos
  arrange(desc(ingresos_totales))

```


**Aplicación: Segmentación de Clientes**

```{r}
# Calcular valor del cliente
valor_cliente <- ventas |>
  group_by(id_cliente) |>
  mutate(
    num_compras_cliente = n(),
    gasto_total_cliente = sum(total),
    ticket_promedio = mean(total),
    
    # Clasificación RFM simplificada
    recencia_dias = as.numeric(max(fecha) - min(fecha)),
    frecuencia = n(),
    monetario = sum(total)
  ) |>
  ungroup()
```

::::



:::: {.notes}


**Problema:** Análisis de ventas navideñas en Madrid

```{r}
# SIN pipe: difícil de leer, muchas variables intermedias
ventas_madrid <- filter(ventas, id_tienda == 1)
ventas_madrid_navidad <- filter(ventas_madrid, mes == 12)
ventas_resumen <- summarize(ventas_madrid_navidad, 
                            total = sum(total),
                            n = n())

# CON pipe: flujo natural de lectura
analisis_navidad_madrid <- ventas |>
  filter(id_tienda == 1) |>
  filter(mes == 12) |>
  summarize(
    ingresos_totales = sum(total),
    num_transacciones = n(),
    ticket_promedio = mean(total)
  )

analisis_navidad_madrid
```

**Análisis Completo Paso a Paso**

**Objetivo:** Análisis de campaña de descuentos del Q4 2023

```{r}
analisis_campana_q4 <- ventas |>
  # 1. Filtrar período relevante
  filter(año == 2023, trimestre == 4) |>
  
  # 2. Agregar categoría de descuento
  mutate(
    tipo_descuento = case_when(
      descuento_porcentaje == 0 ~ "Sin descuento",
      descuento_porcentaje <= 10 ~ "Descuento bajo",
      descuento_porcentaje <= 20 ~ "Descuento medio",
      TRUE ~ "Descuento alto"
    )
  ) |>
  
  # 3. Agrupar por tipo de descuento
  group_by(tipo_descuento) |>
  
  # 4. Calcular métricas
  summarize(
    num_ventas = n(),
    ingresos_totales = sum(total),
    ticket_promedio = mean(total),
    unidades_vendidas = sum(cantidad),
    .groups = "drop"
  ) |>
  
  # 5. Ordenar por ingresos
  arrange(desc(ingresos_totales)) |>
  
  # 6. Calcular porcentajes
  mutate(
    pct_ventas = round(num_ventas / sum(num_ventas) * 100, 1),
    pct_ingresos = round(ingresos_totales / sum(ingresos_totales) * 100, 1)
  )

analisis_campana_q4
```

**Interpretación de Resultados:**

- Cada paso transforma el dataset

- El pipe hace el código legible como una narrativa

- Fácil añadir/quitar pasos para exploración
::::


## Funciones auxiliares para filas

- Extraer filas pero NO por condición: por posición (`slice()`, `slice_head()`), aleatoriamente (`slice_sample()`), etc.


```{r}
ventas |> slice_max(total, n = 5) # Top 5 ventas
ventas |> slice_sample(n = 100)   # sub-muestra aleatoria
```

:::: {.notes}
- `slice_head()`, `slice_tail()`, `slice_min()`, `slice_max()`
::::


* `distinct()`: extrae sólo las filas únicas (una o varias variables)
 
```{r}
#| echo: true
#| eval: false
ventas %>% distinct(id_producto)
```



* `drop_na()` y `replace_na()`: elimina/reemplaza filas con valores ausentes

```{r}
# Quita filas con NA en cualquier variable
ventas_completas <- ventas %>%
  drop_na()                    

# solo quita si precio_unitario es NA
ventas_completas_precio <- ventas %>%
  drop_na(precio_unitario)  
```


<!--
  - transmute(): como mutate() pero solo mantiene las variables creadas
  
  - relocate(): cambiar orden de columnas
-->

:::: {.notes}

**¿Cómo tratar los ("contagiosos") `NA`?**
* Eliminar observaciones con valores ausentes, PERO

    - en *alguna variable*, con `na.rm=TRUE` o `filter(!is.na(x))` o `drop_na(x)` 

    - en *todo* el conjunto de datos con `drop_na()`

    -  en `cor()`, `use = "complete.obs"`

```{r}
#| echo: false
data <- tibble(x1 = c(1:4, NA, 6.0, 7, NA), x2 = c(NA, 12:14, NA, 16.0, 17:18) )

data %>% summarize(num = n(), meanNA = mean(x1), mean = mean(x1, na.rm = TRUE))

data %>% filter(!is.na(x1)) %>% 
  summarize(num = n(), meanNA = mean(x1), mean   = mean(x1, na.rm = TRUE))
```


```{r}
#| echo: false
data <- tibble(x1 = c(1:4, NA, 6.0, 7, NA), x2 = c(NA, 12:14, NA, 16.0, 17:18) )

data %>% summarize(num = n(), meanNA = mean(x1), mean = mean(x1, na.rm = TRUE))

data %>% drop_na(x1) %>% summarize(num = n(), mean = mean(x1))   # drop_na(x2)?
data %>% drop_na()   %>% summarize(num = n(), mean = mean(x1))
```

- Reemplazar con un valor, PERO ¿cúal?

  - NA por no presentarse a un examen es cero

  - NA por no contestar a pregunta de renta o gasto es ¿cero?

```{r}
#| echo: false
data %>% mutate(x1 = if_else(is.na(x1), 0, x1)) %>% summarize(num = n(), mean = mean(x1))
data %>% mutate(x1 = replace_na(x1,0))          %>% summarize(num = n(), mean = mean(x1))
```


- na.omit() vs. drop_na: el primero es de base (stats) el otro de tidyr

::::

## Otras funciones auxilidares de `tidyverse`

::: {style="font-size: 90%;"}
- Muchas funciones son equivalentes a otras de R base:

    - `parse_number()`, `parse_factor()`, etc. por `as.numeric()`, `as.factor()`, etc.
    - `bind_cols()` y `bind_rows()` por `cbind()` y `rbind()`

    - `if_else()` y `case_when()` para ejecución condicional (`ifelse()`)

```{r}
ventas |>
  mutate(
    tipo_venta = if_else(total > 100, "Alta", "Baja"), # condición simple
    categoria_cliente = case_when(              # múltiples condiciones
      total < 30  ~ "Económico",
      total < 100 ~ "Estándar",
      TRUE        ~ "Premium"               # OJO: convertir a factor
    )
  )
```

  
* Discretizar variables<!--numéricas a categóricas-->: `cut_interval()`, `cut_number()`, `cut_width()`

```{r}
#| echo: false
flights %>% mutate(retraso = cut_width(dep_delay,2))   # retraso es factor
```


- Funciones para fechas de `lubridate`: `year()`, `month()`, ``day()`, `quarter()`, `week()`

```{r}
#| echo: false
#| eval: false

# Análisis temporal detallado
ventas_tiempo_detalle <- ventas %>%
  mutate(
    # Componentes de fecha
    año = year(fecha),
    mes = month(fecha),
    dia = day(fecha),
    trimestre = quarter(fecha),
    semana = week(fecha),
    
    # Nombres legibles
    mes_nombre = month(fecha, label = TRUE, abbr = FALSE),
    dia_semana_nombre = wday(fecha, label = TRUE, abbr = FALSE),
    
    # Flags útiles
    es_lunes = wday(fecha) == 2,
    es_fin_semana = wday(fecha) %in% c(1, 7),
    es_quincena = day(fecha) %in% c(1, 15),
    
    # Diferencias temporales
    dias_desde_hoy = as.numeric(Sys.Date() - fecha),
    semanas_desde_inicio = as.numeric(difftime(fecha, min(fecha), units = "weeks"))
  )

# Ventas por día de la semana
ventas_tiempo_detalle %>%
  group_by(dia_semana_nombre) %>%
  summarize(
    num_ventas = n(),
    ingresos = sum(total),
    ticket_promedio = mean(total)
  ) %>%
  arrange(desc(ingresos))
```


::::


## Funciones auxiliares de creación de variables

- `rename()`: cambiar el nombre de una columna
```{r}
ventas_renamed <- ventas |>
  rename(
    fecha_venta = fecha,
    monto_total = total
  )
```

:::: {.notes}
  ![](figure/rename.png){width=70% fig-align="center"}
  
- transmute(): como mutate() pero solo mantiene las variables creadas
  
- relocate(): cambiar orden de columnas

```{r}
#| echo: false
#| eval: false
# Reordenar columnas
ventas_reordenadas <- ventas %>%
  select(id_venta, fecha, total, everything())  # total al inicio

# Relocate (mover columnas)
ventas %>%
  relocate(total, .after = fecha) %>%
  relocate(starts_with("id_"), .before = everything())
```

::::

- `across()`: aplica la misma transformación a múltiples columnas

```{r}
ventas |> mutate(across(c(cantidad, subtotal:total), ~ log(.x)))
ventas |> mutate(across(where(is.character), ~ parse_factor(.x)))
```


-  Operadores aritméticos (`+`, `-`, `*`, `/`, `^`, `%/%`, `%%`) y lógicos (`<`, `<=`, `>`, `>=`, `!=`)

- Funciones como `log()`, `lag()`, `lead()`, `cumsum()`, `row_number()` etc.


:::: {.notes}


- combinados con otros: funciones de "agregación" `x - mean(x)`, `y - sum(y)` 

- Ordenamiento: `row_number()` 

- `min_rank()`, `row_number()` y otras de `dplyr::ranking`

- `percent_rank()`, `cume_dist()`

```{r}
#| echo: false
y <- c (10, 2, 2, NA, 30, 4)
min_rank(y)               
min_rank(desc(y))
row_number(y)
```

- Agregados acumulativos y móviles: ver ayuda de `cumsum()`  y `cummean()` 

```{r}
#| echo: false
cumsum(1:10)
cumprod(1:10)
cummin(1:10)
cummax(1:10)
cummean(1:10)
```


::::

## Funciones auxiliares de resumen

- `count()`: cuenta los valores únicos de una o más variables

```{r}
ventas |> count(id_tienda)
# ventas |> group_by(id_tienda) |>  summarize(n = n())
ventas |> count(id_tienda, sort = TRUE)
```

```{r}
#| echo: false
#| eval: false
ventas |>
  group_by(id_tienda) |>
  summarize(n = n()) |>
  arrange(desc(n))


# Conteos múltiples
ventas |>
  count(id_tienda, mes, name = "num_ventas")

# add_count(): añade conteo sin agrupar
ventas |>
  add_count(id_producto, name = "veces_vendido") |>
  filter(veces_vendido > 50) |>
  select(id_venta, id_producto, veces_vendido)
```

. . .

* Medidas de centralidad y de dispersión: `mean(x)`, `median(x)`, `sd(x)`, `IQR(x)` <!--, `mad(x)` -->

* Medidas de rango: `min(x)`, `quantile(x, 0.25)`, `max(x)`

* Medidas de posición: `first(x)`, `nth(x, 2)`, `last(x)`. 

:::: {.notes}
- similar a `x[1]`, `x[2]` y `x[length(x)]`
::::

* Sumas, productos, etc.

* Conteos: 

  - `n()`: observaciones totales (tamaño del grupo)
  
  - `n_distinct(x)`:  filas distintas en `x`

:::: {.notes}

- `sum(!is.na(x))`: observaciones no ausentes

- más rápido que unique() 
::::
  

```{r}
#| echo: false
#| eval: false
# Valores distintos
ventas %>%
  summarize(
    productos_unicos = n_distinct(id_producto),
    clientes_unicos = n_distinct(id_cliente)
  )
```



# Transformación de Datos: Pivotar

:::: {.notes}
** Cuatro representaciones de los mismos datos
:::: {.columns}

::: {.column width="50%"}
```{r}
library(tidyverse)
table1     # datos ordenados
table2     # varios valores por celda
```


![](figure/tidyvsmessy01_n.png){width=60% fig-align="center"}

![](figure/tidyvsmessy02_n.png){width=60% fig-align="center"}

:::

::: {.column width="50%"}

```{r}
table3     # más de una variable en una columna
table4a 
table4b
```

* `table4a` y `table4b` ofrecen información útil para presentación
pero
- variables tanto en filas como columnas -->
- las cabeceras de columna son valores, no nombres de variables. -->

![](figure/tidyvsmessy04a_n.png){width=60% fig-align="center"}

:::

::::

::::


## Mismos datos, dos formatos: ancho o largo

:::: {.columns}

::: {.column width=50%}

* La utilidad de almacenar los datos en un rectángulo ancho ("wide") o en uno largo ("long")  depende de qué queramos hacer

  * P.e., Excel prefiere el formato largo para tablas dinámicas, fórmulas de agregación (*SUMAR.SI*) y algunos gráficos


:::

::: {.column width=50%}

![](./figure/original-dfs-tidy.png){width=100%}
:::

::::

:::: {.notes}
* En general, el formato largo es más útil para el análisis 

* El cambio de forma "reshaping"


* Cambiar entre representación larga y ancha se conoce como **pivotar (o girar)**

DISTINTO de trasponer filas y columnas en Excel

Existe una función para pivotar en Excel


* Los datos en bruto suelen estar en formato largo: facilita la recogida de información, no el análisis
::::

* El cambio de forma  entre formatos es una tarea habitual del analista de datos. 

* Cambiar entre representación larga y ancha se conoce como **pivotar (o girar)**

```{r}
table4a        # formato ancho
table1         # formato largo
```


:::: {.notes}
**Cambiar la forma de una tabla (pivotar / girar)**

* Las celdas en un formato se reordenan en el otro

![](figure/tidyr-longer-wider.gif){width=45% fig-align="center"}

* Los metadatos que no se reordenan son extendidos/reducidos para no perder información. 

https://tidyr.tidyverse.org/ 

* reshape en R base:  https://jozef.io/r001-reshape/

https://www.r-bloggers.com/2019/07/how-to-reshape-a-dataframe-from-wide-to-long-or-long-to-wide-format/


<https://www.r-bloggers.com/how-to-reshape-data-in-r-tidyr-vs-reshape2/>

<https://www.r-bloggers.com/pivoting-tidily/>


**Verbos principales en `tidyr`**

* `pivot_longer()`: cambia la forma de "anchos" a "largos" (+filas/-cols)

    + **ordena** datos originales para facilitar el análisis.

* `pivot_wider()` cambia la forma de "largos" a "anchos" (+cols/-filas)

    + útil para crear tablas de resumen o un formato para otras herramientas.

![](figure/long-wide.png){width=75% fig-align="center"}



 La longitud es un término relativo, y sólo se puede decir (por ejemplo) que el conjunto de datos A es más largo que el conjunto de datos B.

::::


## El Problema del Formato "Ancho"

- **Situación Real:** Reporte mensual enviado por finanzas

```{r}
ventas_ancho <- tibble(
  tienda = c("Madrid", "Barcelona", "Valencia"),
  Ene_2023 = c(45000, 52000, 38000),
  Feb_2023 = c(48000, 54000, 41000),
  Mar_2023 = c(51000, 56000, 39000),
  Abr_2023 = c(49000, 55000, 42000)
)
```

- **Problemas:**
  - No se puede filtrar por mes fácilmente

  - No se puede hacer group_by por mes

  - Difícil calcular tendencias temporales

  - No es "tidy data"

## `pivot_longer()`: De Ancho a Largo

```{r}
# Convertir a formato largo (ordenado)
ventas_largo <- ventas_ancho %>%
  pivot_longer(
    cols = Ene_2023:Abr_2023,        # columnas a pivotar
    names_to = "mes_año",             # nombre para los encabezados
    values_to = "ingresos"            # nombre para los valores
  )

ventas_largo
```

**Ahora sí podemos analizar:**

```{r}
# Separar mes y año
ventas_largo_limpio <- ventas_largo %>%
  separate(mes_año, into = c("mes", "año"), sep = "_") %>%
  mutate(año = as.numeric(año))

# Análisis temporal por tienda
ventas_largo_limpio %>%
  group_by(tienda) %>%
  mutate(
    crecimiento = ingresos - lag(ingresos),
    pct_crecimiento = round((ingresos - lag(ingresos)) / lag(ingresos) * 100, 1)
  )

# Visualización fácil
library(ggplot2)
ggplot(ventas_largo_limpio, aes(x = mes, y = ingresos, color = tienda, group = tienda)) +
  geom_line() +
  geom_point() +
  theme_minimal() +
  labs(title = "Evolución de Ingresos por Tienda")
```

## Caso Real: Datos de Ventas Mensuales

```{r}
# Crear reporte mensual en formato ancho
reporte_mensual_ancho <- ventas %>%
  mutate(mes_nombre = paste(mes, año, sep = "_")) %>%
  group_by(id_tienda, mes_nombre) %>%
  summarize(ingresos = sum(total), .groups = "drop") %>%
  pivot_wider(
    names_from = mes_nombre,
    values_from = ingresos,
    values_fill = 0  # llenar con 0 si no hay ventas
  )

head(reporte_mensual_ancho)

# Volver a formato largo para análisis
reporte_mensual_largo <- reporte_mensual_ancho %>%
  pivot_longer(
    cols = -id_tienda,
    names_to = "periodo",
    values_to = "ingresos"
  ) %>%
  separate(periodo, into = c("mes", "año"), sep = "_", convert = TRUE)

reporte_mensual_largo
```

## `pivot_wider()`: De Largo a Ancho

**Caso de Uso:** Crear tabla de presentación para ejecutivos

```{r}
# Tabla comparativa: ingresos por región y trimestre
tabla_ejecutiva <- ventas %>%
  left_join(tiendas %>% select(id_tienda, region), by = "id_tienda") %>%
  filter(año == 2023) %>%
  group_by(region, trimestre) %>%
  summarize(ingresos = sum(total), .groups = "drop") %>%
  pivot_wider(
    names_from = trimestre,
    values_from = ingresos,
    names_prefix = "Q"
  ) %>%
  mutate(
    Total = Q1 + Q2 + Q3 + Q4,
    across(Q1:Q4, ~round(.x / 1000, 1))  # en miles
  )

tabla_ejecutiva
```

## Separar y Unir Columnas

```{r}
# separate(): dividir columna en múltiples
datos_ejemplo <- tibble(
  codigo = c("MAD-001", "BCN-002", "VAL-003"),
  fecha_hora = c("2023-01-15 10:30", "2023-01-16 14:20", "2023-01-17 09:15")
)

datos_separados <- datos_ejemplo %>%
  separate(codigo, into = c("ciudad", "numero"), sep = "-") %>%
  separate(fecha_hora, into = c("fecha", "hora"), sep = " ")

datos_separados

# unite(): combinar columnas
datos_unidos <- datos_separados %>%
  unite("codigo_completo", ciudad, numero, sep = "-") %>%
  unite("timestamp", fecha, hora, sep = " ")

datos_unidos
```

# Datos Relacionales

## Por Qué Múltiples Tablas

**Ventajas del Diseño Relacional:**

1. **Eficiencia:** No repetir información
2. **Consistencia:** Un solo lugar para actualizar
3. **Integridad:** Relaciones claras entre datos
4. **Escalabilidad:** Fácil añadir nuevas tablas

```{r}
# Ejemplo: información duplicada vs relacional

# MAL: Todo en una tabla (información repetida)
ventas_todo_junto <- ventas %>%
  left_join(productos, by = "id_producto") %>%
  left_join(tiendas, by = "id_tienda") %>%
  left_join(clientes, by = "id_cliente")

# BIEN: Tablas separadas, unir solo cuando necesario
# ventas, productos, tiendas, clientes son tablas independientes
```

## Tipos de Uniones: Visión General

```{r}
# Datos de ejemplo para ilustrar
df1 <- tibble(id = 1:3, valor_x = c("A", "B", "C"))
df2 <- tibble(id = c(1, 2, 4), valor_y = c("X", "Y", "Z"))

# inner_join: solo coincidencias
inner_join(df1, df2, by = "id")  # resultado: 1, 2

# left_join: todas de la izquierda
left_join(df1, df2, by = "id")   # resultado: 1, 2, 3 (3 con NA)

# right_join: todas de la derecha
right_join(df1, df2, by = "id")  # resultado: 1, 2, 4 (4 con NA)

# full_join: todas de ambas
full_join(df1, df2, by = "id")   # resultado: 1, 2, 3, 4
```

## Caso Real: Enriquecer Datos de Ventas

**Objetivo:** Análisis completo con información de todas las tablas

```{r}
# Crear dataset completo para análisis
ventas_completo <- ventas %>%
  # Información de productos
  left_join(productos %>% select(id_producto, nombre_producto, id_categoria, precio, costo),
            by = "id_producto") %>%
  
  # Información de categorías
  left_join(categorias, by = "id_categoria") %>%
  
  # Información de tiendas
  left_join(tiendas %>% select(id_tienda, nombre_tienda, region, tamaño_m2),
            by = "id_tienda") %>%
  
  # Información de clientes
  left_join(clientes %>% select(id_cliente, programa_fidelidad, fecha_registro),
            by = "id_cliente") %>%
  
  # Información de empleados
  left_join(empleados %>% select(id_empleado, puesto),
            by = "id_empleado")

# Ahora podemos hacer análisis complejos
glimpse(ventas_completo)
```

**Análisis Enriquecido:**

```{r}
# Rentabilidad por categoría y región
analisis_rentabilidad <- ventas_completo %>%
  mutate(
    margen_venta = precio - costo,
    rentabilidad = margen_venta * cantidad
  ) %>%
  group_by(nombre_categoria, region) %>%
  summarize(
    num_ventas = n(),
    ingresos = sum(total),
    rentabilidad_total = sum(rentabilidad, na.rm = TRUE),
    margen_porcentaje = round(mean(margen_venta / precio * 100, na.rm = TRUE), 1),
    .groups = "drop"
  ) %>%
  arrange(desc(rentabilidad_total))

head(analisis_rentabilidad, 10)
```


**Caso de Uso:** Performance por región y mes

```{r}
# Primero unir con info de tiendas para obtener región
performance_regional <- ventas %>%
  left_join(tiendas %>% select(id_tienda, region), by = "id_tienda") %>%
  group_by(region, año, mes) %>%
  summarize(
    ventas_totales = n(),
    ingresos = sum(total),
    ticket_promedio = mean(total),
    .groups = "drop"
  ) %>%
  arrange(region, año, mes)

head(performance_regional, 10)
```


**Caso de Uso:** Performance por región y mes

```{r}
# Primero unir con info de tiendas para obtener región
performance_regional <- ventas %>%
  left_join(tiendas %>% select(id_tienda, region), by = "id_tienda") %>%
  group_by(region, año, mes) %>%
  summarize(
    ventas_totales = n(),
    ingresos = sum(total),
    ticket_promedio = mean(total),
    .groups = "drop"
  ) %>%
  arrange(region, año, mes)

head(performance_regional, 10)
```

- **Aplicación:** Crecimiento anual

```{r}
# Comparación mensual por región
crecimiento_mensual <- performance_regional %>%
  group_by(region, mes) %>%
  arrange(año) %>%
  mutate(
    ingresos_año_anterior = lag(ingresos),
    crecimiento_absoluto = ingresos - ingresos_año_anterior,
    crecimiento_porcentual = round(
      (ingresos - ingresos_año_anterior) / ingresos_año_anterior * 100, 1
    )
  ) %>%
  filter(!is.na(crecimiento_porcentual))

# Regiones con mayor crecimiento
crecimiento_mensual %>%
  filter(año == 2023) %>%
  group_by(region) %>%
  summarize(crecimiento_promedio = mean(crecimiento_porcentual, na.rm = TRUE)) %>%
  arrange(desc(crecimiento_promedio))
```


## Uniones de Filtrado

**semi_join:** Mantener filas que tienen coincidencia

```{r}
# Clientes que SÍ han comprado
clientes_activos <- clientes %>%
  semi_join(ventas, by = "id_cliente")

nrow(clientes_activos)  # ¿Cuántos clientes activos?

# Productos que SÍ se han vendido
productos_vendidos <- productos %>%
  semi_join(ventas, by = "id_producto")
```

**anti_join:** Mantener filas que NO tienen coincidencia

```{r}
# Clientes registrados pero sin compras
clientes_sin_compras <- clientes %>%
  anti_join(ventas, by = "id_cliente")

nrow(clientes_sin_compras)  # Oportunidad de marketing

# Productos en catálogo pero nunca vendidos
productos_sin_vender <- productos %>%
  anti_join(ventas, by = "id_producto") %>%
  filter(activo == TRUE)  # y que estén activos

nrow(productos_sin_vender)  # ¿Eliminar del catálogo?
```

## Uniones con Claves Múltiples

```{r}
# Crear tabla de objetivos mensuales por tienda
objetivos <- tibble(
  id_tienda = rep(1:12, each = 12),
  mes = rep(1:12, times = 12),
  objetivo_ingresos = runif(144, 30000, 80000)
)

# Comparar ventas reales vs objetivos
comparacion_objetivos <- ventas %>%
  group_by(id_tienda, mes) %>%
  summarize(ingresos_reales = sum(total), .groups = "drop") %>%
  left_join(objetivos, by = c("id_tienda", "mes")) %>%
  mutate(
    diferencia = ingresos_reales - objetivo_ingresos,
    cumplimiento_pct = round(ingresos_reales / objetivo_ingresos * 100, 1),
    cumple_objetivo = cumplimiento_pct >= 100
  )

# Tiendas que más superan objetivos
comparacion_objetivos %>%
  filter(cumple_objetivo) %>%
  group_by(id_tienda) %>%
  summarize(
    meses_cumplidos = n(),
    exceso_promedio = mean(diferencia)
  ) %>%
  arrange(desc(meses_cumplidos))
```

## Caso de Estudio Completo: Análisis de Devoluciones

### Problema de Negocio

**Contexto:** Gerente de operaciones preocupado por devoluciones

**Preguntas:**
1. ¿Qué productos tienen más devoluciones?
2. ¿Hay patrones por tienda o categoría?
3. ¿Impacto financiero de las devoluciones?
4. ¿Recomendaciones accionables?

### Paso 1: Exploración Inicial

```{r}
# Visión general de devoluciones
glimpse(devoluciones)

# Estadísticas básicas
devoluciones %>%
  summarize(
    total_devoluciones = n(),
    tasa_devolucion = n() / nrow(ventas) * 100,
    reembolso_total = sum(reembolso),
    reembolso_promedio = mean(reembolso),
    dias_promedio = mean(as.numeric(fecha_devolucion - 
                        ventas$fecha[match(id_venta, ventas$id_venta)]), na.rm = TRUE)
  )
```

### Paso 2: Análisis por Motivo

```{r}
# Distribución de motivos
analisis_motivos <- devoluciones %>%
  group_by(motivo) %>%
  summarize(
    num_devoluciones = n(),
    reembolso_total = sum(reembolso),
    .groups = "drop"
  ) %>%
  mutate(
    pct_devoluciones = round(num_devoluciones / sum(num_devoluciones) * 100, 1),
    pct_reembolso = round(reembolso_total / sum(reembolso_total) * 100, 1)
  ) %>%
  arrange(desc(num_devoluciones))

analisis_motivos

# Visualización
ggplot(analisis_motivos, aes(x = reorder(motivo, num_devoluciones), 
                              y = num_devoluciones)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(title = "Devoluciones por Motivo",
       x = "Motivo", y = "Número de Devoluciones") +
  theme_minimal()
```

## Caso de Estudio Completo (cont.)

### Paso 3: Productos Problemáticos

```{r}
# Unir devoluciones con ventas y productos
productos_devueltos <- devoluciones %>%
  left_join(ventas %>% select(id_venta, id_producto, id_tienda), 
            by = "id_venta") %>%
  left_join(productos %>% select(id_producto, nombre_producto, id_categoria),
            by = "id_producto") %>%
  left_join(categorias %>% select(id_categoria, nombre_categoria),
            by = "id_categoria")

# Top productos con más devoluciones
productos_problema <- productos_devueltos %>%
  group_by(id_producto, nombre_producto, nombre_categoria) %>%
  summarize(
    num_devoluciones = n(),
    reembolso_total = sum(reembolso),
    .groups = "drop"
  ) %>%
  arrange(desc(num_devoluciones)) %>%
  head(20)

productos_problema

# Calcular tasa de devolución por producto
tasa_devolucion_producto <- ventas %>%
  group_by(id_producto) %>%
  summarize(
    veces_vendido = n(),
    .groups = "drop"
  ) %>%
  left_join(
    devoluciones %>%
      left_join(ventas %>% select(id_venta, id_producto), by = "id_venta") %>%
      group_by(id_producto) %>%
      summarize(veces_devuelto = n(), .groups = "drop"),
    by = "id_producto"
  ) %>%
  mutate(
    veces_devuelto = replace_na(veces_devuelto, 0),
    tasa_devolucion = round(veces_devuelto / veces_vendido * 100, 2)
  ) %>%
  filter(veces_vendido >= 10) %>%  # solo productos con suficientes ventas
  arrange(desc(tasa_devolucion))

head(tasa_devolucion_producto, 10)
```

### Paso 4: Análisis por Tienda y Categoría

```{r}
# Devoluciones por tienda
devoluciones_tienda <- productos_devueltos %>%
  left_join(tiendas %>% select(id_tienda, nombre_tienda, region),
            by = "id_tienda") %>%
  group_by(id_tienda, nombre_tienda, region) %>%
  summarize(
    num_devoluciones = n(),
    reembolso_total = sum(reembolso),
    .groups = "drop"
  )

# Calcular tasa de devolución por tienda
ventas_por_tienda <- ventas %>%
  group_by(id_tienda) %>%
  summarize(num_ventas = n(), .groups = "drop")

comparacion_tiendas <- ventas_por_tienda %>%
  left_join(devoluciones_tienda, by = "id_tienda") %>%
  mutate(
    num_devoluciones = replace_na(num_devoluciones, 0),
    tasa_devolucion = round(num_devoluciones / num_ventas * 100, 2)
  ) %>%
  left_join(tiendas %>% select(id_tienda, nombre_tienda, region),
            by = "id_tienda") %>%
  arrange(desc(tasa_devolucion))

comparacion_tiendas

# Por categoría
devoluciones_categoria <- productos_devueltos %>%
  group_by(nombre_categoria) %>%
  summarize(
    num_devoluciones = n(),
    reembolso_total = sum(reembolso),
    motivo_principal = names(sort(table(motivo), decreasing = TRUE))[1],
    .groups = "drop"
  ) %>%
  arrange(desc(num_devoluciones))

devoluciones_categoria
```

## Caso de Estudio Completo (y 3)
### Paso 5: Impacto Financiero

```{r}
# Impacto total
impacto_financiero <- ventas %>%
  summarize(
    ingresos_brutos = sum(total),
    .groups = "drop"
  ) %>%
  mutate(
    reembolsos = sum(devoluciones$reembolso),
    ingresos_netos = ingresos_brutos - reembolsos,
    tasa_devolucion_financiera = round(reembolsos / ingresos_brutos * 100, 2)
  )

impacto_financiero

# Impacto por período
impacto_temporal <- ventas %>%
  mutate(año_mes = paste(año, sprintf("%02d", mes), sep = "-")) %>%
  group_by(año_mes) %>%
  summarize(
    ingresos_brutos = sum(total),
    .groups = "drop"
  ) %>%
  left_join(
    devoluciones %>%
      left_join(ventas %>% select(id_venta, año, mes), by = "id_venta") %>%
      mutate(año_mes = paste(año, sprintf("%02d", mes), sep = "-")) %>%
      group_by(año_mes) %>%
      summarize(reembolsos = sum(reembolso), .groups = "drop"),
    by = "año_mes"
  ) %>%
  mutate(
    reembolsos = replace_na(reembolsos, 0),
    ingresos_netos = ingresos_brutos - reembolsos,
    tasa_devolucion = round(reembolsos / ingresos_brutos * 100, 2)
  ) %>%
  arrange(año_mes)

# Visualizar tendencia
ggplot(impacto_temporal, aes(x = año_mes, y = tasa_devolucion, group = 1)) +
  geom_line(color = "red", size = 1) +
  geom_point() +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Evolución de la Tasa de Devolución",
       x = "Período", y = "Tasa de Devolución (%)")
```

## Caso de Estudio Completo (y 4)

### Paso 6: Recomendaciones Accionables

```{r}
# Crear informe ejecutivo
informe_devoluciones <- list(
  resumen = devoluciones %>%
    summarize(
      total_devoluciones = n(),
      tasa_global = round(n() / nrow(ventas) * 100, 2),
      costo_total = sum(reembolso)
    ),
  
  productos_criticos = tasa_devolucion_producto %>%
    filter(tasa_devolucion > 10) %>%
    head(10),
  
  tiendas_problema = comparacion_tiendas %>%
    filter(tasa_devolucion > 7) %>%
    head(5),
  
  categorias_riesgo = devoluciones_categoria %>%
    head(3)
)

# Mostrar informe
informe_devoluciones
```

**Recomendaciones:**

1. **Productos:** Revisar calidad de productos con tasa >10%
2. **Tiendas:** Capacitación en tiendas con alta tasa de devolución
3. **Categorías:** Mejorar descripción de productos en categorías problemáticas
4. **Procesos:** Implementar mejor política de cambios para "Talla incorrecta"

## Buenas Prácticas y Errores Comunes

### Trabajar con Valores Ausentes (NA)

```{r}
# Identificar NAs
ventas %>%
  summarize(
    na_cliente = sum(is.na(id_cliente)),
    na_producto = sum(is.na(id_producto)),
    na_total = sum(is.na(total))
  )

# Filtrar NAs
ventas_sin_na <- ventas %>%
  filter(!is.na(id_cliente))

# Eliminar filas con ANY NA
ventas_completas <- ventas %>%
  drop_na()

# Eliminar NAs de columnas específicas
ventas %>%
  drop_na(id_cliente, total)

# Reemplazar NAs
clientes_limpio <- clientes %>%
  mutate(
    programa_fidelidad = replace_na(programa_fidelidad, "Básico")
  )

# NA en operaciones: usar na.rm = TRUE
ventas %>%
  summarize(
    media_con_na = mean(descuento_porcentaje),
    media_sin_na = mean(descuento_porcentaje, na.rm = TRUE)
  )
```

## Errores Comunes y Soluciones

**Error 1: Olvidar `ungroup()`**

```{r}
# PROBLEMA
datos_agrupados <- ventas %>%
  group_by(id_tienda) %>%
  mutate(total_tienda = sum(total))

# Operaciones siguientes están agrupadas (puede causar errores)
datos_agrupados %>%
  summarize(media_global = mean(total))  # No es media global!

# SOLUCIÓN
datos_correctos <- ventas %>%
  group_by(id_tienda) %>%
  mutate(total_tienda = sum(total)) %>%
  ungroup() %>%
  summarize(media_global = mean(total))
```

## Errores Comunes y Soluciones (cont.)
**Error 2: Nombres de columnas con espacios o caracteres especiales**

```{r}
# PROBLEMA
datos_problema <- tibble(
  `Nombre Producto` = c("A", "B", "C"),
  `Precio (€)` = c(10, 20, 30)
)

# Usar backticks
datos_problema %>%
  select(`Nombre Producto`, `Precio (€)`)

# MEJOR: Usar nombres sin espacios
datos_bien <- datos_problema %>%
  rename(
    nombre_producto = `Nombre Producto`,
    precio_euros = `Precio (€)`
  )
```

## Errores Comunes y Soluciones (y 3)

**Error 3: No verificar claves duplicadas en joins**

```{r}
# PROBLEMA: claves duplicadas pueden multiplicar filas
df1 <- tibble(id = c(1, 1, 2), valor = c("A", "B", "C"))
df2 <- tibble(id = c(1, 2), info = c("X", "Y"))

resultado <- left_join(df1, df2, by = "id")
nrow(resultado)  # Esperamos 3, tenemos 3 (pero revisar lógica)

# VERIFICAR antes de hacer join
df1 %>% count(id) %>% filter(n > 1)  # ids duplicados
df2 %>% count(id) %>% filter(n > 1)  # ids duplicados

# SOLUCIÓN: decidir qué hacer con duplicados
df1_unico <- df1 %>% distinct(id, .keep_all = TRUE)
```

**Error 4: Orden de operaciones incorrecto**

```{r}
#| eval: false
# PROBLEMA: filtrar después de summarize
ventas %>%
  group_by(id_tienda) %>%
  summarize(total = sum(total)) %>%
  filter(cantidad > 3)  # ERROR: cantidad ya no existe

# SOLUCIÓN: filtrar antes de summarize
ventas %>%
  filter(cantidad > 3) %>%
  group_by(id_tienda) %>%
  summarize(total = sum(total))
```

## Optimización

```{r}
# USO EFICIENTE: filtrar primero, luego unir
ventas_2023 <- ventas %>%
  filter(año == 2023) %>%  # reduce tamaño
  left_join(productos, by = "id_producto")

# USO INEFICIENTE: unir todo, luego filtrar
ventas_2023_lento <- ventas %>%
  left_join(productos, by = "id_producto") %>%
  filter(año == 2023)

# SELECCIONAR SOLO COLUMNAS NECESARIAS
productos_minimo <- productos %>%
  select(id_producto, nombre_producto, precio)

ventas_join <- ventas %>%
  left_join(productos_minimo, by = "id_producto")
```

## Gráficos de Análisis Exploratorio

```{r}
# Distribución de ventas
ggplot(ventas, aes(x = total)) +
  geom_histogram(bins = 50, fill = "steelblue", alpha = 0.7) +
  labs(title = "Distribución de Ventas",
       x = "Importe Total (€)", y = "Frecuencia") +
  theme_minimal()

# Ventas por día de la semana
ventas_dia <- ventas %>%
  group_by(dia_semana) %>%
  summarize(
    num_ventas = n(),
    ingresos = sum(total),
    ticket_promedio = mean(total)
  )

ggplot(ventas_dia, aes(x = dia_semana, y = ingresos)) +
  geom_col(fill = "coral") +
  labs(title = "Ingresos por Día de la Semana",
       x = "Día", y = "Ingresos (€)") +
  theme_minimal()

# Evolución temporal
ventas_mensual <- ventas %>%
  group_by(año, mes) %>%
  summarize(ingresos = sum(total), .groups = "drop") %>%
  mutate(periodo = paste(año, sprintf("%02d", mes), sep = "-"))

ggplot(ventas_mensual, aes(x = periodo, y = ingresos, group = 1)) +
  geom_line(color = "darkgreen", size = 1) +
  geom_point() +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Evolución de Ingresos Mensuales",
       x = "Período", y = "Ingresos (€)")
```

## Comparaciones y Rankings

```{r}
# Top 10 tiendas por ingresos
top_tiendas <- ventas %>%
  left_join(tiendas %>% select(id_tienda, nombre_tienda), by = "id_tienda") %>%
  group_by(nombre_tienda) %>%
  summarize(ingresos = sum(total), .groups = "drop") %>%
  arrange(desc(ingresos)) %>%
  head(10)

ggplot(top_tiendas, aes(x = reorder(nombre_tienda, ingresos), y = ingresos)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(title = "Top 10 Tiendas por Ingresos",
       x = "Tienda", y = "Ingresos (€)") +
  theme_minimal()

# Comparación entre regiones
ventas_region <- ventas %>%
  left_join(tiendas %>% select(id_tienda, region), by = "id_tienda") %>%
  group_by(region, año) %>%
  summarize(ingresos = sum(total), .groups = "drop")

ggplot(ventas_region, aes(x = factor(año), y = ingresos, fill = region)) +
  geom_col(position = "dodge") +
  labs(title = "Ingresos por Región y Año",
       x = "Año", y = "Ingresos (€)", fill = "Región") +
  theme_minimal()
```

## Guardar Datasets Procesados

```{r}
# Guardar en RData
save(ventas_completo, file = "data/ventas_procesado.RData")

# Guardar en CSV
write_csv(ventas_completo, "data/ventas_procesado.csv")

# Guardar múltiples objetos
save(analisis_rentabilidad, comparacion_objetivos, 
     file = "data/analisis_completo.RData")
```

## Crear Reportes

```{r}
#| eval: false
# Tabla resumen para Excel
reporte_ejecutivo <- ventas %>%
  left_join(tiendas %>% select(id_tienda, nombre_tienda, region), 
            by = "id_tienda") %>%
  group_by(region, año, trimestre) %>%
  summarize(
    num_transacciones = n(),
    ingresos = sum(total),
    ticket_promedio = mean(total),
    clientes_unicos = n_distinct(id_cliente),
    .groups = "drop"
  ) %>%
  pivot_wider(
    names_from = trimestre,
    values_from = c(ingresos, num_transacciones),
    names_glue = "{.value}_Q{trimestre}"
  )

# Exportar
library(writexl)
write_xlsx(reporte_ejecutivo, "reportes/reporte_ejecutivo.xlsx")
```

:::: {.notes}

**Resumen**

- Flujo de Trabajo Recomendado

1. **Exploración Inicial**
   - `glimpse()`, `summary()`, `head()`
   - Identificar tipos de datos y valores ausentes

2. **Limpieza**
   - Filtrar datos irrelevantes
   - Manejar valores ausentes
   - Corregir tipos de datos

3. **Transformación**
   - Crear variables derivadas
   - Pivotar si es necesario
   - Unir tablas relacionadas

4. **Agregación**
   - `group_by()` + `summarize()` para KPIs
   - Calcular métricas de negocio

5. **Análisis**
   - Comparaciones temporales
   - Rankings y segmentaciones
   - Identificar outliers

6. **Visualización**
   - Gráficos exploratorios
   - Dashboards de KPIs

7. **Exportación**
   - Guardar resultados procesados
   - Crear reportes


**Principios Clave**

*Datos Ordenados (Tidy Data):*
- Una variable por columna
- Una observación por fila
- Un valor por celda

*Código Legible:*
- Usar pipe `%>%` para encadenar operaciones
- Un paso por línea
- Nombres descriptivos de variables
- Comentarios para lógica compleja

*Eficiencia:*
- Filtrar temprano, unir tarde
- Seleccionar solo columnas necesarias
- Verificar claves antes de joins
- Usar `glimpse()` para inspeccionar resultados intermedios

*Reproducibilidad:*
- Scripts ordenados y comentados
- Guardar datos procesados
- Documentar decisiones de limpieza



**Recursos Adicionales**

- **Documentación:** `?dplyr`, `?tidyr`
- **Cheat Sheets:** RStudio > Help > Cheatsheets
- **Libros:** 
  - "R for Data Science" (Wickham & Grolemund)
  - "Advanced R" (Wickham)
- **Comunidad:** Stack Overflow, RStudio Community

::::

## Ejercicios de Práctica

### Ejercicio 1: Análisis de Categorías

Usando los datos de RetailCorp:

1. Identifica las 3 categorías con mayores ingresos en 2023
2. Calcula la tasa de crecimiento año sobre año para cada categoría
3. Determina qué categorías tienen los tickets promedio más altos
4. Crea un gráfico comparativo

### Ejercicio 2: Segmentación de Clientes

1. Clasifica clientes según su valor total de compras (Bajo/Medio/Alto/Premium)
2. Calcula la recencia (días desde última compra)
3. Identifica clientes en riesgo (no han comprado en >90 días)
4. Propón estrategia de retención

### Ejercicio 3: Análisis de Empleados

1. Calcula el promedio de ventas por empleado
2. Identifica empleados top performers
3. Analiza si hay diferencias por puesto
4. Sugiere un sistema de bonificaciones

### Ejercicio 4: Optimización de Inventario

1. Lista productos con baja rotación (pocas ventas)
2. Identifica productos descontinuados
3. Calcula el stock óptimo por tienda (simulado)
4. Recomienda productos a eliminar del catálogo


<!--
## Conclusión

**Has aprendido:**

✓ Principios de datos ordenados (tidy data)

✓ Los 5 verbos principales de `dplyr`

✓ Uso del operador pipe `%>%`

✓ Agregación con `group_by()` y `summarize()`

✓ Transformación de datos con pivot

✓ Unión de múltiples tablas

✓ Análisis completo de casos reales

**Próximos pasos:**

- Practicar con tus propios datos
- Explorar funciones avanzadas de `dplyr`
- Aprender sobre datos temporales con `lubridate`
- Profundizar en visualización con `ggplot2`

**Recuerda:**

> "La preparación de datos es el 80% del trabajo de análisis. Hacerlo bien desde el principio ahorra tiempo y errores después."

-->