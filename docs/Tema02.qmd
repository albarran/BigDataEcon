---
title: "Tema 02 - Limpieza y Tratamiento de Datos"
subtitle: "De datos en bruto a información útil para decidir con `tidyverse`"
author:  
    - "Pedro Albarrán"
    - "Alberto Pérez"
institute: "Dpto. de Fundamentos del Análisis Económico. Universidad de Alicante"
format:
  revealjs:
    logo: figure/by-nc-sa2.png
    titlegraphic: figure/by-nc-sa.png
    theme:  
        - beige
        - custom.scss
    smaller: true
    scrollable: true
    embed-resources: true
    slide-number: true
    show-slide-number: all
    transition: slide
    background-transition: fade
    progress: true
    height: 800
    width: 1200
    show-notes: false
    notes-format: html
execute:
  enabled: true      # execute code chunks
  eval: false        # by default, don't evaluate code chunks
  echo: true         # show code
  warning: false     # don't show warnings (redundant to eval: false)
  message: false     # don't show messages (idem)
  output: false      # don't show output (idem)
  fig.show: hide     # don't show figures (idem)
knitr:
  opts_chunk:         # OJO: reduntant to execute:
    results: hide     # ni muestra resultados ni figuras
    fig.show: hide
lang: es
strip-comments: true
toc: true
toc-depth: 1
toc-expand: false
toc-title: "Contenidos"
css: styles.css
---

```{r setup}
#| include: false
# se evalua pero no incluye output (mensajes, etc.)

# Elimino todo del Entorno (del documento)
rm(list = ls())

# Working directory
#setwd("/home/albarran/Dropbox/ECMTII/ECMTII/Slides_2023")

# Cargo todas las bibliotecas necesarias
# (se podría hacer cuando cada una sea necesaria)
library(tidyverse)
library(rio)
library(kableExtra)
library(rmarkdown)
```


```{r generar-datos}
#| echo: false
#| eval: true

source("Tema02datos.R")

```

# Introducción. Datos Ordenados

## Limpieza y "doma" de datos 

:::: {.columns}
::: {.column width=40%}
- El ciclo de vida de los datos
::: 
::: {.column width=60%}
![](figure/data-science-wrangle.png){width=75% fig-align="center"}
:::
::::

- El desafío real del análisis de datos:

  - 80% del tiempo de [trabajo "sucio"](https://www.nytimes.com/2014/08/18/technology/for-big-data-scientists-hurdle-to-insights-is-janitor-work.html) : limpieza y preparación

  - 20% del tiempo: análisis y modelización

- `tidyverse` incluye una colección de bibliotecas con herramientes eficientes para el proceso de "tratamiento de datos" ("data wrangling")

- El objetivo es obtener un conjunto de datos **ordenado** y **limpio** para realizar el análisis eficientemente y obtener información útil para la toma de decisiones


:::: {.notes}

- Ciclo: Recolectar, unir, limpiar, recodificar, etc.

- `tidyverse` ofrece herramientas eficientes inspiradas en  declaraciones de consulta **SQL** 

- basadas en una *gramática de manipulación de datos*

::::


## Datos ordenados ('tidy data'): Principios fundamentales

1.- Cada columna es una **variable**: mide el mismo *atributo* entre unidades
  
2.- Cada fila es una **observación** (caso): misma *unidad* a través de atributos

3.- Cada celda es un **valor**


![](figure/tidy-1.png){width=65% fig-align="center"}

- ¿Qué es una unidad en la tabla? ¿a qué nivel medimos la información?

  - a nivel de cada compra realizada por un cliente en cada fecha, o
  
  - a nivel de cliente (todas sus compras), de tienda (todas sus ventas), etc.

- Tenemos información similar y no redundante en una misma tabla 


:::: {.notes}


1. Atributos o características  (cuantitativos o cualitativos) diferentes en columnas diferentes; p.e., nombres de columnas no deben ser valores

  - Variable = vector columna: forma natural para trabajar con datos

2. Mismo nivel de agregación en toda la tabla

3. No mezclar tipos de datos Ni almacenar múltiples valores

  - Una tabla puede completar la información con uniones a tablas adicionales (ej., para variables codificadas)

-  `tidyverse` es eficiente con datos ordenados 

```{r}
#| echo: false
# Para acceder al vector valores de `cases`

table1$cases                   # table1 %>% select(cases)
table2$count[c(1,3,5,7,9,11)]  # table2 %>% filter(type == "cases") %>%
                               #            select(count)
c(table4a$`1999`, table4a$`2000`)
# crear variables es fácil
table1 %>% mutate(rate = cases / population * 10000)  

# Ej. gráfico temporal

ggplot(table1, aes(x = year, y = cases)) +  
  geom_line(aes(colour = country))
```

::::

## Datos no ordenados

:::: {.columns}
::: {.column width=50%}
![](figure/tablaNOordenados.png){width=110% fig-align="center"}
::: 

::: {.column width=50%}
* Otras estructuras como [esta](https://datos.gob.es/es/catalogo/conjuntos-datos?q=hombres-segun-si-tienen-hijos-o-no-situacion-sentimental-y-edad&sort=score+desc%2C+metadata_created+desc) pueden tener sentido para *mostrar información* (o por convenciones)<!--para almacenar información -->


* La visualización es atractiva, PERO sobran filas para **analizar** los datos: ej., total de personas con hijos y sin pareja entre 30 y 39 años

::: 
::::


:::: {.notes}
```{r}
#| echo: false
# Ejemplo de datos NO ORDENADOS (comunes en Excel)
ventas_desordenadas <- data.frame(
  Tienda = c("Madrid Centro", "Barcelona", "Total"),
  Ene_2023 = c(45000, 52000, 97000),
  Feb_2023 = c(48000, 54000, 102000),
  Mar_2023 = c(51000, 56000, 107000)
)
ventas_desordenadas
```

**Problemas de estos datos:**

- Meses están en columnas (son valores, no variables)

- Fila "Total" mezcla niveles de agregación

- Difícil filtrar, agrupar o visualizar

**Por Qué Importan los Datos Ordenados**

**Ventajas:**

✓ Consistencia en todas las operaciones

✓ Fácil manipulación con `dplyr`

✓ Visualización directa con `ggplot2`

✓ Compatible con modelización

✓ Facilita colaboración

**Ejemplo Práctico:**

```{r eval=FALSE}
# Con datos ordenados: FÁCIL
ventas %>%
  group_by(id_tienda, mes) %>%
  summarize(ventas_total = sum(total))

# Con datos desordenados: COMPLEJO
# Requiere reshape, limpieza, etc.
```

::::



## Caso de Estudio: RetailCorp

- **Contexto:** Cadena de venta al por menor con 12 tiendas en España

- **Objetivo:** Analizar rendimiento de ventas para toma de decisiones estratégicas

. . .

```{r}
load("data/retail_data.RData")
```

:::: {.columns}
::: {.column width=50%}
- Recibe datos de 

  - Sistema de ventas (POS)
  
  - CRM de clientes
  
  - Inventario de productos
  
  - RRHH de empleados
  
  - Informes Excel de gerentes
  
:::

::: {.column width=40%}
**Problemas Típicos:**

- Formatos inconsistentes

- Datos duplicados

- Valores ausentes

- Estructuras inadecuadas

- Tablas dispersas
:::
::::


# Transformación de datos (una tabla)

:::: {.notes}
* `dplyr` frente R `base`

* sencillez, rapidez con big data, estilo SQL etc.

1.  select()  =  data[, c("name") / pos] 
              =  subset()

2.  filter()  =  data[c("name") / pos / condicion, ] 
              =  subset()

3.  mutate()  = data$newvar <- 
              = with(data, newvar = y - x)

4.  arrange() = order()
              [sort() es para vectores]

5.  summarize() = aggregate(data,income, FUN=mean)

6. groub_by() %>% summarize = aggregate(data,income~año, FUN=mean)
::::

## Funciones de transformación de datos

- La mayoría de operaciones pueden realizarse combinando 5 "verbos": 

  1. `select()`: selecciona columnas (variables)
  
  2. `filter()`: filtra (extraer) filas
  
  3. `mutate()`: crea nuevas columnas
  
  4. `arrange()`: ordena filas
  
  5. `summarize()`: crea resúmenes de la tabla
  
  - Más la tubería `%>%` o `|>` 
  
  - y `group_by()`

- NOTA: existe una colección de ["chuletas"](https://rstudio.com/resources/cheatsheets/) de R, p.e., para transformación.

- Todos tienen como primer argumento un *data frame*, los siguientes describen qué hacer (con columnas o filas) y devuelven otro *data frame*


## 1. `select()`

- **Selecciona variables** por nombres o posiciones de columnas, separados por comas


![](figure/select.png){width=100% fig-align="center"}


- Ej., un analista solo necesita información básica de ventas

```{r}
select(ventas, id_venta, fecha, id_tienda, id_producto, total)

select(ventas, 1:2, 5, 4, 12)
```

- Aplicación Empresarial:  el equipo de marketing solo necesita información de cliente y venta
```{r}
ventas_mkt <- select(ventas, 
                fecha, id_cliente, id_producto, total)
```



## 2. `filter()`

- Conserva filas en las que una *condición lógica* (o varias separadas por comas) es verdadera

![](figure/filter.png){width=70% fig-align="center"}


- **Caso de Uso:** Gerente quiere analizar ventas específicas con determinadas características

```{r}
ventas_top      <- filter(ventas, total > 1000)

ventas_ene_2024 <- filter(ventas, año == 2024, mes == 1)

ventas_mad_bcn  <- filter(ventas, id_tienda %in% c(1, 2))

ventas_premium  <- filter(ventas, 
                     total > 1000 & descuento_porcentaje == 0)
```



```{r}
#| echo: false
# Ventas con descuento
ventas_con_descuento <- ventas %>%
  filter(descuento_porcentaje > 0)

# Combinando condiciones: ventas altas sin descuento
ventas_premium <- ventas %>%
  filter(total > 1000, descuento_porcentaje == 0)

# Análisis de fin de semana vs días laborables
ventas_finde <- ventas %>%
  filter(dia_semana %in% c("sábado", "domingo"))

# Campaña de verano 2023
ventas_verano_2023 <- ventas %>%
  filter(año == 2023, mes %in% c(6, 7, 8))
```


## Encadenando operaciones con tuberías: `%>%` o `|>`

::: {style="font-size: 95%;"}

- Las operaciones encadenadas crean objetos intermedios o no son legibles

```{r}
ventas_top        <- filter(ventas, total > 1000)
ventas_top_markt  <- select(ventas_top, 
                       fecha, id_cliente, id_producto, total)

ventas_top_markt <- select(filter(ventas, total > 1000),
                      fecha, id_cliente, id_producto, total)
```

:::

. . .

::: {style="font-size: 95%;"}

- `datos %>% filter(condicion)` equivale a `filter(datos, condicion)`

- El anidamiento con tuberías sigue el flujo natural de lectura

  - Toma una tabla y pásala a un comando que acepta y produce un *data frame*
  - Toma la nueva tabla resultante y pásala a otro comando


```{r}
ventas_top_markt <- ventas |>                   
                     filter(total > 1000) |>     
                     select(fecha, id_cliente, id_producto, total)
```


:::

:::: {.notes}

- Los objetos intermedios son innecesarios

- Aplicable a cualquier función: `10 |> log()` es `log(10)`

- Legible, fácil anidar operaciones: siempre toman y devuelve un *data frame*

```{r}
#| echo: false

# estas dos son equivalentes
filter(ventas, total > 100)
ventas |> filter(total > 100)

# y estas
select(ventas_top, 
       fecha, id_cliente, id_producto, total)
ventas_top |> select(fecha, id_cliente, id_producto, total)

# sustituimos ventas_top
filter(ventas, total > 100) |> select(fecha, id_cliente, id_producto, total)

# y reemplazamos
ventas |> filter(total > 100) |> select(fecha, id_cliente, id_producto, total)
```


- `ggplot2` `+` en lugar de `%>%` (desarrollado antes)

- Atajo de teclado: `Cmd / Ctrl + Mays + M `

- También existe una tubería en R base: `|>`

::::


## Funciones auxiliares de selección (de columnas)


```{r}
# Por rango de columnas
ventas |> select(id_venta:id_tienda)

# Excluir columnas
ventas |> select(-descuento_porcentaje, -descuento_aplicado)

# Por patrón de nombre
ventas |> select(starts_with("id_"))
ventas |> select(ends_with("_porcentaje"))
ventas |> select(contains("descuento"))

# Por tipo de dato
ventas |> select(where(is.numeric))
ventas |> select(where(is.character))
```

-  `pull()`: extrae una única columna, como **vector**
```{r}
ventas |> pull(cantidad) |> mean()
```


:::: {.notes}

```{r}
library(nycflights13)
select(flights, -(year:day))    # todas menos "year, month, day"
```

- `num_range("x", 1:3)`: para x1, x2 y x3.
- `matches()`: nombres que coinciden con una [expresión regular](https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular)

- `matches("(.)\\1")`: selecciona las variables que coinciden con una expresión regular (en este caso, cualquier variable que contenga caracteres repetidos).

::::

## 3. `mutate()`


:::: {.columns}

::: {.column width=55%}

- Crea o modifica variables mediante una *fórmula* a partir de otras columnas

:::

::: {.column width=45%}

![](figure/mutate.png){width=95% fig-align="center"}
::: 

::::

```{r}
ventas2 <- ventas |>
  mutate(
    precio_final_unitario = total / cantidad,
    es_inicio_mes         = day(fecha) <= 7
  )
```

- Funciones para operar con fechas (usando `lubridate`)

```{r}
ventas_tiempo <- ventas |>
  mutate(
    fecha_completa = as.Date(fecha),  # tipo de objeto "fecha"
    semana_año = week(fecha),
    nombre_mes = month(fecha, label = TRUE),
    dias_desde_venta = Sys.Date() - fecha
  )
```

:::: {.notes}
- `lubridate` es parte de `tidyverse`
::::


## 4. `arrange()`

:::: {.columns}

::: {.column width=55%}

- re-ordena las filas de un *data frame* (todas las columnas)

  - en orden ascendente (por defecto) o descendente con `desc()`

:::

::: {.column width=45%}
![](figure/arrange.png){width=50% fig-align="center"}
::: 

::::

- *Caso de Uso:* Top 5 ventas más altas
```{r}
ventas |> 
  arrange(desc(total)) |> slice(5) |> 
  select(id_venta, fecha, total)  
```

- Ordenamientos **múltiples**: ordena por la primera variable y luego, en caso de empate, por la siguiente, etc.
```{r}
ventas |>
  arrange(id_tienda, desc(total)) |>
  select(id_tienda, id_venta, total)
```

:::: {.notes}
- similar a Excel
- sort() es para un vector
::::


## 5. `summarize()`


:::: {.columns}
::: {.column width=55%}
- Crea un nuevo conjunto de datos de **una sola fila**, con variables nuevas de un solo valor que resumen los datos completos
:::
::: {.column width=45%}
![](figure/summarise.png){width=80% fig-align="center"}
:::
::::

- *Caso de Uso:* KPIs para el dashboard ejecutivo

```{r}
KPIs <- ventas |>
  summarize(
    total_ventas       = n(),           # Volumen (núm. de filas)
    ingresos_totales   = sum(total),    # Ingresos
    ingresos_promedio  = mean(total),
    ingresos_mediano   = median(total),
    descuento_promedio = mean(descuento_porcentaje), # Descuentos
    descuento_total    = sum(descuento_aplicado),
    unidades_vendidas  = sum(cantidad),             # Productos
    clientes_unicos    = n_distinct(id_cliente)     # Clientes 
                         # (núm. de filas distintas)
  )
```


```{r}
#| echo: false
# **Métricas de Distribución:**
# Análisis de dispersión de ventas
dispersion_ventas <- ventas %>%
  summarize(
    media = mean(total),
    desv_std = sd(total),
    minimo = min(total),
    q25 = quantile(total, 0.25),
    mediana = median(total),
    q75 = quantile(total, 0.75),
    maximo = max(total),
    rango_intercuartil = IQR(total)
  )

dispersion_ventas
```


## `group_by()`: Análisis por Grupos

::: {style="font-size: 95%;"}

- Cambia el alcance: *cada función* actúa dentro de grupos, no sobre toda la tabla

- Ejemplo: encontrar la fecha con la mayor venta por tienda

```{r}
ventas |> group_by(id_tienda) |>
  arrange(desc(total)) |>  
  slice(1) |>                     # Fila 1 (de cada grupo)
  select(id_tienda, fecha, total)
```

:::

::::{.notes}
- alternativa `slice_max()`
::::

. . .

::: {style="font-size: 95%;"}

- `group_by()` + `summarize()` = cambia el nivel de análisis, **agregando**, p.e., de transacciones a tiendas, productos, etc.
  
  - En Excel: *Tablas dinámicas*, *AGRUPARPOR()* (y *SUMAR.SI*/*SUMIF*) 

```{r}
ventas                             # tabla a nivel de transacción
ventas |>
  summarize(ingresos = sum(total)) # resumen global
ventas |>
  group_by(id_tienda) |>
  summarize(ingresos = sum(total)) # resumen por tienda
                                   # tabla a nivel de tienda
```

:::

:::: {.notes}

- `group_by()` similar a facet

-  Ver  `ventas |> group_by(id_tienda)`: tibble muestra que hay dos grupos

- datos de información/ventas por empleado a información por tienda

- DEBEN INCLUIRSE variables que se quieran mantener


- **Ejercicio**:

  1. Para cada *producto*, calcular
  
    - suma de valor de ventas (variable *total*)
    
    - media de valor de ventas (idem)
    
    - media de cantidad vendida (variable *cantidad*)
    
  2. En R y Excel 
  
  3. ¿Cuáles son los 5 productos con menor cantidad media vendida?
  
  
```{r}
ventas_prod <- ventas |>
  group_by(producto) |>
  summarize(
    sum_total = sum(total),
    med_total = mean(total),
    med_cant  = mean(cantidad)
  )

export(ventas, "ventas.xlsx")
# misma secuencia en Tablas Dinamicas de Excel

# igual que antes pero con este nueva tabla de datos a nivel producto
ventas_prod |>
  arrange(med_cantidad) |> 
  head(5) 
```

::::


##  `group_by()` (cont.)

- `group_by() + summarize()` reduce filas: nueva tabla agregada a nivel de los grupos

```{r}
tabla_sum <- ventas |> group_by(id_tienda) |>
  summarize(ingresos = sum(total))
```

- `group_by() + mutate()` mantiene filas: añade columnas calculadas por grupo a nivel de la tabla original

```{r}
tabla_mut <- ventas |> group_by(id_tienda) |>
  mutate(ingresos = sum(total))
```

. . .

- Ejemplo: Porcentaje de las ventas que representa cada transacción

```{r}
#| echo: false
ventas |> 
  group_by(id_tienda, mes) |>
  mutate(
    ventas_tienda_mes = sum(total),
    pct_de_ventas_mes = total / ventas_tienda_mes * 100
  ) |>
  slice_max(pct_de_ventas_mes) |> 
  select(id_tienda, mes, id_venta, total, pct_de_ventas_mes)
```

```{r}
ventas |> group_by(id_tienda) |>
  mutate(
    ventas_tienda = sum(total),
    pct_de_ventas = total / ventas_tienda * 100
  )
```

  

## `ungroup()`

::: {style="font-size: 92%;"}

- **IMPORTANTE:** No olvidar `ungroup()` o `.groups = "drop"` después de terminar operaciones agrupadas



- Cálculo de Porcentajes Globales: sin desagrupar, el segundo `sum(total)` suma *por tienda* → siempre da 100%


```{r}
ventas |>
  group_by(id_tienda) |>
  mutate(ventas_tienda = sum(total)) |>
  ungroup() |>
  mutate(porcentaje = ventas_tienda / sum(total) * 100)

ventas |>
  group_by(id_tienda) |>
  mutate(ventas_tienda = sum(total),
         .groups = "drop") |>
  mutate(porcentaje = ventas_tienda / sum(total) * 100)

```

:::

:::: {.notes}
- Después de group_by() + mutate():

  - Si tu siguiente operación debe ser GLOBAL → usa ungroup()

  - Si debe seguir POR GRUPO → no uses ungroup()

- Después de group_by() + summarize():

  - summarize() ya reduce un nivel de agrupación

  - Si tenías múltiples grupos, sigue agrupado por los anteriores

  - Usa .groups = "drop" o ungroup() para estar seguro

::: {style="font-size: 92%;"}
- Filtrar Top Global: sin desagrupar, será top 5 de *cada* tienda

```{r}
ventas |>
  group_by(id_tienda) |>
  mutate(ventas_tienda = sum(total), 
         .groups = "drop" ) |>
  arrange(desc(ventas_tienda)) |>
  slice_head(n = 5)
```


- Media Global después de agrupar: sin desagrupar, 1 fila por tienda (media mensual de cada tienda)

```{r}
# Ventas por tienda y mes
ventas_mes_por_tienda <- ventas |>
  group_by(id_tienda, mes) |>
  summarize(total_mes = sum(total))

ventas_mensuales_medias <- ventas_mes_por_tienda |>
  ungroup() |>
  summarize(media = mean(total_mes))
# Resultado: 1 fila (media de todos los meses de todas las tiendas)
```
:::

- Ranking de Productos

```{r}
ventas |>
  group_by(id_producto) |>
  summarize(
    unidades_vendidas = sum(cantidad),
    ingresos_totales = sum(total)
  ) |>
  ungroup() |>                     # posteriores NO por grupos 
  arrange(desc(ingresos_totales))
# ungroup() innecesario con summarize en este caso
```


**Aplicación: Segmentación de Clientes**

```{r}
# Calcular valor del cliente
valor_cliente <- ventas |>
  group_by(id_cliente) |>
  mutate(
    num_compras_cliente = n(),
    gasto_total_cliente = sum(total),
    ticket_promedio = mean(total),
    
    # Clasificación RFM simplificada
    recencia_dias = as.numeric(max(fecha) - min(fecha)),
    frecuencia = n(),
    monetario = sum(total)
  ) |>
  ungroup()
```


**Problema:** Análisis de ventas navideñas en Madrid

```{r}
# SIN pipe: difícil de leer, muchas variables intermedias
ventas_madrid <- filter(ventas, id_tienda == 1)
ventas_madrid_navidad <- filter(ventas_madrid, mes == 12)
ventas_resumen <- summarize(ventas_madrid_navidad, 
                            total = sum(total),
                            n = n())

# CON pipe: flujo natural de lectura
analisis_navidad_madrid <- ventas |>
  filter(id_tienda == 1) |>
  filter(mes == 12) |>
  summarize(
    ingresos_totales = sum(total),
    num_transacciones = n(),
    ticket_promedio = mean(total)
  )

analisis_navidad_madrid
```

**Análisis Completo Paso a Paso**

**Objetivo:** Análisis de campaña de descuentos del Q4 2023

```{r}
analisis_campana_q4 <- ventas |>
  # 1. Filtrar período relevante
  filter(año == 2023, trimestre == 4) |>
  
  # 2. Agregar categoría de descuento
  mutate(
    tipo_descuento = case_when(
      descuento_porcentaje == 0 ~ "Sin descuento",
      descuento_porcentaje <= 10 ~ "Descuento bajo",
      descuento_porcentaje <= 20 ~ "Descuento medio",
      TRUE ~ "Descuento alto"
    )
  ) |>
  
  # 3. Agrupar por tipo de descuento
  group_by(tipo_descuento) |>
  
  # 4. Calcular métricas
  summarize(
    num_ventas = n(),
    ingresos_totales = sum(total),
    ticket_promedio = mean(total),
    unidades_vendidas = sum(cantidad),
    .groups = "drop"
  ) |>
  
  # 5. Ordenar por ingresos
  arrange(desc(ingresos_totales)) |>
  
  # 6. Calcular porcentajes
  mutate(
    pct_ventas = round(num_ventas / sum(num_ventas) * 100, 1),
    pct_ingresos = round(ingresos_totales / sum(ingresos_totales) * 100, 1)
  )

analisis_campana_q4
```

::::


## Funciones auxiliares para filas

- Extraer filas pero NO por condición: por posición (`slice()`, `slice_head()`), aleatoriamente (`slice_sample()`), etc.


```{r}
ventas |> slice_max(total, n = 5) # Top 5 ventas
ventas |> slice_sample(n = 100)   # sub-muestra aleatoria
```

* `distinct()`: extrae sólo las filas únicas (una o varias variables)
 
```{r}
ventas %>% distinct(id_producto)
```

* `drop_na()` y `replace_na()`: elimina/reemplaza filas con valores ausentes

```{r}
# Quita filas con NA en cualquier variable
ventas_completas <- ventas %>%
  drop_na()                    

# solo quita si precio_unitario es NA
ventas_completas_precio <- ventas %>%
  drop_na(precio_unitario)  
```

:::: {.notes}
- `slice_head()`, `slice_tail()`, `slice_min()`, `slice_max()`

1. Eliminar `NA` (valores ausentes), PERO

    - en *alguna variable*, con `na.rm=TRUE` o `filter(!is.na(x))` o `drop_na(x)` 

    - en *todo* el conjunto de datos con `drop_na()`

    - en `cor()`, `use = "complete.obs"`

```{r}
#| echo: false
data <- tibble(x1 = c(1:4, NA, 6.0, 7, NA), x2 = c(NA, 12:14, NA, 16.0, 17:18) )

data %>% summarize(num = n(), meanNA = mean(x1), mean = mean(x1, na.rm = TRUE))

data %>% filter(!is.na(x1)) %>% 
  summarize(num = n(), meanNA = mean(x1), mean   = mean(x1, na.rm = TRUE))

data %>% drop_na(x1) %>% summarize(num = n(), mean = mean(x1))   # drop_na(x2)?
data %>% drop_na()   %>% summarize(num = n(), mean = mean(x1))
```


2. Reemplazar con un valor, PERO ¿cúal?

  - NA por no presentarse a un examen es cero

  - NA por no contestar a pregunta de renta o gasto es ¿cero?

```{r}
#| echo: false
data %>% mutate(x1 = if_else(is.na(x1), 0, x1)) %>% summarize(num = n(), mean = mean(x1))
data %>% mutate(x1 = replace_na(x1,0))          %>% summarize(num = n(), mean = mean(x1))
```


- na.omit() vs. drop_na: el primero es de base (stats) el otro de tidyr

::::

## Otras funciones auxilidares de `tidyverse`

::: {style="font-size: 90%;"}
- Muchas funciones son equivalentes a otras de R base:

    - `parse_number()`, `parse_factor()`, etc. por `as.numeric()`, `as.factor()`, etc.
    - `bind_cols()` y `bind_rows()` por `cbind()` y `rbind()`

    - `if_else()` y `case_when()` para ejecución condicional (`ifelse()`)

```{r}
ventas |>
  mutate(
    tipo_venta = if_else(total > 1000, "Alta", "Baja"), # condición simple
    categoria_cliente = case_when(              # múltiples condiciones
      total < 300  ~ "Económico",
      total < 1000 ~ "Estándar",
      TRUE         ~ "Premium"               # OJO: convertir a factor
    )
  )
```

  
* Discretizar variables<!--numéricas a categóricas-->: `cut_interval()`, `cut_number()`, `cut_width()`

```{r}
#| echo: false
flights %>% mutate(retraso = cut_width(dep_delay,2))   # retraso es factor
```


- Funciones para fechas de `lubridate`: `year()`, `month()`, `day()`, `quarter()`, `week()`

```{r}
#| echo: false
# Análisis temporal detallado
ventas_tiempo_detalle <- ventas %>%
  mutate(
    # Componentes de fecha
    año = year(fecha),
    mes = month(fecha),
    dia = day(fecha),
    trimestre = quarter(fecha),
    semana = week(fecha),
    
    # Nombres legibles
    mes_nombre = month(fecha, label = TRUE, abbr = FALSE),
    dia_semana_nombre = wday(fecha, label = TRUE, abbr = FALSE),
    
    # Flags útiles
    es_lunes = wday(fecha) == 2,
    es_fin_semana = wday(fecha) %in% c(1, 7),
    es_quincena = day(fecha) %in% c(1, 15),
    
    # Diferencias temporales
    dias_desde_hoy = as.numeric(Sys.Date() - fecha),
    semanas_desde_inicio = as.numeric(difftime(fecha, min(fecha), units = "weeks"))
  )

# Ventas por día de la semana
ventas_tiempo_detalle %>%
  group_by(dia_semana_nombre) %>%
  summarize(
    num_ventas = n(),
    ingresos = sum(total),
    ticket_promedio = mean(total)
  ) %>%
  arrange(desc(ingresos))
```

:::


## Funciones auxiliares de creación de variables

- `rename()`: cambiar el nombre de una columna
```{r}
ventas_renamed <- ventas |>
  rename(
    fecha_venta = fecha,
    monto_total = total
  )
```

:::: {.notes}
  ![](figure/rename.png){width=70% fig-align="center"}
  
- `transmute()`: como `mutate()` pero solo mantiene las variables creadas
  
- `relocate()`: cambiar orden de columnas

```{r}
#| echo: false
# Reordenar columnas
ventas_reordenadas <- ventas %>%
  select(id_venta, fecha, total, everything())  # total al inicio

# Relocate (mover columnas)
ventas %>%
  relocate(total, .after = fecha) %>%
  relocate(starts_with("id_"), .before = everything())
```

::::

- `across()`: aplica la misma transformación a múltiples columnas

```{r}
ventas |> mutate(across(c(cantidad, subtotal:total), ~ log(.x)))
ventas |> mutate(across(where(is.character), ~ parse_factor(.x)))
```


- Operadores aritméticos (`+`, `-`, `*`, `/`, `^`, `%/%`, `%%`) y lógicos (`<`, `<=`, `>`, `>=`, `!=`)

- Funciones como `log()`, `lag()`, `lead()`, `cumsum()`, `row_number()` etc.


:::: {.notes}

- combinados con otros: funciones de "agregación" `x - mean(x)`, `y - sum(y)` 

- Ordenamiento: `row_number()` 

- `min_rank()`, `row_number()` y otras de `dplyr::ranking`

- `percent_rank()`, `cume_dist()`

```{r}
#| echo: false
y <- c (10, 2, 2, NA, 30, 4)
min_rank(y)               
min_rank(desc(y))
row_number(y)
```

- Agregados acumulativos y móviles: ver ayuda de `cumsum()`  y `cummean()` 

```{r}
#| echo: false
cumsum(1:10)
cumprod(1:10)
cummin(1:10)
cummax(1:10)
cummean(1:10)
```

::::

## Funciones auxiliares de resumen

- `count()`: cuenta los valores únicos de una o más variables

```{r}
ventas |> count(id_tienda)
# ventas |> group_by(id_tienda) |>  summarize(n = n())
ventas |> count(id_tienda, sort = TRUE)
```

```{r}
#| echo: false
ventas |>
  group_by(id_tienda) |>
  summarize(n = n()) |>
  arrange(desc(n))


# Conteos múltiples
ventas |>
  count(id_tienda, mes, name = "num_ventas")

# add_count(): añade conteo sin agrupar
ventas |>
  add_count(id_producto, name = "veces_vendido") |>
  filter(veces_vendido > 50) |>
  select(id_venta, id_producto, veces_vendido)
```

. . .

* Medidas de centralidad y de dispersión: `mean(x)`, `median(x)`, `sd(x)`, `IQR(x)` <!--, `mad(x)` -->

* Medidas de rango: `min(x)`, `quantile(x, 0.25)`, `max(x)`

* Medidas de posición: `first(x)`, `nth(x, 2)`, `last(x)`. 

:::: {.notes}
- similar a `x[1]`, `x[2]` y `x[length(x)]`
::::

* Sumas, productos, etc.

* Conteos: 

  - `n()`: observaciones totales (tamaño del grupo)
  
  - `n_distinct(x)`:  filas distintas en `x`

:::: {.notes}

- `sum(!is.na(x))`: observaciones no ausentes

- más rápido que unique() 
::::
  

```{r}
#| echo: false
# Valores distintos
ventas %>%
  summarize(
    productos_unicos = n_distinct(id_producto),
    clientes_unicos = n_distinct(id_cliente)
  )
```

## Operaciones Adicionales de Limpieza

- `separate()`: dividir una columna por caracter o posición

```{r}
#| echo: false
table3 |> separate(rate, into = c("cases", "population"), sep = "/")
tabla5 <- table3 |> separate(year, into = c("century", "year"), sep = 2)
```


- `unite()`: combinar columnas


```{r}
#| echo: false
table5 |> unite(new, century, year, sep = "-")
```

:::: {.notes}

- Argumentos: *date frame*, columna a dividir, nombres de las nuevas variables y carácter (expresión regular) para separar

  - Si se pasa a `sep` un vector de enteros, son posiciones en las que dividir
  - la longitud de `sep` debe ser uno menos que la de `into`
  - valores positivos comienzan (en 1)por la izquierda; negativos (desde -1) por la derecha

- Con  `convert = TRUE` intenta convertir el tipo de dato (no mantener carácter)

```{r}
table3 |> separate(rate, into = c("cases", "population"), convert = TRUE)
```


- Argumentos: *data frame*, nombre de la nueva variable a crear,  columnas a combinar y carácter entre valores de las columnas originales

  - El separador por defecto es subrayado, `sep = _`

::::


. . .

- Para nombres de columnas con espacios o caracteres especiales, debemos usar acento invertido

  - Mejor: renombrar sin espacios

```{r}
datos_problema |> 
  rename(nombre_producto = `Nombre Producto`,
         precio_euros    = `Precio (€)`)
```



# Transformación de Datos: Pivotar

:::: {.notes}

** Cuatro representaciones de los mismos datos

```{r}
library(tidyverse)
table1     # datos ordenados
table2     # varios valores por celda
```


![](figure/tidyvsmessy01_n.png){width=60% fig-align="center"}

![](figure/tidyvsmessy02_n.png){width=60% fig-align="center"}


```{r}
table3     # más de una variable en una columna
table4a 
table4b
```

* `table4a` y `table4b` ofrecen información útil para presentación
pero
- variables tanto en filas como columnas
- las cabeceras de columna son valores, no nombres de variables.

![](figure/tidyvsmessy04a_n.png){width=60% fig-align="center"}




**Mismos datos, dos formatos: ancho o largo**

:::: {.columns}

::: {.column width=50%}

* La utilidad de almacenar los datos en un rectángulo ancho ("wide") o en uno largo ("long")  depende de qué queramos hacer

  * P.e., Excel prefiere el formato largo para tablas dinámicas, fórmulas de agregación (*SUMAR.SI*) y algunos gráficos


:::

::: {.column width=50%}

![](./figure/original-dfs-tidy.png){width=100%}
:::

::::

- El cambio de forma  entre formatos es una tarea habitual del analista de datos. 

- Cambiar entre representación larga y ancha se conoce como **pivotar (o girar)**

```{r}
table4a        # formato ancho
table1         # formato largo
```


- En general, el formato largo es más útil para el análisis 

- El cambio de forma =  "reshaping"

- DISTINTO de trasponer filas y columnas en Excel

- Existe una función para pivotar en Excel

**Cambiar la forma de una tabla (pivotar / girar)**

* Las celdas en un formato se reordenan en el otro

![](figure/tidyr-longer-wider.gif){width=45% fig-align="center"}

* Los metadatos que no se reordenan son extendidos/reducidos para no perder información. 

https://tidyr.tidyverse.org/ 

* reshape en R base:  https://jozef.io/r001-reshape/

https://www.r-bloggers.com/2019/07/how-to-reshape-a-dataframe-from-wide-to-long-or-long-to-wide-format/


<https://www.r-bloggers.com/how-to-reshape-data-in-r-tidyr-vs-reshape2/>

<https://www.r-bloggers.com/pivoting-tidily/>


**Verbos principales en `tidyr`**

* `pivot_longer()`: cambia la forma de "anchos" a "largos" (+filas/-cols)

    + **ordena** datos originales para facilitar el análisis.

* `pivot_wider()` cambia la forma de "largos" a "anchos" (+cols/-filas)

    + útil para crear tablas de resumen o un formato para otras herramientas.

![](figure/long-wide.png){width=75% fig-align="center"}

 La longitud es un término relativo, y sólo se puede decir (por ejemplo) que el conjunto de datos A es más largo que el conjunto de datos B.

::::

## Mismos datos, dos formatos: ancho o largo

::::{.notes}
- Se pueden almacenar datos en uno u otro formato, según nuestro objetivos

  - P.e., largo en Excel para tablas dinámicas, fórmulas de agregación (SUMAR.SI), algunos gráficos
  
::::

::: {style="font-size: 95%;"}

:::: {.columns}

::: {.column width="50%"}

**Formato ANCHO:**

| tienda | Q1 | Q2 | Q3 | Q4 |
|--------|----|----|----|----|
| Madrid | 145 | 158 | 151 | 169 |
| Barcelona | 152 | 164 | 156 | 175 |
| Valencia | 138 | 151 | 149 | 162 |

<br>

```{r}
ventas_ancho
```
 (datos del informe enviado por gestores)

:::

::: {.column width="50%"}

**Formato LARGO:**

| tienda | trimestre | ventas |
|--------|-----------|----------|
| Madrid | Q1 | 145 |
| Madrid | Q2 | 158 |
| Madrid | Q3 | 151 |
| Madrid | Q4 | 169 |
| Barcelona | Q1 | 152 |
| ... | ... | ... |


:::

::::

:::: {.columns}

::: {.column width="50%"}

- Los trimestres son **columnas**

- Cada tienda = 1 fila

- Análisis de datos a menudo complicado

:::

::: {.column width="50%"}

- Los trimestres son **valores**

- Cada tienda-trimestre = 1 fila

- No adecuado para tablas de presentación final

:::

::::

:::

## `pivot_longer()`: girar de ancho a largo

::: {style="font-size: 90%;"}

:::: {.columns}

::: {.column width="50%"}

- Girar para analizar los datos

```{r}
ventas_largo <- ventas_ancho |>
  pivot_longer(
    cols = Q1:Q4,              
    names_to = "trimestre",    
    values_to = "ventas"       
  )
```


:::

::: {.column width="50%"}

![](figure/longer.png){width=100% fig-align="center"}

:::

::::

1. tabla a cambiar de forma

2. nombres o índices (numéricos) de las columnas a girar: representan valores, no variables 

3. nombre para la nueva variable que tendrá, como valores, esas antiguas columnas a girar

4. nombre para la nueva variable que tendrá como valores las antiguas celdas

:::

:::: {.notes}

- Recordad que existen formas equivalentes de hacer lo mismo
```{r}
#| echo: false
pivot_longer(table4a, 2:3, names_to = "year", values_to = "cases")       
table4a %>% pivot_longer(c(`1999`, `2000`), values_to = "cases", names_to = "year")
table4a %>% pivot_longer(names_to = "year", values_to = "cases", -country)
table4a %>% pivot_longer(names_to = "year", values_to = "cases", `1999`:`2000`)
```

```{r}
table4a %>% pivot_longer(cols = `1999`:`2000`, 
                         values_to = "cases", names_to = "year")
```

- Notar que los nombres de columna son caracteres y cuando son números van entre \` (evita confusión con índice de posición)

```{r}
#| echo: false
table4a %>% pivot_longer(c(1999, 2000), values_to = "cases", names_to = "year")
table1 %>% mutate(`tasa por 1000 mil habitantes` = cases/population*1000,
                  tasa =cases/population*1000)
```

- Deberíamos cambiar el tipo de las nuevas variables 

::::


## `pivot_wider()`: girar de largo a ancho



:::: {.columns}

::: {.column width="50%"}

- Girar para crear tabla de presentación

```{r}
ventas_largo |>             
  pivot_wider(
    names_from = trimestre, 
    values_from = ventas    
  )
```

:::

::: {.column width="50%"}

![](figure/wider.png){width=100% fig-align="center"}
:::

::::

1. tabla a cambiar de forma

2. nombre de la variable cuyos valores dan nombre a las nuevas columnas

3. nombre de la variable de cuyas celdas toman los valores las nuevas columnas


## Comparación: Tareas Comunes

::: {style="font-size: 90%;"}

- Según nuestro objetivos, podemos preferir formato ancho o largo

- Problemas prácticos con formato ancho para **analizar datos**:

::::{.notes}

- P.e., largo en Excel para tablas dinámicas, fórmulas de agregación (SUMAR.SI), algunos gráficos

- Total por trimestre: en formato ancho, posible pero repetitivo

```{r}
#| echo: false
# Formato ANCHO: posible pero repetitivo
tibble(
  trimestre = c("Q1", "Q2", "Q3", "Q4"),
  total = c(sum(ventas_ancho$Q1),
            sum(ventas_ancho$Q2),
            sum(ventas_ancho$Q3),
            sum(ventas_ancho$Q4))
)

# Formato LARGO: una sola operación
ventas_largo <- ventas_ancho |>
  pivot_longer(Q1:Q4, names_to = "trimestre", values_to = "ventas")

ventas_largo |>
  group_by(trimestre) |>
  summarize(total = sum(ventas))
```

- Filtrar trimestres específicos

```{r}
# Formato ANCHO: difícil - ¿cómo filtro "solo Q2 y Q3"?
ventas_ancho |>
  select(tienda, Q2, Q3)  # Solo puedo seleccionar columnas, no filtrar

# Formato LARGO: trivial
ventas_largo |>
  filter(trimestre %in% c("Q2", "Q3"))
```

::::

1. Algunas tareas son imposibles. P.e., ¿qué trimestres superan 160 en ventas?

```{r}
ventas_largo |>
  filter(ventas > 160)
```

2. Código repetitivo y propenso a errores. P.e., Calcular crecimiento

```{r}
ventas_ancho |>
  mutate(
    crec_Q2 = (Q2 - Q1) / Q1 * 100,
    crec_Q3 = (Q3 - Q2) / Q2 * 100,
    crec_Q4 = (Q4 - Q3) / Q3 * 100
  )

ventas_largo |>
  group_by(tienda) |>
  mutate(crecimiento = (ventas - lag(ventas)) / lag(ventas) * 100)
```

::::{.notes}

1. formato ancho: tarea manual difícil con muchas fechas)

2. formato ancho: cada columna manualmente, difícil con muchas fechas

::::

:::  

## Comparación: Tareas Comunes (cont.)

::: {style="font-size: 90%;"}

  

3. No escalable. P.e., gráfico temporal por grupos

```{r}
ggplot(ventas_ancho) +
  geom_line(aes(x = 1:4, y = c(Q1[1], Q2[1], Q3[1], Q4[1])), color = "red") +
  geom_line(aes(x = 1:4, y = c(Q1[2], Q2[2], Q3[2], Q4[2])), color = "blue") +
  geom_line(aes(x = 1:4, y = c(Q1[3], Q2[3], Q3[3], Q4[3])), color = "green")

ggplot(ventas_largo, aes(x = trimestre, y = ventas, 
                         color = tienda, group = tienda)) +
  geom_line() + geom_point()
```

:::  

. . .

::: {style="font-size: 90%;"}

- Formato ancho solo para tablas de presentación final

```{r}
analisis <- ventas_largo |>
  group_by(trimestre) |>
  summarize(total = sum(ventas))

tabla_presentacion <- ventas_largo |>
  pivot_wider(names_from = trimestre, values_from = ventas) |>
  mutate(Total = Q1 + Q2 + Q3 + Q4)
```

:::  


# Datos Relacionales

## Por Qué Múltiples Tablas

- Analizar datos suele implicar múltiples tablas

  - diferentes orígenes: ej., dptos. de empresa (personal, ventas, almacén)

  - almacenamiento más eficiente: elementos “similares” dentro de una tabla y diferentes entre ellas

- Para poder combinar información los datos deben ser relacionales: cada par de tablas están relacionadas mediante identificadores comunes llamados **claves**

  - Primaria (o interna): identifican de forma única cada observación en una tabla. Puede ser una sola variable o múltiples

  - Secundaria (o externa): señala a la clave primaria de otra tabla

::::{.notes}
* Es conveniente verificar que las claves primarias realmente identifican de manera única cada observación. 

```{r}
planes %>% count(tailnum) %>% filter(n > 1)
#table(planes$tailnum)
```

* La clave externa asegura la integridad referencial. 


- Subrogada = número de fila, si la tabla carece de identificación única


* Tabla sin clave de identificación única: se crea con `mutate()` y `row_number()`. 

```{r}
flights %>% 
  count(year, month, day, flight) %>% 
  filter(n > 1)
```

::::

- Una clave primaria y su externa asociada en otra tabla forman una relación: de uno-a-muchos, de uno-a-uno, de muchos-a-muchos, de muchos-a-uno

## Diagrama de Relaciones del Sistema RetailCorp

![](figure/Tema02relat.png){width=75% fig-align="center"}


::::{.notes}

- gráfico creado con UML en https://www.plantuml.com
- usando Tema02relat.puml

```
library(plantuml)
# Guarda el código en un archivo "diagrama.puml"
plantuml("diagrama.puml")
```

**Operaciones con dos tablas**

* **Uniones de transformación** ("Mutating joins"): añade nuevas variables a una tabla desde filas coincidentes en otra.  

* **Uniones de filtro** ("Filtering joins"): filtra las observaciones de una tabla basándose en si coinciden o no con una observación de la otra tabla. 

* **Operaciones de conjunto** ("Set operations"): combinan las observaciones en los conjuntos de datos como si fueran elementos de un conjunto.    

* Esta discusión asume que tenemos datos ordenados (*tidy*):
    + las filas son observaciones 
    + las columnas son variables

::::


## Uniones de transformación

- Añaden **nuevas variables** a una tabla desde *filas coincidentes* en otra.  

::::{.columns}

:::{.column width=40%}

- Tenemos estos [datos](https://raw.githubusercontent.com/albarran/00datos/main/DosTablas.xlsx). 

- ¿Cómo conseguimos unirlos adecuadamente en R y en Excel?


:::

:::{.column width=60%}

![](figure/DatosRelacionales.png){width=95% fig-align="center"}

:::

::::


- Con `cbind()` o `bind_columns()` o copiando y pegando en Excel: nuevas columnas para filas en el mismo orden

. . .

```{r}
tabla1 <- import("data/DosTablas.xlsx", sheet = 1)
tabla2 <- import("data/DosTablas.xlsx", sheet = 2)
union  <- inner_join(tabla1, tabla2, by = "Vendedor")
```


::::{.notes}

como mutate = mutating joins

clave = fila Y ademán en el mismo orden

- en Excel, las uniones se hacen con VLOOKUP o HLOOKUP o XLOOKUP (BUSQUEDAH, BUSQUEDAV, BUSQUEDAX)

::::

## Tipos de Uniones: Visión General

::: {style="font-size: 95%;"}

```{r}
#| echo: false
# Datos de ejemplo para ilustrar
df1 <- tibble(id = 1:3, valor_x = c("A", "B", "C"))
df2 <- tibble(id = c(1, 2, 4), valor_y = c("X", "Y", "Z"))

# inner_join: solo coincidencias
inner_join(df1, df2, by = "id")  # resultado: 1, 2

# left_join: todas de la izquierda
left_join(df1, df2, by = "id")   # resultado: 1, 2, 3 (3 con NA)

# right_join: todas de la derecha
right_join(df1, df2, by = "id")  # resultado: 1, 2, 4 (4 con NA)

# full_join: todas de ambas
full_join(df1, df2, by = "id")   # resultado: 1, 2, 3, 4
```


::::{.columns}

:::{.column width=50%}

- Unión interna: `inner_join(x, y)` sólo incluye observaciones que coincidan en `x` y `y`.
:::


:::{.column width=50%}

![](figure/join-inner.png){width=65% fig-align="center"}
:::

::::


<div style="margin-top: -1em;"></div>

- Uniones externas: cuando una fila no coincide en una unión externa, las nuevas variables se rellenan como **valores ausentes**

::::{.columns}
  
:::{.column width=33%}

`left_join(x, y)`

![](figure/join-outer1.png){width=85% fig-align="center"}
:::

:::{.column width=33%}

`right_join(x, y)`

![](figure/join-outer2.png){width=85% fig-align="center"}
:::

:::{.column width=33%}

`full_join(x, y)`


![](figure/join-outer3.png){width=85% fig-align="center"}
:::

::::

- **Pensar** con cuidado el tipo de unión necesaria: qué observaciones quedan (todas, solo de una tabla y cuál) y ser conscientes de la introducción de `NAs`

::::{.notes}

* unión interna:  Uniendo dos series temporales con periodos diferentes: [PIB](https://fred.stlouisfed.org/series/GDPC1) y [consumo](https://fred.stlouisfed.org/series/MEHOINUSA672N)

![](figure/inner-join.gif){width=75% fig-align="center"}

* `left_join(df1, df2)`: mantiene todas las observaciones en `x`, coincidan o no con la de `y` 
  + (no se pierden observaciones de la tabla primaria) 
* `right_join(df1, df2)`:  mantiene todas las observaciones en `y`
* `full_join(df1, df2)`: incluye todas las observaciones de `x` e `y`

![](figure/join-outer.png){width=75% fig-align="center"}

![](figure/left-join.gif){width=80% fig-align="center"}

![](figure/right-join.gif){width=80% fig-align="center"}

![](figure/full-join.gif){width=80% fig-align="center"}

::::

:::

## Análisis de ventas por región en el tiempo

::: {style="font-size: 95%;"}
- Para usar la información de región se deben unir las tablas de ventas y de tiendas

```{r}
tabla_regional <- ventas |>
  left_join(tiendas, by = "id_tienda") |>   
  group_by(region, año, mes) %>%
  summarize( valor_ventas = sum(total),
             ticket_medio = mean(total),
             cantidad_media = mean(cantidad) ) |> ungroup()
```

- Ahora podemos realizar más análisis

```{r}
# Evolución de ventas por región
tabla_regional |> 
  mutate(periodo = ym(paste(año, mes, sep = "-"))) |>
  ggplot() + 
  geom_line(aes(x = periodo, y = valor_ventas, color = region))

# Los dos periodos con más ventas medias de cada región
tabla_regional |> 
  group_by(region) |>  
  arrange(desc(ticket_medio)) |> slice(1:2)
```

:::

##  Sobre el argumento `by`

-  Las claves, es decir, las variables que relacionan ambas tablas, se indican con 

    - `by = "varX"`, cuando la clave es una variable
  
    - `by = c("varX", "varY")`, cuando son varias variables

- Si los nombre son distintos en cada tabla, se empareja `x1` en la primera con `y1` en la segunda con `by = c("x1" = "y1", "x2" = "y2")` 


::::{.notes}
* Si se omite el argumento `by`, se usan todas las variables en común. <!-- de ambas tablas. --> Esto no siempre es deseable: ej., año no es lo mismo en `flights` y `planes`

* Columnas con el mismo nombre (ej., año) se desambigúan con un sufijo
::::

. . .

- Ej., calcular el bono medio de los Vendedores

```{r}
empleados |> filter(puesto == "Vendedor") |>
  left_join(promociones_empleado, 
            by = c("id_empleado" = "cod_empleado", 
                   "id_tienda" = "cod_tienda") ) |> 
  pull(monto_bono) |> mean(na.rm = T)
```

##  Claves duplicadas

- Si una coincidencia no es única, se generan todas las combinaciones posibles (producto cartesiano) de las observaciones coincidentes


- Un uso habitual de las uniones: los nombres completos de categorías se  ponen una tabla aparte y solo se une cuando se necesitan

```{r}
# margen medio por categoría de producto
productos |> 
  mutate(margen = precio - costo) |> 
  select(id_categoria, margen) |> 
  right_join(categorias,                 # ¿por qué right?
             by = c("id_categoria" = "categoria")) |>
    group_by(nombre_categoria) |> 
  summarize(margen_medio = mean(margen))
```


:::: {.notes}

* En **una tabla**: añade información adicional en una relación de uno a muchos.

![](figure/join-one-to-many.png){width=95% fig-align="center"}


```{r echo=FALSE}
df1dup <- tibble(clave = c(1, 2, 2, 1), val_x = c("x1", "x2", "x3", "x4"))
df2dup <- tibble(clave = c(1, 2), val_y = c("y1", "y2"))
df1dup %>% left_join(df2dup)
```

- En **ambas tablas**: igualmente, todas las combinaciones posibles


![](figure/join-many-to-many.png){width=85% fig-align="center"}

  + posible error: NO hay clave primaria única (que identifica una observación)
  
```{r}
df1dup2 <- tibble(clave = c(1, 2, 2, 3), val_x = c("x1", "x2", "x3", "x4"))
df2dup2 <- tibble(clave = c(1, 2, 2, 3), val_y = c("y1", "y2", "y3", "y4"))
df1dup2 %>% left_join(df2dup2)
```


- `base::merge()`  realizar los cuatro tipos de unión de transformación (usando las opciones `all.x = ` y `all.y = `, ver ayuda). 

- los verbos específicos de `dplyr` es que expresan más claramente la intención del código: la diferencia entre las uniones es realmente importante pero está oculta en los argumentos de `merge()`. Las uniones de dplyr son considerablemente más rápidas y no alteran el orden de las filas.


melt et al. <http://had.co.nz/reshape/>

::::


## Uniones de Filtrado

- Filtran las **observaciones** de la tabla de la izquierda basándose en si coinciden o no con una observación de la otra tabla


- Se tiene un subconjunto de las filas de la tabla de la izquierda

::::{.columns}
::: {.column width=50%}

* `semi_join(x, y)` mantiene las observaciones en `x` que están en `y`

![](figure/join-semi.png){width=95%}

```{r}
#| echo: false
df1 %>% semi_join(df2, 
          by = "clave")
```

:::

::: {.column width=50%}

* `anti_join(x, y)` elimina <!--todas--> las observaciones en `x` que están <!--coinciden--> en `y`

![](figure/join-anti.png){width=95%}

```{r}
#| echo: false
df1 %>% anti_join(df2, 
          by = "clave")
```
::: 

::::

::::{.notes}

- no afectan a las variables

- **Claves duplicadas**: en uniones de filtro sólo importa la existencia de una coincidencia, NO qué observación coincida $\Rightarrow$ NUNCA duplica filas

![](figure/join-semi-many.png){width=35% fig-align="center"}

```{r echo=FALSE}
df1dup2 %>% semi_join(df2dup2)
```

::::

## Uniones de Filtrado (cont.)

- Aplicación: ¿cuántos clientes tenemos y cuántos sí han comprado?

```{r}
clientes |> distinct(id_cliente) |> count()
clientes |> semi_join(ventas) |> distinct(id_cliente) |> count()
```

-  Aplicación: ¿qué productos NO han sido devueltos?

```{r}
#| echo: false
# Productos que NO han sido devueltos
productos_devueltos <- ventas |> 
  semi_join(devoluciones, by = "id_venta") |> 
  distinct(id_producto)

productos |> anti_join(productos_devueltos)
```

. . .

- Útiles para diagnosticar desajustes de uniones (qué observaciones serán emparejadas). Importante antes de unir tablas MUY grandes

```{r}
# empleados sin información de ventas
empleados |> anti_join(ventas, 
                       by = c("id_empleado", "id_tienda")) |> 
  count(id_empleado, id_tienda)  
```


::::{.notes}

- Utiles porque solo eliminan y nunca duplican observaciones

```{r}
#| echo: false
flights %>% anti_join(planes, by = "tailnum") %>%   # vuelos sin información del avión
              count(tailnum, sort = TRUE)

flights %>% count(tailnum, sort = TRUE)
```

::::



- Pueden ser una alternativa simple a usar `filter()` con filtrados complejos (que involucran varias variables), creando previamente tablas resumidas

  -Ej., venta promedio de los 10 productos con más cantidad vendida

::::{.notes}
Unión, PERO NO con tabla ya existente

Creamos una tabla para nuestro objetivo de unión de filtrado 

- Algunas  uniones de filtrado pueden ser equivalentes a usar `filter()`, con tablas previamente resumidas, pero permiten filtrados complejos (que involucran varias variables) fácilmente


```{r}
#| echo: false
top_dest <- flights %>% count(dest, sort = TRUE) %>% head(10)   # destinos populares
flights %>% filter(dest %in% top_dest$dest)
flights %>% semi_join(top_dest)
```

```{r}
#| echo: false
flights %>% count(dest, sort = TRUE) %>% head(10) 
flights %>% group_by(dest) %>% summarize(n=n()) %>% arrange(desc(n)) %>% head(10)
```

```{r}
#| echo: false
#| eval: false
flights %>% count(dest)
table(flights$dest)

flights %>% count(dest, sort = TRUE)

flights %>% filter(dest =="ORD" | dest = "ATL" | ...) 

top_dest$dest
flights %>% filter(dest %in% top_dest$dest) %>% summarize(media=mean(arr_delay))
flights %>% semi_join(top_dest)     
```

- ej., los diez días con más vuelos (o con los atrasos promedio más altos, necesita un filtro con varias variables (`year`, `month`, `day`)

```{r}
#| echo: false
top_dias <- flights %>% count(year, month, day, sort = TRUE) %>% head(3)
flights %>% semi_join(top_dias)
```

```{r}
#| echo: false
flights %>% filter(day %in% top_dias$day, month %in% top_dias$month) %>% distinct(day, month)
flights %>% semi_join(top_dias) %>% distinct(day, month)
```

::::



## Operaciones de conjunto

* Trabajan con filas completas, comparando valores de cada variable.

* Esperan que `x` e `y` tengan las **mismas variables**, y tratan las observaciones (filas) como elementos de un conjunto.

* Útil cuando se quiere dividir un filtro complejo en piezas más simples.

::::{.notes}

* Combinan las observaciones en los conjuntos de datos como si fueran elementos de un conjunto.   

::::

```{r}
df1 <- tibble(x = 1:2, y = c(1, 1))
df2 <- tibble(x = c(1,1), y = 1:2)

intersect(df1, df2)     # solo filas tanto en df1 como en df2
union(df1, df2)         # filas únicas en ambas tablas df1 y df2` 
union_all(df1, df2)     # todas las filas de df1 y df2, manteniendo duplicados 
setdiff(df1, df2)       # filas en df1, pero no en df2
setdiff(df2, df1)   
```


```{r}
#| echo: false
intersect(df1, df2)   # inner_join(df1,df2)
union(df1, df2)       # full_join(df1,df2)   # Notad que tenemos 3 filas, no 4
setdiff(df1, df2)     # anti_join(df1,df2)
setdiff(df2, df1)     # anti_join(df2, df1)
```


::::{.notes}
**Equivalencia con bases de datos SQL**

https://www.cs.utexas.edu/~mitra/csFall2006/cs329/lectures/sql.html

```{r}
#| echo: false
#| eval: false
#| results: asis
library(kableExtra)
#library(knitr)
tabla <- tribble(
     ~dplyr           ,     ~SQL                                                               ,
  "inner_join()"      ,	"SELECT * FROM x JOIN y ON x.a = y.a"                                  ,
  "left_join()"       ,	"SELECT * FROM x LEFT JOIN y ON x.a = y.a"                             ,
  "right_join()"      ,	"SELECT * FROM x RIGHT JOIN y ON x.a = y.a"                            ,
  "full_join()"       ,	"SELECT * FROM x FULL JOIN y ON x.a = y.a"                             ,
  "semi_join()"       ,	"SELECT * FROM x WHERE EXISTS (SELECT 1 FROM y WHERE x.a = y.a)"       ,
  "anti_join()"       ,	"SELECT * FROM x WHERE NOT EXISTS (SELECT 1 FROM y WHERE x.a = y.a)"   ,
  "intersect(x, y)"   ,	"SELECT * FROM x INTERSECT SELECT * FROM y"                            ,
  "union(x, y)"       ,	"SELECT * FROM x UNION SELECT * FROM y"                                ,
  "setdiff(x, y)"     , "SELECT * FROM x EXCEPT SELECT * FROM y"                              
)
tabla %>%
  kbl()  %>%
  kable_paper("hover", full_width = F, font_size = 22)
# tabla
```



* SQL soporta más tipos de unión y puede trabajar con más de dos tablas.


Como sugiere esta sintaxis,  más tipos de unión porque se pueden conectar las tablas usando restricciones diferentes a la igualdad (algunas veces llamadas no-equijoins).

`x` and `y` no tienen que ser tablas en la misma base de datos. Si especifica `copy = TRUE`, `dplyr` copiará la tabla `y` en el mismo lugar que `x`. 


Revisar las reglas de coerción. P. e., los factores se conservan sólo si los niveles coinciden exactamente; si no, se "coaccionan" (se fuerza su conversión) a tipo de carácter.

::::


## Buenas Prácticas

- Datos Ordenados

- Código Legible y reproducible

  1. Scripts ordenados y comentados
  
  2. Encadenar operacion con  `|>` en un paso por línea
  
  3. Inspeccionar resultados intermedios

  4. Documentar decisiones de limpieza
  
  5. Nombres descriptivos de variables
  
  6. Guardar datos procesados


- Errores comunes

  1. No verificar claves duplicadas en uniones

  2. Orden de operaciones incorrecto: ej., filtar después de `summarize()` por una variable que ya no existe

```{r}
#| echo: false

# PROBLEMA: claves duplicadas pueden multiplicar filas
df1 <- tibble(id = c(1, 1, 2), valor = c("A", "B", "C"))
df2 <- tibble(id = c(1, 2), info = c("X", "Y"))

resultado <- left_join(df1, df2, by = "id")
nrow(resultado)  # Esperamos 3, tenemos 3 (pero revisar lógica)

# VERIFICAR antes de hacer join
df1 %>% count(id) %>% filter(n > 1)  # ids duplicados
df2 %>% count(id) %>% filter(n > 1)  # ids duplicados

# SOLUCIÓN: decidir qué hacer con duplicados
df1_unico <- df1 %>% distinct(id, .keep_all = TRUE)
```


```{r}
#| echo: false
# PROBLEMA: filtrar después de summarize
ventas %>%
  group_by(id_tienda) %>%
  summarize(total = sum(total)) %>%
  filter(cantidad > 3)  # ERROR: cantidad ya no existe

# SOLUCIÓN: filtrar antes de summarize
ventas %>%
  filter(cantidad > 3) %>%
  group_by(id_tienda) %>%
  summarize(total = sum(total))
```


## Buenas Prácticas (cont.)

### Eficiencia:


1. Filtrar temprano, unir tarde

```{r}
ventas_2023 <- ventas |>
  filter(año == 2023) |>    # reduce tamaño
  left_join(productos, by = "id_producto")

ventas_2023_lento <- ventas |>
  left_join(productos, by = "id_producto") |>
  filter(año == 2023)
```

2. Seleccionar solo columnas necesarias

```{r}
#| echo: false
productos_minimo <- productos %>%
  select(id_producto, nombre_producto, precio)

ventas_join <- ventas %>%
  left_join(productos_minimo, by = "id_producto")
```


:::: {.notes}
**Recursos Adicionales**

- **Documentación:** `?dplyr`, `?tidyr`
- **Cheat Sheets:** RStudio > Help > Cheatsheets
- **Libros:** 
  - "R for Data Science" (Wickham & Grolemund)
  - "Advanced R" (Wickham)
- **Comunidad:** Stack Overflow, RStudio Community

::::
