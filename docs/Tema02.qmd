---
title: "Tema 02 - Limpieza y Tratamiento de Datos"
subtitle: "De datos en bruto a información útil para decidir con `tidyverse`"
author:  
    - "Pedro Albarrán"
    - "Alberto Pérez"
institute: "Dpto. de Fundamentos del Análisis Económico. Universidad de Alicante"
format:
  revealjs:
    logo: figure/by-nc-sa2.png
    titlegraphic: figure/by-nc-sa.png
    theme:  
        - beige
        - custom.scss
    smaller: true
    scrollable: true
    embed-resources: true
    slide-number: true
    show-slide-number: all
    transition: slide
    background-transition: fade
    progress: true
    height: 800
    width: 1200
    show-notes: false
    notes-format: html
execute:
  enabled: true      # execute code chunks
  eval: false        # by default, don't evaluate code chunks
  echo: true         # show code
  warning: false     # don't show warnings (redundant to eval: false)
  message: false     # don't show messages (idem)
  output: false      # don't show output (idem)
  fig.show: hide     # don't show figures (idem)
knitr:
  opts_chunk:         # OJO: reduntant to execute:
    results: hide     # ni muestra resultados ni figuras
    fig.show: hide
lang: es
strip-comments: true
toc: true
toc-depth: 1
toc-expand: false
toc-title: "Contenidos"
css: styles.css
---

```{r setup}
#| include: false
# se evalua pero no incluye output (mensajes, etc.)

# Elimino todo del Entorno (del documento)
rm(list = ls())

# Working directory
#setwd("/home/albarran/Dropbox/ECMTII/ECMTII/Slides_2023")

# Cargo todas las bibliotecas necesarias
# (se podría hacer cuando cada una sea necesaria)
library(tidyverse)
library(rio)
library(kableExtra)
library(rmarkdown)
```


```{r generar-datos}
#| echo: false

# Crear directorio para datos
if (!dir.exists("data")) dir.create("data")

set.seed(2024)

# ========================================
# DATASET: CATEGORÍAS
# ========================================
categorias <- data.frame(
  id_categoria = 1:8,
  nombre_categoria = c("Electrónica", "Ropa", "Hogar", "Deportes", 
                       "Alimentación", "Juguetes", "Libros", "Belleza"),
  margen_promedio = c(0.25, 0.45, 0.35, 0.40, 0.15, 0.35, 0.30, 0.50)
)

# ========================================
# DATASET: PRODUCTOS
# ========================================
productos <- data.frame(
  id_producto = 1:150,
  nombre_producto = paste0("Producto_", sprintf("%03d", 1:150)),
  id_categoria = sample(1:8, 150, replace = TRUE),
  precio = round(runif(150, 10, 500), 2),
  costo = round(runif(150, 5, 400), 2)
) %>%
  mutate(
    precio = ifelse(precio < costo, costo * 1.2, precio),
    activo = sample(c(TRUE, FALSE), 150, replace = TRUE, prob = c(0.9, 0.1))
  )

# ========================================
# DATASET: TIENDAS
# ========================================
tiendas <- data.frame(
  id_tienda = 1:12,
  nombre_tienda = c("Madrid Centro", "Barcelona Diagonal", "Valencia Puerto",
                    "Sevilla Este", "Bilbao Centro", "Málaga Costa",
                    "Zaragoza Plaza", "Alicante Playa", "Valladolid Norte",
                    "Vigo Mar", "Gijón Centro", "Murcia Sur"),
  region = c("Centro", "Nordeste", "Levante", "Sur", "Norte", "Sur",
             "Centro", "Levante", "Norte", "Noroeste", "Norte", "Levante"),
  tamaño_m2 = c(800, 1200, 600, 750, 900, 650, 700, 850, 500, 550, 600, 700),
  fecha_apertura = as.Date(c("2015-01-15", "2014-06-20", "2016-03-10",
                             "2015-09-05", "2017-02-14", "2016-11-22",
                             "2018-04-03", "2017-08-17", "2019-01-25",
                             "2018-10-09", "2019-05-30", "2020-02-18"))
)

# ========================================
# DATASET: EMPLEADOS
# ========================================
empleados <- data.frame(
  id_empleado = 1:85,
  nombre = paste0("Empleado_", 1:85),
  id_tienda = sample(1:12, 85, replace = TRUE),
  puesto = sample(c("Vendedor", "Supervisor", "Gerente", "Almacén"),
                  85, replace = TRUE, prob = c(0.6, 0.2, 0.1, 0.1)),
  fecha_contratacion = sample(seq(as.Date("2015-01-01"), 
                                  as.Date("2023-12-31"), by = "day"),
                              85, replace = TRUE)) %>%
  mutate(
    salario_mensual = case_when(
      puesto == "Vendedor" ~ round(rnorm(85, 1400, 200), 0),
      puesto == "Supervisor" ~ round(rnorm(85, 2000, 300), 0),
      puesto == "Gerente" ~ round(rnorm(85, 3000, 400), 0),
      puesto == "Almacén" ~ round(rnorm(85, 1300, 150), 0)),
    salario_mensual = pmax(salario_mensual, 1100)
  )

# ========================================
# DATASET: CLIENTES
# ========================================
clientes <- data.frame(
  id_cliente = 1:2500,
  email = paste0("cliente", 1:2500, "@email.com"),
  fecha_registro = sample(seq(as.Date("2015-01-01"), 
                              as.Date("2024-01-31"), by = "day"),
                          2500, replace = TRUE),
  codigo_postal = sample(c("28001", "08001", "46001", "41001", "48001",
                           "29001", "50001", "03001", "47001", "36001",
                           "33001", "30001"), 2500, replace = TRUE),
  programa_fidelidad = sample(c("Básico", "Silver", "Gold", "Platinum", NA),
                              2500, replace = TRUE, 
                              prob = c(0.4, 0.25, 0.15, 0.05, 0.15))
)

# ========================================
# DATASET: VENTAS (Principal - ~5000 registros)
# ========================================
# Generar fechas con mayor concentración en años recientes
fechas_ventas <- c(
  sample(seq(as.Date("2020-01-01"), as.Date("2021-12-31"), by = "day"),
         1000, replace = TRUE),
  sample(seq(as.Date("2022-01-01"), as.Date("2022-12-31"), by = "day"),
         1500, replace = TRUE),
  sample(seq(as.Date("2023-01-01"), as.Date("2023-12-31"), by = "day"),
         2000, replace = TRUE),
  sample(seq(as.Date("2024-01-01"), as.Date("2024-01-31"), by = "day"),
         500, replace = TRUE)
)

ventas <- data.frame(
  id_venta = 1:5000,
  fecha = sample(fechas_ventas, 5000, replace = FALSE),
  id_cliente = sample(clientes$id_cliente, 5000, replace = TRUE),
  id_producto = sample(productos$id_producto, 5000, replace = TRUE),
  id_tienda = sample(tiendas$id_tienda, 5000, replace = TRUE),
  id_empleado = sample(empleados$id_empleado, 5000, replace = TRUE),
  cantidad = sample(1:5, 5000, replace = TRUE, prob = c(0.5, 0.25, 0.15, 0.07, 0.03)),
  descuento_porcentaje = sample(c(0, 5, 10, 15, 20, 25),
                                5000, replace = TRUE,
                                prob = c(0.5, 0.2, 0.15, 0.1, 0.04, 0.01))
) %>%
  left_join(productos %>% select(id_producto, precio), by = "id_producto") %>%
  mutate(
    precio_unitario = precio,
    subtotal = cantidad * precio_unitario,
    descuento_aplicado = round(subtotal * descuento_porcentaje / 100, 2),
    total = subtotal - descuento_aplicado,
    año = year(fecha),
    mes = month(fecha),
    trimestre = quarter(fecha),
    dia_semana = wday(fecha, label = TRUE, abbr = FALSE, week_start = 1)
  ) %>%
  select(-precio)

# ========================================
# DATASET: EJEMPLO VENTAS_ANCHO
# ========================================
ventas_ancho <- tibble(
  tienda = c("Madrid", "Barcelona", "Valencia"),
  Q1 = c(145, 152, 138),
  Q2 = c(158, 164, 151),
  Q3 = c(151, 156, 149),
  Q4 = c(169, 175, 162)
)
# ========================================
# DATASET: DEVOLUCIONES
# ========================================
# Aproximadamente 5% de ventas tienen devolución
ventas_con_devolucion <- sample(ventas$id_venta, 
                                round(nrow(ventas) * 0.05), 
                                replace = FALSE)

devoluciones <- ventas %>%
  filter(id_venta %in% ventas_con_devolucion) %>%
  mutate(
    id_devolucion = row_number(),
    fecha_devolucion = fecha + sample(1:30, n(), replace = TRUE),
    motivo = sample(c("Defectuoso", "No satisfecho", "Talla incorrecta", 
                      "Color diferente", "Cambio de opinión"),
                    n(), replace = TRUE,
                    prob = c(0.15, 0.25, 0.20, 0.15, 0.25)),
    cantidad_devuelta = pmin(cantidad, sample(1:3, n(), replace = TRUE)),
    reembolso = round(total * (cantidad_devuelta / cantidad), 2),
    procesado = sample(c(TRUE, FALSE), n(), replace = TRUE, prob = c(0.9, 0.1))
  ) %>%
  select(id_devolucion, id_venta, fecha_devolucion, motivo, 
         cantidad_devuelta, reembolso, procesado)

# ========================================
# INFORMACIÓN DE VARIABLES
# ========================================
ventas_info <- data.frame(
  variable = c("id_venta", "fecha", "id_cliente", "id_producto", "id_tienda",
               "id_empleado", "cantidad", "descuento_porcentaje", "precio_unitario",
               "subtotal", "descuento_aplicado", "total", "año", "mes",
               "trimestre", "dia_semana"),
  descripcion = c(
    "Identificador único de la transacción de venta",
    "Fecha de la venta (formato YYYY-MM-DD)",
    "Identificador del cliente que realizó la compra",
    "Identificador del producto vendido",
    "Identificador de la tienda donde se realizó la venta",
    "Identificador del empleado que atendió la venta",
    "Número de unidades vendidas",
    "Porcentaje de descuento aplicado (0-25%)",
    "Precio por unidad del producto en euros",
    "Precio total antes de descuento (cantidad × precio_unitario)",
    "Importe del descuento aplicado en euros",
    "Precio final pagado por el cliente en euros",
    "Año de la venta",
    "Mes de la venta (1-12)",
    "Trimestre del año (1-4)",
    "Día de la semana de la venta"
  ),
  tipo = c("Entero", "Fecha", "Entero", "Entero", "Entero", "Entero",
           "Entero", "Numérica", "Numérica", "Numérica", "Numérica",
           "Numérica", "Entero", "Entero", "Entero", "Factor")
)

productos_info <- data.frame(
  variable = c("id_producto", "nombre_producto", "id_categoria", 
               "precio", "costo", "activo"),
  descripcion = c(
    "Identificador único del producto",
    "Nombre descriptivo del producto",
    "Identificador de la categoría a la que pertenece",
    "Precio de venta al público en euros",
    "Costo de adquisición/producción en euros",
    "Indica si el producto está activo en catálogo (TRUE/FALSE)"
  ),
  tipo = c("Entero", "Carácter", "Entero", "Numérica", "Numérica", "Lógico")
)

clientes_info <- data.frame(
  variable = c("id_cliente", "email", "fecha_registro", 
               "codigo_postal", "programa_fidelidad"),
  descripcion = c(
    "Identificador único del cliente",
    "Dirección de correo electrónico del cliente",
    "Fecha de registro en el sistema",
    "Código postal de residencia del cliente",
    "Nivel en el programa de fidelidad (Básico/Silver/Gold/Platinum/NA)"
  ),
  tipo = c("Entero", "Carácter", "Fecha", "Carácter", "Factor")
)

empleados_info <- data.frame(
  variable = c("id_empleado", "nombre", "id_tienda", "puesto",
               "fecha_contratacion", "salario_mensual"),
  descripcion = c(
    "Identificador único del empleado",
    "Nombre del empleado",
    "Identificador de la tienda donde trabaja",
    "Puesto de trabajo (Vendedor/Supervisor/Gerente/Almacén)",
    "Fecha de contratación del empleado",
    "Salario mensual bruto en euros"
  ),
  tipo = c("Entero", "Carácter", "Entero", "Factor", "Fecha", "Numérica")
)

tiendas_info <- data.frame(
  variable = c("id_tienda", "nombre_tienda", "region", "tamaño_m2",
               "fecha_apertura"),
  descripcion = c(
    "Identificador único de la tienda",
    "Nombre comercial de la tienda",
    "Región geográfica (Centro/Norte/Sur/Nordeste/Levante/Noroeste)",
    "Superficie de la tienda en metros cuadrados",
    "Fecha de apertura de la tienda"
  ),
  tipo = c("Entero", "Carácter", "Factor", "Numérica", "Fecha")
)

categorias_info <- data.frame(
  variable = c("id_categoria", "nombre_categoria", "margen_promedio"),
  descripcion = c(
    "Identificador único de la categoría",
    "Nombre de la categoría de productos",
    "Margen de beneficio promedio de la categoría (proporción)"
  ),
  tipo = c("Entero", "Carácter", "Numérica")
)

devoluciones_info <- data.frame(
  variable = c("id_devolucion", "id_venta", "fecha_devolucion", "motivo",
               "cantidad_devuelta", "reembolso", "procesado"),
  descripcion = c(
    "Identificador único de la devolución",
    "Identificador de la venta original asociada",
    "Fecha en que se procesó la devolución",
    "Motivo de la devolución (Defectuoso/No satisfecho/etc.)",
    "Cantidad de unidades devueltas",
    "Importe reembolsado al cliente en euros",
    "Indica si la devolución ha sido procesada (TRUE/FALSE)"
  ),
  tipo = c("Entero", "Entero", "Fecha", "Factor", "Entero", "Numérica", "Lógico")
)

# Guardar todos los datasets
save(ventas, productos, clientes, empleados, tiendas, 
     categorias, devoluciones, ventas_ancho,
     ventas_info, productos_info, clientes_info, 
     empleados_info, tiendas_info, categorias_info, devoluciones_info,
     file = "data/retail_data.RData")

# Exportar también a CSV para otros usos
# write_csv(ventas, "data/ventas.csv")
# write_csv(productos, "data/productos.csv")
# write_csv(clientes, "data/clientes.csv")
# write_csv(empleados, "data/empleados.csv")
# write_csv(tiendas, "data/tiendas.csv")
# write_csv(categorias, "data/categorias.csv")
# write_csv(devoluciones, "data/devoluciones.csv")
```

# Introducción. Datos Ordenados

## Limpieza y "doma" de datos 

:::: {.columns}
::: {.column width=40%}
- El ciclo de vida de los datos
::: 
::: {.column width=60%}
![](figure/data-science-wrangle.png){width=75% fig-align="center"}
:::
::::

- El desafío real del análisis de datos:

  - 80% del tiempo de [trabajo "sucio"](https://www.nytimes.com/2014/08/18/technology/for-big-data-scientists-hurdle-to-insights-is-janitor-work.html) : limpieza y preparación

  - 20% del tiempo: análisis y modelización

- `tidyverse` incluye una colección de bibliotecas con herramientes eficientes para el proceso de "tratamiento de datos" ("data wrangling")

:::: {.notes}
- En la vida real, los datos se tiene que recolectar, unir, limpiar, recodificar, etc.

- ofrece herramientas eficientes inspiradas en  declaraciones de consulta **SQL** 

- basadas en una *gramática de manipulación de datos*

::::

- El objetivo es obtener un conjunto de datos **ordenado** y **limpio** para realizar el análisis eficientemente y obtener información útil para la toma de decisiones


## Datos ordenados ('tidy data'): Principios fundamentales

1.- Cada columna es una **variable**: mide el mismo *atributo* entre unidades
  
2.- Cada fila es una **observación** (caso): misma *unidad* a través de atributos

3.- Cada celda es un **valor**


![](figure/tidy-1.png){width=65% fig-align="center"}

* Tenemos información similar y no redundante en una misma tabla 

* Es una forma natural (variable = vector columna) para trabajar con datos <!-- en R y otros lenguajes-->
 
```{r}
#| echo: false
# Para acceder al vector valores de `cases`

table1$cases                   # table1 %>% select(cases)
table2$count[c(1,3,5,7,9,11)]  # table2 %>% filter(type == "cases") %>%
                               #            select(count)
c(table4a$`1999`, table4a$`2000`)
# crear variables es fácil
table1 %>% mutate(rate = cases / population * 10000)  
```

* `tidyverse` es eficiente con datos ordenados 


```{r}
#| echo: false
# Ej. gráfico temporal

ggplot(table1, aes(x = year, y = cases)) +  
  geom_line(aes(colour = country))
```


:::: {.notes}


1. Atributos o características  (cuantitativos o cualitativos) diferentes en columnas diferentes; p.e., nombres de columnas no deben ser valores

2. Mismo nivel de agregación en toda la tabla

3. No mezclar tipos de datos Ni almacenar múltiples valores

  - Una tabla puede completar la información con uniones a tablas adicionales (ej., para variables codificadas)

```{r}
#| echo: false
# Ejemplo de datos ORDENADOS
head(ventas, 3)
```

::::

## Datos no ordenados

:::: {.columns}
::: {.column width=50%}
![](figure/tablaNOordenados.png){width=110% fig-align="center"}
::: 

::: {.column width=50%}
* Otras estructuras como [esta](https://datos.gob.es/es/catalogo/conjuntos-datos?q=hombres-segun-si-tienen-hijos-o-no-situacion-sentimental-y-edad&sort=score+desc%2C+metadata_created+desc) pueden tener sentido para *mostrar información* (o por convenciones)<!--para almacenar información -->


* La visualización es atractiva, PERO sobran filas para **analizar** los datos: ej., total de personas con hijos y sin pareja entre 30 y 39 años

::: 
::::


:::: {.notes}
```{r}
#| echo: false
# Ejemplo de datos NO ORDENADOS (comunes en Excel)
ventas_desordenadas <- data.frame(
  Tienda = c("Madrid Centro", "Barcelona", "Total"),
  Ene_2023 = c(45000, 52000, 97000),
  Feb_2023 = c(48000, 54000, 102000),
  Mar_2023 = c(51000, 56000, 107000)
)
ventas_desordenadas
```

**Problemas de estos datos:**

- Meses están en columnas (son valores, no variables)

- Fila "Total" mezcla niveles de agregación

- Difícil filtrar, agrupar o visualizar

**Por Qué Importan los Datos Ordenados**

**Ventajas:**

✓ Consistencia en todas las operaciones

✓ Fácil manipulación con `dplyr`

✓ Visualización directa con `ggplot2`

✓ Compatible con modelización

✓ Facilita colaboración

**Ejemplo Práctico:**

```{r eval=FALSE}
# Con datos ordenados: FÁCIL
ventas %>%
  group_by(id_tienda, mes) %>%
  summarize(ventas_total = sum(total))

# Con datos desordenados: COMPLEJO
# Requiere reshape, limpieza, etc.
```

::::



## Caso de Estudio: RetailCorp

- **Contexto:** Cadena de venta al por menor con 12 tiendas en España

- **Objetivo:** Analizar rendimiento de ventas para toma de decisiones estratégicas

. . .

```{r}
load("data/retail_data.RData")
```

:::: {.columns}
::: {.column width=50%}
- Recibe datos de 

  - Sistema de ventas (POS)
  
  - CRM de clientes
  
  - Inventario de productos
  
  - RRHH de empleados
  
  - Informes Excel de gerentes
  
:::

::: {.column width=40%}
**Problemas Típicos:**

- Formatos inconsistentes

- Datos duplicados

- Valores ausentes

- Estructuras inadecuadas

- Tablas dispersas
:::
::::


# Transformación de datos (una tabla)

:::: {.notes}
* `dplyr` frente R `base`

* sencillez, rapidez con big data, estilo SQL etc.

1.  select()  =  data[, c("name") / pos] 
              =  subset()

2.  filter()  =  data[c("name") / pos, ] 
              =  subset()

3.  mutate()  = data$newvar <- 
              = with(data, newvar = y - x)

4.  arrange() = order()
              [sort() es para vectores]

5.  summarize() = aggregate(data,income, FUN=mean)

6. groub_by() %>% summarize = aggregate(data,income~año, FUN=mean)
::::

## Funciones de transformación de datos

- La mayoría de operaciones pueden realizarse combinando 5 "verbos": 

  1. `select()`: selecciona columnas (variables)
  
  2. `filter()`: filtra (extraer) filas
  
  3. `mutate()`: crea nuevas columnas
  
  4. `arrange()`: ordena filas
  
  5. `summarize()`: crea resúmenes de la tabla
  
  - Más la tubería `%>%` o `|>` 
  
  - y `group_by()`

- NOTA: existe una colección de ["chuletas"](https://rstudio.com/resources/cheatsheets/) de R, p.e., para transformación.

- Todos tienen como primer argumento un *data frame*, los siguientes describen qué hacer (con columnas o filas) y devuelven otro *data frame*


## 1. `select()`

- **Selecciona variables** por nombres o posiciones de columnas, separados por comas


![](figure/select.png){width=100% fig-align="center"}


- Ej., un analista solo necesita información básica de ventas

```{r}
select(ventas, id_venta, fecha, id_tienda, id_producto, total)

select(ventas, 1:2, 5, 4, 12)
```

- Aplicación Empresarial:  el equipo de marketing solo necesita información de cliente y venta
```{r}
ventas_mkt <- select(ventas, 
                fecha, id_cliente, id_producto, total)
```



## 2. `filter()`

- Conserva filas en las que una *condición lógica* (o varias separadas por comas) es verdadera

![](figure/mutate.png){width=70% fig-align="center"}


- **Caso de Uso:** Gerente quiere analizar ventas específicas con determinadas características

```{r}
ventas_top      <- filter(ventas, total > 100)

ventas_ene_2024 <- filter(ventas, año == 2024, mes == 1)

ventas_mad_bcn  <- filter(ventas, id_tienda %in% c(1, 2))

ventas_premium  <- filter(ventas, 
                     total > 100 & descuento_porcentaje == 0)
```



```{r}
#| echo: false
# Ventas superiores a 100€
ventas_altas <- ventas %>%
  filter(total > 100)

# Ventas con descuento
ventas_con_descuento <- ventas %>%
  filter(descuento_porcentaje > 0)

# Filtro simple: ventas del último mes
ventas_enero_2024 <- ventas %>%
  filter(año == 2024, mes == 1)

nrow(ventas_enero_2024)  # ¿Cuántas ventas hubo?

# Ventas en tiendas específicas
ventas_madrid_bcn <- ventas %>%
  filter(id_tienda %in% c(1, 2))

# Combinando condiciones: ventas altas sin descuento
ventas_premium <- ventas %>%
  filter(total > 100, descuento_porcentaje == 0)

# Análisis de fin de semana vs días laborables
ventas_finde <- ventas %>%
  filter(dia_semana %in% c("sábado", "domingo"))

# Ventas problemáticas (alta cantidad + alto descuento)
ventas_revisar <- ventas %>%
  filter(cantidad > 3, descuento_porcentaje >= 20)

# Campaña de verano 2023
ventas_verano_2023 <- ventas %>%
  filter(año == 2023, mes %in% c(6, 7, 8))
```


## Encadenando operaciones con tuberías: `%>%` o `|>`

::: {style="font-size: 95%;"}

- Las operaciones encadenadas no son legibles o crean objetos intermedios

```{r}
ventas_top_markt <- select(filter(ventas, total > 100),
                      fecha, id_cliente, id_producto, total)

ventas_top        <- filter(ventas, total > 100)
ventas_top_markt  <- select(ventas_top, 
                       fecha, id_cliente, id_producto, total)
```

:::

. . .

::: {style="font-size: 95%;"}

- `datos %>% filter(condicion)` equivale a `filter(datos, condicion)`

- El anidamiento con tuberías sigue el flujo natural de lectura

  - Toma una tabla y pásala a un comando que acepta y produce un *data frame*
  - Toma la nueva tabla resultante y pásala a otro comando


```{r}
ventas_top_markt <- ventas |>                   
                     filter(total > 100) |>     
                     select(fecha, id_cliente, id_producto, total)
```


:::

:::: {.notes}

- Los objetos intermedios son innecesarios

- Aplicable a cualquier función: `10 |> log()` es `log(10)`

- Legible, fácil anidar operaciones: siempre toman y devuelve un *data frame*



- `ggplot2` `+` en lugar de `%>%` (desarrollado antes)

* Atajo de teclado: `Cmd / Ctrl + Mays + M `

* También existe una tubería en R base: `|>`

::::


## Funciones auxiliares de selección (de columnas)


```{r}
# Por rango de columnas
ventas |> select(id_venta:id_tienda)

# Excluir columnas
ventas |> select(-descuento_porcentaje, -descuento_aplicado)

# Por patrón de nombre
ventas |> select(starts_with("id_"))
ventas |> select(ends_with("_porcentaje"))
ventas |> select(contains("descuento"))

# Por tipo de dato
ventas |> select(where(is.numeric))
ventas |> select(where(is.character))
```

-  `pull()`: extrae una única columna, como **vector**
```{r}
ventas |> pull(cantidad) |> mean()
```


:::: {.notes}

```{r}
library(nycflights13)
select(flights, -(year:day))    # todas menos "year, month, day"
```

- `num_range("x", 1:3)`: para x1, x2 y x3.
- `matches()`: nombres que coinciden con una [expresión regular](https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular)

- `matches("(.)\\1")`: selecciona las variables que coinciden con una expresión regular (en este caso, cualquier variable que contenga caracteres repetidos).

::::

## 3. `mutate()`


:::: {.columns}

::: {.column width=55%}

- Crea o modifica variables mediante una *fórmula* a partir de otras columnas

:::

::: {.column width=45%}

![](figure/mutate.png){width=95% fig-align="center"}
::: 

::::

```{r}
ventas2 <- ventas |>
  mutate(
    precio_final_unitario = total / cantidad,
    es_inicio_mes         = day(fecha) <= 7
  )
```

- Funciones para operar con fechas (usando `lubridate`)

```{r}
ventas_tiempo <- ventas |>
  mutate(
    fecha_completa = as.Date(fecha),  # tipo de objeto "fecha"
    semana_año = week(fecha),
    nombre_mes = month(fecha, label = TRUE),
    dias_desde_venta = as.numeric(Sys.Date() - fecha)
  )
```

:::: {.notes}
- `lubridate` es parte de `tidyverse`
::::


## 4. `arrange()`

:::: {.columns}
::: {.column width=55%}
- re-ordena las filas todas las columnas de un *data frame*
  - en orden ascendente (por defecto) o descendente con `desc()`
:::

::: {.column width=45%}
![](figure/arrange.png){width=50% fig-align="center"}
::: 
::::

- *Caso de Uso:* Top 10 ventas más altas
```{r}
ventas |> 
  arrange(desc(total)) |> 
  select(id_venta, fecha, total) |> head(10) 
```

- Ordenamientos **múltiples**: ordena por la primera variable y luego, en caso de empate, por la siguiente, etc.
```{r}
ventas |>
  arrange(id_tienda, desc(total)) |>
  select(id_tienda, id_venta, total) |> head(10)
```

:::: {.notes}
- similar a Excel
- sort() es para un vector
::::


## 5. `summarize()`


:::: {.columns}
::: {.column width=55%}
- Crea un nuevo conjunto de datos de **una sola fila**, con variables nuevas de un solo valor que resumen los datos completos
:::
::: {.column width=45%}
![](figure/summarise.png){width=80% fig-align="center"}
:::
::::

- *Caso de Uso:* KPIs para el dashboard ejecutivo

```{r}
ventas |>
  summarize(
    total_ventas       = n(),           # Volumen (núm. de filas)
    ingresos_totales   = sum(total),    # Ingresos
    ingresos_promedio  = mean(total),
    ingresos_mediano   = median(total),
    descuento_promedio = mean(descuento_porcentaje), # Descuentos
    descuento_total    = sum(descuento_aplicado),
    unidades_vendidas  = sum(cantidad),             # Productos
    clientes_unicos    = n_distinct(id_cliente)     # Clientes 
                         # (núm. de filas distintas)
  )
```


```{r}
#| echo: false
# **Métricas de Distribución:**
# Análisis de dispersión de ventas
dispersion_ventas <- ventas %>%
  summarize(
    media = mean(total),
    desv_std = sd(total),
    minimo = min(total),
    q25 = quantile(total, 0.25),
    mediana = median(total),
    q75 = quantile(total, 0.75),
    maximo = max(total),
    rango_intercuartil = IQR(total)
  )

dispersion_ventas
```


## `group_by()`: Análisis por Grupos

- Cambia el alcance de *cada función* para que no actúe sobre todo el *data frame* sino en grupos individuales

. . .

- `group_by()` + `summarize()` = el poder de la agregación

  - **Concepto:** cambiar el nivel de análisis: de transacciones a tiendas, productos, etc.)
  
  - En Excel: *Tablas dinámicas*, *AGRUPARPOR()* (y *SUMAR.SI*/*SUMIF*) 

```{r}
ventas                             # tabla a nivel de transacción

ventas |>
  summarize(ingresos = sum(total)) # resumen global

ventas |>
  group_by(id_tienda) |>
  summarize(ingresos = sum(total)) # resumen por tienda
                                   # tabla a nivel de tienda
                                     
```

:::: {.notes}

- `group_by()` similar a facet

-  Ver  `ventas |> group_by(id_tienda)`: tibble muestra que hay dos grupos

- datos de información/ventas por empleado a información por tienda

- DEBEN INCLUIRSE variables que se quieran mantener
::::


## Combinando `mutate()` con `group_by()`

- **Diferencia Clave:**

  - `group_by() + summarize()`: Reduce filas (nuevo dataset agregado a nivel de los grupos)
  
  - `group_by() + mutate()`: Mantiene filas (añade columnas calculadas por grupo a nivel de la tabla original)

- Ejemplo: Porcentaje de las ventas mensuales que representa cada transacción

```{r}
ventas |>
  group_by(id_tienda, mes) |>
  mutate(
    ventas_tienda_mes = sum(total),
    pct_de_ventas_mes = total / ventas_tienda_mes * 100
  ) |>
  slice_max(pct_de_ventas_mes) |> 
  select(id_tienda, mes, id_venta, total, pct_de_ventas_mes)
```

## Análisis multinivel y `ungroup()`

::: {style="font-size: 92%;"}
- Encontrar la fecha con la mayor venta por tienda

```{r}
ventas |>
  group_by(id_tienda) |>
  arrange(desc(total)) |>  
  slice(1) |>                     # Primera fila (de cada grupo)
  select(id_tienda, fecha, total)
# alternativa: slice_max()
```


- **IMPORTANTE:** No olvidar `ungroup()` o `.groups = "drop"` después de terminar operaciones agrupadas



- Cálculo de Porcentajes Globales: sin desagrupar, `sum(total)` suma *por tienda* → siempre da 100%


```{r}
ventas |>
  group_by(id_tienda) |>
  mutate(ventas_tienda = sum(total)) |>
  ungroup() |>
  mutate(porcentaje = ventas_tienda / sum(total) * 100)
```

:::

:::: {.notes}
- Después de group_by() + mutate():

  - Si tu siguiente operación debe ser GLOBAL → usa ungroup()

  - Si debe seguir POR GRUPO → no uses ungroup()

- Después de group_by() + summarize():

  - summarize() ya reduce un nivel de agrupación

  - Si tenías múltiples grupos, sigue agrupado por los anteriores

  - Usa .groups = "drop" o ungroup() para estar seguro
::::


## Análisis multinivel y  `ungroup()` (cont.)

::: {style="font-size: 92%;"}
- Filtrar Top Global: sin desagrupar, será top 5 de *cada* tienda

```{r}
ventas |>
  group_by(id_tienda) |>
  mutate(ventas_tienda = sum(total), 
         .groups = "drop" ) |>
  arrange(desc(ventas_tienda)) |>
  slice_head(n = 5)
```


- Media Global después de agrupar: sin desagrupar, 1 fila por tienda (media mensual de cada tienda)

```{r}
# Ventas por tienda y mes
ventas_mes_por_tienda <- ventas |>
  group_by(id_tienda, mes) |>
  summarize(total_mes = sum(total))

ventas_mensuales_medias <- ventas_mes_por_tienda |>
  ungroup() |>
  summarize(media = mean(total_mes))
# Resultado: 1 fila (media de todos los meses de todas las tiendas)
```
:::

:::: {.notes}

- Ranking de Productos

```{r}
ventas |>
  group_by(id_producto) |>
  summarize(
    unidades_vendidas = sum(cantidad),
    ingresos_totales = sum(total)
  ) |>
  ungroup() |>                     # posteriores NO por grupos 
  arrange(desc(ingresos_totales))
# ungroup() innecesario con summarize en este caso
```


**Aplicación: Segmentación de Clientes**

```{r}
# Calcular valor del cliente
valor_cliente <- ventas |>
  group_by(id_cliente) |>
  mutate(
    num_compras_cliente = n(),
    gasto_total_cliente = sum(total),
    ticket_promedio = mean(total),
    
    # Clasificación RFM simplificada
    recencia_dias = as.numeric(max(fecha) - min(fecha)),
    frecuencia = n(),
    monetario = sum(total)
  ) |>
  ungroup()
```


**Problema:** Análisis de ventas navideñas en Madrid

```{r}
# SIN pipe: difícil de leer, muchas variables intermedias
ventas_madrid <- filter(ventas, id_tienda == 1)
ventas_madrid_navidad <- filter(ventas_madrid, mes == 12)
ventas_resumen <- summarize(ventas_madrid_navidad, 
                            total = sum(total),
                            n = n())

# CON pipe: flujo natural de lectura
analisis_navidad_madrid <- ventas |>
  filter(id_tienda == 1) |>
  filter(mes == 12) |>
  summarize(
    ingresos_totales = sum(total),
    num_transacciones = n(),
    ticket_promedio = mean(total)
  )

analisis_navidad_madrid
```

**Análisis Completo Paso a Paso**

**Objetivo:** Análisis de campaña de descuentos del Q4 2023

```{r}
analisis_campana_q4 <- ventas |>
  # 1. Filtrar período relevante
  filter(año == 2023, trimestre == 4) |>
  
  # 2. Agregar categoría de descuento
  mutate(
    tipo_descuento = case_when(
      descuento_porcentaje == 0 ~ "Sin descuento",
      descuento_porcentaje <= 10 ~ "Descuento bajo",
      descuento_porcentaje <= 20 ~ "Descuento medio",
      TRUE ~ "Descuento alto"
    )
  ) |>
  
  # 3. Agrupar por tipo de descuento
  group_by(tipo_descuento) |>
  
  # 4. Calcular métricas
  summarize(
    num_ventas = n(),
    ingresos_totales = sum(total),
    ticket_promedio = mean(total),
    unidades_vendidas = sum(cantidad),
    .groups = "drop"
  ) |>
  
  # 5. Ordenar por ingresos
  arrange(desc(ingresos_totales)) |>
  
  # 6. Calcular porcentajes
  mutate(
    pct_ventas = round(num_ventas / sum(num_ventas) * 100, 1),
    pct_ingresos = round(ingresos_totales / sum(ingresos_totales) * 100, 1)
  )

analisis_campana_q4
```

**Interpretación de Resultados:**

- Cada paso transforma el dataset

- El pipe hace el código legible como una narrativa

- Fácil añadir/quitar pasos para exploración
::::


## Funciones auxiliares para filas

- Extraer filas pero NO por condición: por posición (`slice()`, `slice_head()`), aleatoriamente (`slice_sample()`), etc.


```{r}
ventas |> slice_max(total, n = 5) # Top 5 ventas
ventas |> slice_sample(n = 100)   # sub-muestra aleatoria
```

* `distinct()`: extrae sólo las filas únicas (una o varias variables)
 
```{r}
ventas %>% distinct(id_producto)
```

* `drop_na()` y `replace_na()`: elimina/reemplaza filas con valores ausentes

```{r}
# Quita filas con NA en cualquier variable
ventas_completas <- ventas %>%
  drop_na()                    

# solo quita si precio_unitario es NA
ventas_completas_precio <- ventas %>%
  drop_na(precio_unitario)  
```

:::: {.notes}
- `slice_head()`, `slice_tail()`, `slice_min()`, `slice_max()`

1. Eliminar `NA` (valores ausentes), PERO

    - en *alguna variable*, con `na.rm=TRUE` o `filter(!is.na(x))` o `drop_na(x)` 

    - en *todo* el conjunto de datos con `drop_na()`

    - en `cor()`, `use = "complete.obs"`

```{r}
#| echo: false
data <- tibble(x1 = c(1:4, NA, 6.0, 7, NA), x2 = c(NA, 12:14, NA, 16.0, 17:18) )

data %>% summarize(num = n(), meanNA = mean(x1), mean = mean(x1, na.rm = TRUE))

data %>% filter(!is.na(x1)) %>% 
  summarize(num = n(), meanNA = mean(x1), mean   = mean(x1, na.rm = TRUE))

data %>% drop_na(x1) %>% summarize(num = n(), mean = mean(x1))   # drop_na(x2)?
data %>% drop_na()   %>% summarize(num = n(), mean = mean(x1))
```


2. Reemplazar con un valor, PERO ¿cúal?

  - NA por no presentarse a un examen es cero

  - NA por no contestar a pregunta de renta o gasto es ¿cero?

```{r}
#| echo: false
data %>% mutate(x1 = if_else(is.na(x1), 0, x1)) %>% summarize(num = n(), mean = mean(x1))
data %>% mutate(x1 = replace_na(x1,0))          %>% summarize(num = n(), mean = mean(x1))
```


- na.omit() vs. drop_na: el primero es de base (stats) el otro de tidyr

::::

## Otras funciones auxilidares de `tidyverse`

::: {style="font-size: 90%;"}
- Muchas funciones son equivalentes a otras de R base:

    - `parse_number()`, `parse_factor()`, etc. por `as.numeric()`, `as.factor()`, etc.
    - `bind_cols()` y `bind_rows()` por `cbind()` y `rbind()`

    - `if_else()` y `case_when()` para ejecución condicional (`ifelse()`)

```{r}
ventas |>
  mutate(
    tipo_venta = if_else(total > 100, "Alta", "Baja"), # condición simple
    categoria_cliente = case_when(              # múltiples condiciones
      total < 30  ~ "Económico",
      total < 100 ~ "Estándar",
      TRUE        ~ "Premium"               # OJO: convertir a factor
    )
  )
```

  
* Discretizar variables<!--numéricas a categóricas-->: `cut_interval()`, `cut_number()`, `cut_width()`

```{r}
#| echo: false
flights %>% mutate(retraso = cut_width(dep_delay,2))   # retraso es factor
```


- Funciones para fechas de `lubridate`: `year()`, `month()`, `day()`, `quarter()`, `week()`

```{r}
#| echo: false
# Análisis temporal detallado
ventas_tiempo_detalle <- ventas %>%
  mutate(
    # Componentes de fecha
    año = year(fecha),
    mes = month(fecha),
    dia = day(fecha),
    trimestre = quarter(fecha),
    semana = week(fecha),
    
    # Nombres legibles
    mes_nombre = month(fecha, label = TRUE, abbr = FALSE),
    dia_semana_nombre = wday(fecha, label = TRUE, abbr = FALSE),
    
    # Flags útiles
    es_lunes = wday(fecha) == 2,
    es_fin_semana = wday(fecha) %in% c(1, 7),
    es_quincena = day(fecha) %in% c(1, 15),
    
    # Diferencias temporales
    dias_desde_hoy = as.numeric(Sys.Date() - fecha),
    semanas_desde_inicio = as.numeric(difftime(fecha, min(fecha), units = "weeks"))
  )

# Ventas por día de la semana
ventas_tiempo_detalle %>%
  group_by(dia_semana_nombre) %>%
  summarize(
    num_ventas = n(),
    ingresos = sum(total),
    ticket_promedio = mean(total)
  ) %>%
  arrange(desc(ingresos))
```

:::


## Funciones auxiliares de creación de variables

- `rename()`: cambiar el nombre de una columna
```{r}
ventas_renamed <- ventas |>
  rename(
    fecha_venta = fecha,
    monto_total = total
  )
```

:::: {.notes}
  ![](figure/rename.png){width=70% fig-align="center"}
  
- `transmute()`: como `mutate()` pero solo mantiene las variables creadas
  
- `relocate()`: cambiar orden de columnas

```{r}
#| echo: false
# Reordenar columnas
ventas_reordenadas <- ventas %>%
  select(id_venta, fecha, total, everything())  # total al inicio

# Relocate (mover columnas)
ventas %>%
  relocate(total, .after = fecha) %>%
  relocate(starts_with("id_"), .before = everything())
```

::::

- `across()`: aplica la misma transformación a múltiples columnas

```{r}
ventas |> mutate(across(c(cantidad, subtotal:total), ~ log(.x)))
ventas |> mutate(across(where(is.character), ~ parse_factor(.x)))
```


- Operadores aritméticos (`+`, `-`, `*`, `/`, `^`, `%/%`, `%%`) y lógicos (`<`, `<=`, `>`, `>=`, `!=`)

- Funciones como `log()`, `lag()`, `lead()`, `cumsum()`, `row_number()` etc.


:::: {.notes}

- combinados con otros: funciones de "agregación" `x - mean(x)`, `y - sum(y)` 

- Ordenamiento: `row_number()` 

- `min_rank()`, `row_number()` y otras de `dplyr::ranking`

- `percent_rank()`, `cume_dist()`

```{r}
#| echo: false
y <- c (10, 2, 2, NA, 30, 4)
min_rank(y)               
min_rank(desc(y))
row_number(y)
```

- Agregados acumulativos y móviles: ver ayuda de `cumsum()`  y `cummean()` 

```{r}
#| echo: false
cumsum(1:10)
cumprod(1:10)
cummin(1:10)
cummax(1:10)
cummean(1:10)
```

::::

## Funciones auxiliares de resumen

- `count()`: cuenta los valores únicos de una o más variables

```{r}
ventas |> count(id_tienda)
# ventas |> group_by(id_tienda) |>  summarize(n = n())
ventas |> count(id_tienda, sort = TRUE)
```

```{r}
#| echo: false
ventas |>
  group_by(id_tienda) |>
  summarize(n = n()) |>
  arrange(desc(n))


# Conteos múltiples
ventas |>
  count(id_tienda, mes, name = "num_ventas")

# add_count(): añade conteo sin agrupar
ventas |>
  add_count(id_producto, name = "veces_vendido") |>
  filter(veces_vendido > 50) |>
  select(id_venta, id_producto, veces_vendido)
```

. . .

* Medidas de centralidad y de dispersión: `mean(x)`, `median(x)`, `sd(x)`, `IQR(x)` <!--, `mad(x)` -->

* Medidas de rango: `min(x)`, `quantile(x, 0.25)`, `max(x)`

* Medidas de posición: `first(x)`, `nth(x, 2)`, `last(x)`. 

:::: {.notes}
- similar a `x[1]`, `x[2]` y `x[length(x)]`
::::

* Sumas, productos, etc.

* Conteos: 

  - `n()`: observaciones totales (tamaño del grupo)
  
  - `n_distinct(x)`:  filas distintas en `x`

:::: {.notes}

- `sum(!is.na(x))`: observaciones no ausentes

- más rápido que unique() 
::::
  

```{r}
#| echo: false
# Valores distintos
ventas %>%
  summarize(
    productos_unicos = n_distinct(id_producto),
    clientes_unicos = n_distinct(id_cliente)
  )
```

## Operaciones Adicionales de Limpieza

::: {style="font-size: 90%;"}

- `separate()`: dividir una columna por caracter o posición

```{r}
table3 |> separate(rate, into = c("cases", "population"), sep = "/")
tabla5 <- table3 |> separate(year, into = c("century", "year"), sep = 2)
```

- Con  `convert = TRUE` intenta convertir el tipo de dato (no mantener carácter)

```{r}
table3 |> separate(rate, into = c("cases", "population"), convert = TRUE)
```

:::: {.notes}

- Argumentos: *date frame*, columna a dividir, nombres de las nuevas variables y carácter separador (por defecto cualquier carácter no numérico)

(estrictamente, una expresión regular)


- Si se pasa a `sep` un vector de enteros, son posiciones en las que dividir
- la longitud de `sep` debe ser uno menos que la de `into`
- valores positivos comienzan (en 1)por la izquierda; negativos (desde -1) por la derecha

::::


- `unite()`: combinar columnas

```{r}
table5 |> unite(new, century, year, sep = "-")
```

:::: {.notes}
- Argumentos: 
  - un *data frame*
  - el nombre de la nueva variable a crear 
- un conjunto de columnas a combinar
- carácter entre valores de las columnas originales

- El separador por defecto es subrayado, `sep = _`

::::

:::

. . .

::: {style="font-size: 90%;"}
- Para nombres de columnas con espacios o caracteres especiales, debemos usar acento invertido

  - Mejor: renombrar sin espacios

```{r}
datos_problema |> 
  rename(nombre_producto = `Nombre Producto`,
         precio_euros    = `Precio (€)`)
```

:::


# Transformación de Datos: Pivotar

:::: {.notes}

** Cuatro representaciones de los mismos datos

```{r}
library(tidyverse)
table1     # datos ordenados
table2     # varios valores por celda
```


![](figure/tidyvsmessy01_n.png){width=60% fig-align="center"}

![](figure/tidyvsmessy02_n.png){width=60% fig-align="center"}


```{r}
table3     # más de una variable en una columna
table4a 
table4b
```

* `table4a` y `table4b` ofrecen información útil para presentación
pero
- variables tanto en filas como columnas
- las cabeceras de columna son valores, no nombres de variables.

![](figure/tidyvsmessy04a_n.png){width=60% fig-align="center"}




**Mismos datos, dos formatos: ancho o largo**

:::: {.columns}

::: {.column width=50%}

* La utilidad de almacenar los datos en un rectángulo ancho ("wide") o en uno largo ("long")  depende de qué queramos hacer

  * P.e., Excel prefiere el formato largo para tablas dinámicas, fórmulas de agregación (*SUMAR.SI*) y algunos gráficos


:::

::: {.column width=50%}

![](./figure/original-dfs-tidy.png){width=100%}
:::

::::

- El cambio de forma  entre formatos es una tarea habitual del analista de datos. 

- Cambiar entre representación larga y ancha se conoce como **pivotar (o girar)**

```{r}
table4a        # formato ancho
table1         # formato largo
```


- En general, el formato largo es más útil para el análisis 

- El cambio de forma =  "reshaping"

- DISTINTO de trasponer filas y columnas en Excel

- Existe una función para pivotar en Excel

**Cambiar la forma de una tabla (pivotar / girar)**

* Las celdas en un formato se reordenan en el otro

![](figure/tidyr-longer-wider.gif){width=45% fig-align="center"}

* Los metadatos que no se reordenan son extendidos/reducidos para no perder información. 

https://tidyr.tidyverse.org/ 

* reshape en R base:  https://jozef.io/r001-reshape/

https://www.r-bloggers.com/2019/07/how-to-reshape-a-dataframe-from-wide-to-long-or-long-to-wide-format/


<https://www.r-bloggers.com/how-to-reshape-data-in-r-tidyr-vs-reshape2/>

<https://www.r-bloggers.com/pivoting-tidily/>


**Verbos principales en `tidyr`**

* `pivot_longer()`: cambia la forma de "anchos" a "largos" (+filas/-cols)

    + **ordena** datos originales para facilitar el análisis.

* `pivot_wider()` cambia la forma de "largos" a "anchos" (+cols/-filas)

    + útil para crear tablas de resumen o un formato para otras herramientas.

![](figure/long-wide.png){width=75% fig-align="center"}

 La longitud es un término relativo, y sólo se puede decir (por ejemplo) que el conjunto de datos A es más largo que el conjunto de datos B.

::::

## Mismos datos, dos formatos: ancho o largo

::::{.notes}
- Se pueden almacenar datos en uno u otro formato, según nuestro objetivos

  - P.e., largo en Excel para tablas dinámicas, fórmulas de agregación (SUMAR.SI), algunos gráficos
  
::::

::: {style="font-size: 95%;"}

:::: {.columns}

::: {.column width="50%"}

**Formato ANCHO:**

| tienda | Q1 | Q2 | Q3 | Q4 |
|--------|----|----|----|----|
| Madrid | 145 | 158 | 151 | 169 |
| Barcelona | 152 | 164 | 156 | 175 |
| Valencia | 138 | 151 | 149 | 162 |

<br>

```{r}
ventas_ancho
```
 (datos del informe enviado por gestores)

:::

::: {.column width="50%"}

**Formato LARGO:**

| tienda | trimestre | ventas |
|--------|-----------|----------|
| Madrid | Q1 | 145 |
| Madrid | Q2 | 158 |
| Madrid | Q3 | 151 |
| Madrid | Q4 | 169 |
| Barcelona | Q1 | 152 |
| ... | ... | ... |


:::

::::

:::: {.columns}

::: {.column width="50%"}

- Los trimestres son **columnas**

- Cada tienda = 1 fila

- Análisis de datos a menudo complicado

:::

::: {.column width="50%"}

- Los trimestres son **valores**

- Cada tienda-trimestre = 1 fila

- No adecuado para tablas de presentación final

:::

::::

:::

## `pivot_longer()`: girar de ancho a largo

::: {style="font-size: 90%;"}

:::: {.columns}

::: {.column width="50%"}

- Girar para analizar los datos

```{r}
ventas_largo <- ventas_ancho |>
  pivot_longer(
    cols = Q1:Q4,              
    names_to = "trimestre",    
    values_to = "ventas"       
  )
```


:::

::: {.column width="50%"}

![](figure/longer.png){width=100% fig-align="center"}

:::

::::

1. tabla a cambiar de forma

2. nombres o índices (numéricos) de las columnas a girar: representan valores, no variables 

3. nombre para la nueva variable que tendrá, como valores, esas antiguas columnas a girar

4. nombre para la nueva variable que tendrá como valores las antiguas celdas

:::

:::: {.notes}

- Recordad que existen formas equivalentes de hacer lo mismo
```{r}
#| echo: false
pivot_longer(table4a, 2:3, names_to = "year", values_to = "cases")       
table4a %>% pivot_longer(c(`1999`, `2000`), values_to = "cases", names_to = "year")
table4a %>% pivot_longer(names_to = "year", values_to = "cases", -country)
table4a %>% pivot_longer(names_to = "year", values_to = "cases", `1999`:`2000`)
```

```{r}
table4a %>% pivot_longer(cols = `1999`:`2000`, 
                         values_to = "cases", names_to = "year")
```

- Notar que los nombres de columna son caracteres y cuando son números van entre \` (evita confusión con índice de posición)

```{r}
#| echo: false
table4a %>% pivot_longer(c(1999, 2000), values_to = "cases", names_to = "year")
table1 %>% mutate(`tasa por 1000 mil habitantes` = cases/population*1000,
                  tasa =cases/population*1000)
```

- Deberíamos cambiar el tipo de las nuevas variables 

::::


## `pivot_wider()`: girar de largo a ancho



:::: {.columns}

::: {.column width="50%"}

- Girar para crear tabla de presentación

```{r}
ventas_largo |>             
  pivot_wider(
    names_from = trimestre, 
    values_from = ventas    
  )
```

:::

::: {.column width="50%"}

![](figure/wider.png){width=100% fig-align="center"}
:::

::::

1. tabla a cambiar de forma

2. nombre de la variable cuyos valores dan nombre a las nuevas columnas

3. nombre de la variable de cuyas celdas toman los valores las nuevas columnas


## Comparación: Tareas Comunes

::: {style="font-size: 90%;"}

- Según nuestro objetivos, podemos preferir formato ancho o largo

- Problemas prácticos con formato ancho para **analizar datos**:

::::{.notes}

- P.e., largo en Excel para tablas dinámicas, fórmulas de agregación (SUMAR.SI), algunos gráficos

- Total por trimestre: en formato ancho, posible pero repetitivo

```{r}
#| echo: false
# Formato ANCHO: posible pero repetitivo
tibble(
  trimestre = c("Q1", "Q2", "Q3", "Q4"),
  total = c(sum(ventas_ancho$Q1),
            sum(ventas_ancho$Q2),
            sum(ventas_ancho$Q3),
            sum(ventas_ancho$Q4))
)

# Formato LARGO: una sola operación
ventas_largo <- ventas_ancho |>
  pivot_longer(Q1:Q4, names_to = "trimestre", values_to = "ingresos")

ventas_largo |>
  group_by(trimestre) |>
  summarize(total = sum(ventas))
```

- Filtrar trimestres específicos

```{r}
# Formato ANCHO: difícil - ¿cómo filtro "solo Q2 y Q3"?
ventas_ancho |>
  select(tienda, Q2, Q3)  # Solo puedo seleccionar columnas, no filtrar

# Formato LARGO: trivial
ventas_largo |>
  filter(trimestre %in% c("Q2", "Q3"))
```

::::

1. Algunas tareas son imposibles. P.e., ¿qué trimestres superan 160 en ventas?

```{r}
ventas_largo |>
  filter(ventas > 160)
```

2. Código repetitivo y propenso a errores. P.e., Calcular crecimiento

```{r}
ventas_ancho |>
  mutate(
    crec_Q2 = (Q2 - Q1) / Q1 * 100,
    crec_Q3 = (Q3 - Q2) / Q2 * 100,
    crec_Q4 = (Q4 - Q3) / Q3 * 100
  )

ventas_largo |>
  group_by(tienda) |>
  mutate(crecimiento = (ventas - lag(ventas)) / lag(ventas) * 100)
```

::::{.notes}

1. formato ancho: tarea manual difícil con muchas fechas)

2. formato ancho: cada columna manualmente, difícil con muchas fechas

::::

:::  

## Comparación: Tareas Comunes (cont.)

::: {style="font-size: 90%;"}

  

3. No escalable. P.e., gráfico temporal por grupos

```{r}
ggplot(ventas_ancho) +
  geom_line(aes(x = 1:4, y = c(Q1[1], Q2[1], Q3[1], Q4[1])), color = "red") +
  geom_line(aes(x = 1:4, y = c(Q1[2], Q2[2], Q3[2], Q4[2])), color = "blue") +
  geom_line(aes(x = 1:4, y = c(Q1[3], Q2[3], Q3[3], Q4[3])), color = "green")

ggplot(ventas_largo, aes(x = trimestre, y = ventas, 
                         color = tienda, group = tienda)) +
  geom_line() + geom_point()
```

:::  

. . .

::: {style="font-size: 90%;"}

- Formato ancho solo para tablas de presentación final

```{r}
analisis <- ventas_largo |>
  group_by(trimestre) |>
  summarize(total = sum(ingresos))

tabla_presentacion <- ventas_largo |>
  pivot_wider(names_from = trimestre, values_from = ingresos) |>
  mutate(Total = Q1 + Q2 + Q3 + Q4)
```

:::  


# Datos Relacionales

## Por Qué Múltiples Tablas

**Ventajas del Diseño Relacional:**

1. **Eficiencia:** No repetir información
2. **Consistencia:** Un solo lugar para actualizar
3. **Integridad:** Relaciones claras entre datos
4. **Escalabilidad:** Fácil añadir nuevas tablas

```{r}
# Ejemplo: información duplicada vs relacional

# MAL: Todo en una tabla (información repetida)
ventas_todo_junto <- ventas %>%
  left_join(productos, by = "id_producto") %>%
  left_join(tiendas, by = "id_tienda") %>%
  left_join(clientes, by = "id_cliente")

# BIEN: Tablas separadas, unir solo cuando necesario
# ventas, productos, tiendas, clientes son tablas independientes
```

## Tipos de Uniones: Visión General

```{r}
# Datos de ejemplo para ilustrar
df1 <- tibble(id = 1:3, valor_x = c("A", "B", "C"))
df2 <- tibble(id = c(1, 2, 4), valor_y = c("X", "Y", "Z"))

# inner_join: solo coincidencias
inner_join(df1, df2, by = "id")  # resultado: 1, 2

# left_join: todas de la izquierda
left_join(df1, df2, by = "id")   # resultado: 1, 2, 3 (3 con NA)

# right_join: todas de la derecha
right_join(df1, df2, by = "id")  # resultado: 1, 2, 4 (4 con NA)

# full_join: todas de ambas
full_join(df1, df2, by = "id")   # resultado: 1, 2, 3, 4
```

## Caso Real: Enriquecer Datos de Ventas

**Objetivo:** Análisis completo con información de todas las tablas

```{r}
# Crear dataset completo para análisis
ventas_completo <- ventas %>%
  # Información de productos
  left_join(productos %>% select(id_producto, nombre_producto, id_categoria, precio, costo),
            by = "id_producto") %>%
  
  # Información de categorías
  left_join(categorias, by = "id_categoria") %>%
  
  # Información de tiendas
  left_join(tiendas %>% select(id_tienda, nombre_tienda, region, tamaño_m2),
            by = "id_tienda") %>%
  
  # Información de clientes
  left_join(clientes %>% select(id_cliente, programa_fidelidad, fecha_registro),
            by = "id_cliente") %>%
  
  # Información de empleados
  left_join(empleados %>% select(id_empleado, puesto),
            by = "id_empleado")

# Ahora podemos hacer análisis complejos
glimpse(ventas_completo)
```

**Análisis Enriquecido:**

```{r}
# Rentabilidad por categoría y región
analisis_rentabilidad <- ventas_completo %>%
  mutate(
    margen_venta = precio - costo,
    rentabilidad = margen_venta * cantidad
  ) %>%
  group_by(nombre_categoria, region) %>%
  summarize(
    num_ventas = n(),
    ingresos = sum(total),
    rentabilidad_total = sum(rentabilidad, na.rm = TRUE),
    margen_porcentaje = round(mean(margen_venta / precio * 100, na.rm = TRUE), 1),
    .groups = "drop"
  ) %>%
  arrange(desc(rentabilidad_total))

head(analisis_rentabilidad, 10)
```


**Caso de Uso:** Performance por región y mes

```{r}
# Primero unir con info de tiendas para obtener región
performance_regional <- ventas %>%
  left_join(tiendas %>% select(id_tienda, region), by = "id_tienda") %>%
  group_by(region, año, mes) %>%
  summarize(
    ventas_totales = n(),
    ingresos = sum(total),
    ticket_promedio = mean(total),
    .groups = "drop"
  ) %>%
  arrange(region, año, mes)

head(performance_regional, 10)
```


**Caso de Uso:** Performance por región y mes

```{r}
# Primero unir con info de tiendas para obtener región
performance_regional <- ventas %>%
  left_join(tiendas %>% select(id_tienda, region), by = "id_tienda") %>%
  group_by(region, año, mes) %>%
  summarize(
    ventas_totales = n(),
    ingresos = sum(total),
    ticket_promedio = mean(total),
    .groups = "drop"
  ) %>%
  arrange(region, año, mes)

head(performance_regional, 10)
```

- **Aplicación:** Crecimiento anual

```{r}
# Comparación mensual por región
crecimiento_mensual <- performance_regional %>%
  group_by(region, mes) %>%
  arrange(año) %>%
  mutate(
    ingresos_año_anterior = lag(ingresos),
    crecimiento_absoluto = ingresos - ingresos_año_anterior,
    crecimiento_porcentual = round(
      (ingresos - ingresos_año_anterior) / ingresos_año_anterior * 100, 1
    )
  ) %>%
  filter(!is.na(crecimiento_porcentual))

# Regiones con mayor crecimiento
crecimiento_mensual %>%
  filter(año == 2023) %>%
  group_by(region) %>%
  summarize(crecimiento_promedio = mean(crecimiento_porcentual, na.rm = TRUE)) %>%
  arrange(desc(crecimiento_promedio))
```


## Uniones de Filtrado

**semi_join:** Mantener filas que tienen coincidencia

```{r}
# Clientes que SÍ han comprado
clientes_activos <- clientes %>%
  semi_join(ventas, by = "id_cliente")

nrow(clientes_activos)  # ¿Cuántos clientes activos?

# Productos que SÍ se han vendido
productos_vendidos <- productos %>%
  semi_join(ventas, by = "id_producto")
```

**anti_join:** Mantener filas que NO tienen coincidencia

```{r}
# Clientes registrados pero sin compras
clientes_sin_compras <- clientes %>%
  anti_join(ventas, by = "id_cliente")

nrow(clientes_sin_compras)  # Oportunidad de marketing

# Productos en catálogo pero nunca vendidos
productos_sin_vender <- productos %>%
  anti_join(ventas, by = "id_producto") %>%
  filter(activo == TRUE)  # y que estén activos

nrow(productos_sin_vender)  # ¿Eliminar del catálogo?
```

## Uniones con Claves Múltiples

```{r}
# Crear tabla de objetivos mensuales por tienda
objetivos <- tibble(
  id_tienda = rep(1:12, each = 12),
  mes = rep(1:12, times = 12),
  objetivo_ingresos = runif(144, 30000, 80000)
)

# Comparar ventas reales vs objetivos
comparacion_objetivos <- ventas %>%
  group_by(id_tienda, mes) %>%
  summarize(ingresos_reales = sum(total), .groups = "drop") %>%
  left_join(objetivos, by = c("id_tienda", "mes")) %>%
  mutate(
    diferencia = ingresos_reales - objetivo_ingresos,
    cumplimiento_pct = round(ingresos_reales / objetivo_ingresos * 100, 1),
    cumple_objetivo = cumplimiento_pct >= 100
  )

# Tiendas que más superan objetivos
comparacion_objetivos %>%
  filter(cumple_objetivo) %>%
  group_by(id_tienda) %>%
  summarize(
    meses_cumplidos = n(),
    exceso_promedio = mean(diferencia)
  ) %>%
  arrange(desc(meses_cumplidos))
```

## Caso de Estudio Completo: Análisis de Devoluciones

### Problema de Negocio

**Contexto:** Gerente de operaciones preocupado por devoluciones

**Preguntas:**
1. ¿Qué productos tienen más devoluciones?
2. ¿Hay patrones por tienda o categoría?
3. ¿Impacto financiero de las devoluciones?
4. ¿Recomendaciones accionables?

### Paso 1: Exploración Inicial

```{r}
# Visión general de devoluciones
glimpse(devoluciones)

# Estadísticas básicas
devoluciones %>%
  summarize(
    total_devoluciones = n(),
    tasa_devolucion = n() / nrow(ventas) * 100,
    reembolso_total = sum(reembolso),
    reembolso_promedio = mean(reembolso),
    dias_promedio = mean(as.numeric(fecha_devolucion - 
                        ventas$fecha[match(id_venta, ventas$id_venta)]), na.rm = TRUE)
  )
```

### Paso 2: Análisis por Motivo

```{r}
# Distribución de motivos
analisis_motivos <- devoluciones %>%
  group_by(motivo) %>%
  summarize(
    num_devoluciones = n(),
    reembolso_total = sum(reembolso),
    .groups = "drop"
  ) %>%
  mutate(
    pct_devoluciones = round(num_devoluciones / sum(num_devoluciones) * 100, 1),
    pct_reembolso = round(reembolso_total / sum(reembolso_total) * 100, 1)
  ) %>%
  arrange(desc(num_devoluciones))

analisis_motivos

# Visualización
ggplot(analisis_motivos, aes(x = reorder(motivo, num_devoluciones), 
                              y = num_devoluciones)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(title = "Devoluciones por Motivo",
       x = "Motivo", y = "Número de Devoluciones") +
  theme_minimal()
```

## Caso de Estudio Completo (cont.)

### Paso 3: Productos Problemáticos

```{r}
# Unir devoluciones con ventas y productos
productos_devueltos <- devoluciones %>%
  left_join(ventas %>% select(id_venta, id_producto, id_tienda), 
            by = "id_venta") %>%
  left_join(productos %>% select(id_producto, nombre_producto, id_categoria),
            by = "id_producto") %>%
  left_join(categorias %>% select(id_categoria, nombre_categoria),
            by = "id_categoria")

# Top productos con más devoluciones
productos_problema <- productos_devueltos %>%
  group_by(id_producto, nombre_producto, nombre_categoria) %>%
  summarize(
    num_devoluciones = n(),
    reembolso_total = sum(reembolso),
    .groups = "drop"
  ) %>%
  arrange(desc(num_devoluciones)) %>%
  head(20)

productos_problema

# Calcular tasa de devolución por producto
tasa_devolucion_producto <- ventas %>%
  group_by(id_producto) %>%
  summarize(
    veces_vendido = n(),
    .groups = "drop"
  ) %>%
  left_join(
    devoluciones %>%
      left_join(ventas %>% select(id_venta, id_producto), by = "id_venta") %>%
      group_by(id_producto) %>%
      summarize(veces_devuelto = n(), .groups = "drop"),
    by = "id_producto"
  ) %>%
  mutate(
    veces_devuelto = replace_na(veces_devuelto, 0),
    tasa_devolucion = round(veces_devuelto / veces_vendido * 100, 2)
  ) %>%
  filter(veces_vendido >= 10) %>%  # solo productos con suficientes ventas
  arrange(desc(tasa_devolucion))

head(tasa_devolucion_producto, 10)
```

### Paso 4: Análisis por Tienda y Categoría

```{r}
# Devoluciones por tienda
devoluciones_tienda <- productos_devueltos %>%
  left_join(tiendas %>% select(id_tienda, nombre_tienda, region),
            by = "id_tienda") %>%
  group_by(id_tienda, nombre_tienda, region) %>%
  summarize(
    num_devoluciones = n(),
    reembolso_total = sum(reembolso),
    .groups = "drop"
  )

# Calcular tasa de devolución por tienda
ventas_por_tienda <- ventas %>%
  group_by(id_tienda) %>%
  summarize(num_ventas = n(), .groups = "drop")

comparacion_tiendas <- ventas_por_tienda %>%
  left_join(devoluciones_tienda, by = "id_tienda") %>%
  mutate(
    num_devoluciones = replace_na(num_devoluciones, 0),
    tasa_devolucion = round(num_devoluciones / num_ventas * 100, 2)
  ) %>%
  left_join(tiendas %>% select(id_tienda, nombre_tienda, region),
            by = "id_tienda") %>%
  arrange(desc(tasa_devolucion))

comparacion_tiendas

# Por categoría
devoluciones_categoria <- productos_devueltos %>%
  group_by(nombre_categoria) %>%
  summarize(
    num_devoluciones = n(),
    reembolso_total = sum(reembolso),
    motivo_principal = names(sort(table(motivo), decreasing = TRUE))[1],
    .groups = "drop"
  ) %>%
  arrange(desc(num_devoluciones))

devoluciones_categoria
```

## Caso de Estudio Completo (y 3)
### Paso 5: Impacto Financiero

```{r}
# Impacto total
impacto_financiero <- ventas %>%
  summarize(
    ingresos_brutos = sum(total),
    .groups = "drop"
  ) %>%
  mutate(
    reembolsos = sum(devoluciones$reembolso),
    ingresos_netos = ingresos_brutos - reembolsos,
    tasa_devolucion_financiera = round(reembolsos / ingresos_brutos * 100, 2)
  )

impacto_financiero

# Impacto por período
impacto_temporal <- ventas %>%
  mutate(año_mes = paste(año, sprintf("%02d", mes), sep = "-")) %>%
  group_by(año_mes) %>%
  summarize(
    ingresos_brutos = sum(total),
    .groups = "drop"
  ) %>%
  left_join(
    devoluciones %>%
      left_join(ventas %>% select(id_venta, año, mes), by = "id_venta") %>%
      mutate(año_mes = paste(año, sprintf("%02d", mes), sep = "-")) %>%
      group_by(año_mes) %>%
      summarize(reembolsos = sum(reembolso), .groups = "drop"),
    by = "año_mes"
  ) %>%
  mutate(
    reembolsos = replace_na(reembolsos, 0),
    ingresos_netos = ingresos_brutos - reembolsos,
    tasa_devolucion = round(reembolsos / ingresos_brutos * 100, 2)
  ) %>%
  arrange(año_mes)

# Visualizar tendencia
ggplot(impacto_temporal, aes(x = año_mes, y = tasa_devolucion, group = 1)) +
  geom_line(color = "red", size = 1) +
  geom_point() +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Evolución de la Tasa de Devolución",
       x = "Período", y = "Tasa de Devolución (%)")
```

## Caso de Estudio Completo (y 4)

### Paso 6: Recomendaciones Accionables

```{r}
# Crear informe ejecutivo
informe_devoluciones <- list(
  resumen = devoluciones %>%
    summarize(
      total_devoluciones = n(),
      tasa_global = round(n() / nrow(ventas) * 100, 2),
      costo_total = sum(reembolso)
    ),
  
  productos_criticos = tasa_devolucion_producto %>%
    filter(tasa_devolucion > 10) %>%
    head(10),
  
  tiendas_problema = comparacion_tiendas %>%
    filter(tasa_devolucion > 7) %>%
    head(5),
  
  categorias_riesgo = devoluciones_categoria %>%
    head(3)
)

# Mostrar informe
informe_devoluciones
```

**Recomendaciones:**

1. **Productos:** Revisar calidad de productos con tasa >10%
2. **Tiendas:** Capacitación en tiendas con alta tasa de devolución
3. **Categorías:** Mejorar descripción de productos en categorías problemáticas
4. **Procesos:** Implementar mejor política de cambios para "Talla incorrecta"

## Buenas Prácticas y Errores Comunes


## Errores Comunes y Soluciones (y 3)

**Error 3: No verificar claves duplicadas en joins**

```{r}
# PROBLEMA: claves duplicadas pueden multiplicar filas
df1 <- tibble(id = c(1, 1, 2), valor = c("A", "B", "C"))
df2 <- tibble(id = c(1, 2), info = c("X", "Y"))

resultado <- left_join(df1, df2, by = "id")
nrow(resultado)  # Esperamos 3, tenemos 3 (pero revisar lógica)

# VERIFICAR antes de hacer join
df1 %>% count(id) %>% filter(n > 1)  # ids duplicados
df2 %>% count(id) %>% filter(n > 1)  # ids duplicados

# SOLUCIÓN: decidir qué hacer con duplicados
df1_unico <- df1 %>% distinct(id, .keep_all = TRUE)
```

**Error 4: Orden de operaciones incorrecto**

```{r}
# PROBLEMA: filtrar después de summarize
ventas %>%
  group_by(id_tienda) %>%
  summarize(total = sum(total)) %>%
  filter(cantidad > 3)  # ERROR: cantidad ya no existe

# SOLUCIÓN: filtrar antes de summarize
ventas %>%
  filter(cantidad > 3) %>%
  group_by(id_tienda) %>%
  summarize(total = sum(total))
```

## Optimización

```{r}
# USO EFICIENTE: filtrar primero, luego unir
ventas_2023 <- ventas %>%
  filter(año == 2023) %>%  # reduce tamaño
  left_join(productos, by = "id_producto")

# USO INEFICIENTE: unir todo, luego filtrar
ventas_2023_lento <- ventas %>%
  left_join(productos, by = "id_producto") %>%
  filter(año == 2023)

# SELECCIONAR SOLO COLUMNAS NECESARIAS
productos_minimo <- productos %>%
  select(id_producto, nombre_producto, precio)

ventas_join <- ventas %>%
  left_join(productos_minimo, by = "id_producto")
```

## Gráficos de Análisis Exploratorio

```{r}
# Distribución de ventas
ggplot(ventas, aes(x = total)) +
  geom_histogram(bins = 50, fill = "steelblue", alpha = 0.7) +
  labs(title = "Distribución de Ventas",
       x = "Importe Total (€)", y = "Frecuencia") +
  theme_minimal()

# Ventas por día de la semana
ventas_dia <- ventas %>%
  group_by(dia_semana) %>%
  summarize(
    num_ventas = n(),
    ingresos = sum(total),
    ticket_promedio = mean(total)
  )

ggplot(ventas_dia, aes(x = dia_semana, y = ingresos)) +
  geom_col(fill = "coral") +
  labs(title = "Ingresos por Día de la Semana",
       x = "Día", y = "Ingresos (€)") +
  theme_minimal()

# Evolución temporal
ventas_mensual <- ventas %>%
  group_by(año, mes) %>%
  summarize(ingresos = sum(total), .groups = "drop") %>%
  mutate(periodo = paste(año, sprintf("%02d", mes), sep = "-"))

ggplot(ventas_mensual, aes(x = periodo, y = ingresos, group = 1)) +
  geom_line(color = "darkgreen", size = 1) +
  geom_point() +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Evolución de Ingresos Mensuales",
       x = "Período", y = "Ingresos (€)")
```

## Comparaciones y Rankings

```{r}
# Top 10 tiendas por ingresos
top_tiendas <- ventas %>%
  left_join(tiendas %>% select(id_tienda, nombre_tienda), by = "id_tienda") %>%
  group_by(nombre_tienda) %>%
  summarize(ingresos = sum(total), .groups = "drop") %>%
  arrange(desc(ingresos)) %>%
  head(10)

ggplot(top_tiendas, aes(x = reorder(nombre_tienda, ingresos), y = ingresos)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(title = "Top 10 Tiendas por Ingresos",
       x = "Tienda", y = "Ingresos (€)") +
  theme_minimal()

# Comparación entre regiones
ventas_region <- ventas %>%
  left_join(tiendas %>% select(id_tienda, region), by = "id_tienda") %>%
  group_by(region, año) %>%
  summarize(ingresos = sum(total), .groups = "drop")

ggplot(ventas_region, aes(x = factor(año), y = ingresos, fill = region)) +
  geom_col(position = "dodge") +
  labs(title = "Ingresos por Región y Año",
       x = "Año", y = "Ingresos (€)", fill = "Región") +
  theme_minimal()
```



## Principios Clave

- Datos Ordenados

- Código Legible:

  - Usar pipe `%>%` para encadenar operaciones
  
  - Un paso por línea
  
  - Nombres descriptivos de variables
  
  - Comentarios para lógica compleja

- Eficiencia:

  - Filtrar temprano, unir tarde
  
  - Seleccionar solo columnas necesarias
  
  - Verificar claves antes de joins
  
-   Inspeccionar resultados intermedios

- Reproducibilidad:

  - Scripts ordenados y comentados
  
  - Guardar datos procesados
  
  - Documentar decisiones de limpieza


:::: {.notes}
**Recursos Adicionales**

- **Documentación:** `?dplyr`, `?tidyr`
- **Cheat Sheets:** RStudio > Help > Cheatsheets
- **Libros:** 
  - "R for Data Science" (Wickham & Grolemund)
  - "Advanced R" (Wickham)
- **Comunidad:** Stack Overflow, RStudio Community

::::

## Ejercicios de Práctica

### Ejercicio 1: Análisis de Categorías

Usando los datos de RetailCorp:

1. Identifica las 3 categorías con mayores ingresos en 2023
2. Calcula la tasa de crecimiento año sobre año para cada categoría
3. Determina qué categorías tienen los tickets promedio más altos
4. Crea un gráfico comparativo

### Ejercicio 2: Segmentación de Clientes

1. Clasifica clientes según su valor total de compras (Bajo/Medio/Alto/Premium)
2. Calcula la recencia (días desde última compra)
3. Identifica clientes en riesgo (no han comprado en >90 días)
4. Propón estrategia de retención

### Ejercicio 3: Análisis de Empleados

1. Calcula el promedio de ventas por empleado
2. Identifica empleados top performers
3. Analiza si hay diferencias por puesto
4. Sugiere un sistema de bonificaciones

### Ejercicio 4: Optimización de Inventario

1. Lista productos con baja rotación (pocas ventas)
2. Identifica productos descontinuados
3. Calcula el stock óptimo por tienda (simulado)
4. Recomienda productos a eliminar del catálogo

