---
title    :  "Tema 0: Introducción a R y RStudio (Posit)"

author:  
    - "Pedro Albarrán"
#    - "Teresa Molina"
 
institute: 
     - "Dpto. de Fundamentos del Análisis Económico. Universidad de Alicante"
#     - "Dpto. de Fundamentos del Análisis Económico. Universidad de Alicante"

format:
  revealjs:
    logo: figure/by-nc-sa2.png
    titlegraphic: figure/by-nc-sa.png
    theme:  
        - beige # sky # serif # simple # default # moon #  
        - custom.scss
    smaller: true
    scrollable: true
    embed-resources: true
    slide-number: true
    show-slide-number: all
    transition: slide # concave # 
    background-transition: fade
    progress: true
    height: 800
    width: 1200
    # width: 3000
    # height: 2000
    # margin: 0.05
  beamer:
    handout: false
    logo: figure/by-nc-sa2.png
    titlegraphic: figure/by-nc-sa.png
    theme:  Boadilla # Copenhagen # CambridgeUS #
    outertheme: miniframes
    colortheme: crane
    section-titles: false
    fontsize: 10pt
    header-includes: |
        \setbeamertemplate{footline}
        {
        \leavevmode%
        \hbox{%
        \begin{beamercolorbox}[wd=.30\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
        \usebeamerfont{author in head/foot}\insertshortauthor%
        \end{beamercolorbox}%
        \begin{beamercolorbox}[wd=.55\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
        \usebeamerfont{title in head/foot}\insertshorttitle%
        \end{beamercolorbox}%
        \begin{beamercolorbox}[wd=.15\paperwidth,ht=2.25ex,dp=1ex,center]{date in head/foot}%
        \usebeamerfont{date in head/foot}\insertframenumber{} / \inserttotalframenumber
        \end{beamercolorbox}}%
        }
       # - \setbeamertemplate{navigation symbols}{}
       # - \setbeamertemplate{caption}[numbered]
       # - \setbeamertemplate{headline}[page number]
       # - \setbeameroption{show notes}
       # - \setbeameroption{show notes on second screen}
execute:
  enabled: true      # execute code chunks
  eval: false        # by default, don't evaluate code chunks
  echo: true         # show code
  warning: false     # don't show warnings (redundant to eval: false)
  message: false     # don't show messages (idem)
  output: false      # don't show output (idem)
  fig.show: hide     # don't show figures (idem)
lang: es
strip-comments: true
toc: true
toc-depth: 1
toc-expand: false
toc-title: "Contenidos"
css: styles.css
---

```{r}
#| label: setup
#| include: false
# se evalua pero no incluye output (mensajes, etc.)

# Elimino todo del Entorno (del documento)
rm(list = ls())

# Working directory
#setwd("/home/albarran/Dropbox/MAD/00.TEC")

# Cargo todas las bibliotecas necesarias
# (se podría hacer cuando cada una sea necesaria)
```

# Conceptos básicos

## Introducción

-   Debéis tener instalados los programas gratuitos
    [R](https://cran.r-project.org/) y
    [RStudio](https://posit.co/download/rstudio-desktop/)

-   Nos familiarizaremos con los conceptos y comandos básicos de programación en R

-   R es un lenguaje interpretado: ejecuta las instrucciones directamente en la consola

<!--    -   La consola es la forma más "primitiva" de interactuar con R -->

-   RStudio es un entorno de desarrollo integrado (IDE) que combina varias herramientas para facilitar el uso de R: consola, **editor** para escribir comandos, ayuda, etc.

<!--
    -   consola de R,
    -   un **editor** para escribir un archivo con comandos,
    -   ayuda,
    -   varias herramientas (como autocompletado, resaltado de sintaxis, etc.)
-->

::: {.notes}

+ Un editor de texto NO es un procesador de texto (como Word): solo importa el texto sin formato (negrita, etc.)

:::

## R Studio

![](figure/RStudioGUIes.png){width="95%"}


## Empezando con R 

-   Escribimos *comandos* en la **consola**  y se ejecutan pulsando `Enter`:

    + La tecla de tabulador ![](figure/tab.png){width="8%" .center} ofrece opciones de autocompletado

    + Ejecutar algo que no es un **comando de R** devuelve un error

```{r}
2 + 2
3 * (1 - 4)^2
sqrt(log(5/2))
pi
hola
```

::: {.notes}
-   Operadores aritméticos habituales: `+,-,*,/, %/%, %%`

-   Funciones o constantes incorporadas: `log, sqrt, abs, exp, round, pi`

```{r}
#| echo: false
abs(-5)
9 %/% 4
9 %% 4
```

`abs(-5)`

`9 %/% 4`

`9 %% 4`


* Si intentamos evaluar algo que NO es un comando de R o no está correctamente escrito, tendremos un ERROR

* Es **NORMAL** cometer errores

:::


- O en el **Editor de RStudio** y se envían a la consola la o las líneas seleccionadas para ser evaluadas con el icono ![](figure/run.png){width="10%" .center} o con el atajo de teclado `Ctrl+Enter`

- NOTA: en MacOS, usad la tecla `Command` en lugar de `Ctrl`

## Archivos de guion ("scripts") 

-  Es preferible incluir varios comandos en un archivo de texto para ejecutarlos 

-  Se puede replicar el proceso <!--completo--> de cálculos paso a paso (no como Excel) <!--y ejecutar todo o solo parte -->

-   Creamos un nuevo archivo con el icono ![](figure/Mas.jpg){width="5%" .center} o en el menú *File \> New File \> R script* (atajo `Ctrl + Mays + N`)

-   Guardamos el archivo con ![](figure/guardar.png){width="5%" .center} o en *File \> Save* (atajo `Ctrl + S`), eligiendo un directorio y nombre de extensión ".R" (por defecto) o ".r"

* En un archivo de guion (guardado), RStudio marca las líneas con error y muestra el mensaje de error al pasar el puntero

:::: {.columns}

::: {.column width="20%"}


:::

::: {.column width="80%"}
![](figure/Error.jpg){width="60%"}
:::

::::


## Trabajar con ficheros de guion 

-   Cada comando es "una" línea  y se ejecutan secuencialmente

-   Un comando se puede extender visualmente más de una línea hasta completarse: p.e., hasta cerrar los paréntesis.

    + Escribimos `log(`, en otra línea `9` y ejecutamos: la consola cambia de `>` a `+`  <!--(indicando que no ha cambiado de línea)-->

    + No hace "nada" <!--(ni resultado ni error)--> esperando que completemos el comando.

::: {.notes}

* NO LO VEREMOS: se pueden incluir más de un comando por línea, separados por "`;`", pero el código es menos legible

* Podemos ejecutar **todo el archivo**:

    + seleccionando todas las líneas `Ctrl + A` y luego ![](figure/run.png){width="10%"} 
    
    <!--(`Ctrl+Enter`)-->

    + usando ![](figure/source.jpg){width="14%"} con "echo" o sin "echo" (no muestra resultados en consola)

* En ambos casos, se para la ejecución cuando encuentra error

    <!-- antes `Run` ejecutaba linea a linea y seguía tras error -->

:::


-   El carácter `#` marca el inicio de un **comentario**: lo que sigue se "ignora" (no se ejecuta) en R


```{r}
# Pueden ir al principio de la línea 
2 + 2 # o después de una instrucción
```

- Comentar es un buen hábito: ayuda a entender/recordar qué hacemos 
    
- Notad que RStudio tiene *resaltado de sintaxis*: distinto color para comentarios, números, funciones, etc.


## Directorio de Trabajo. Proyectos. 

-   Conviene **organizar los archivos** relacionados con un mismo tema en una estructura de (sub)directorios <!--y subdirectorios--> a partir de un **directorio de trabajo** principal <!--, que se puede fijar "manualmente"  con `setwd()` -->

<!--
-  Esto puede hacerse manualmente, pero RStudio permite definir **proyectos** para gestionarlo fácilmente a través del menú *File* o desplegando el icono en la parte superior derecha ![](figure/Project.png){width="15%" .center} 
-->

-  RStudio permite definir **proyectos** para gestionarlo fácilmente a través del menú *File* o desplegando el icono en la parte superior derecha ![](figure/Project.png){width="15%" .center}

<!--
* Organizar los directorio y archivos es habitual: ej., directorios diferentes para asignaturas, subdirectorios por temas, etc.


-   Cada "proyecto" tiene un **directorio de trabajo**, con subdirectorios para cada tipo de archivo: código, datos, resultados, etc.
-->

    
    
::: {.notes}

<!--
-   ¿Cómo trabajar con directorios y ficheros en R con comandos dado que no podemos navegar visualmente con un explorador de archivos?
-->

<!--

añadir qué un path visualmente como en 
https://qmd4sci.njtierney.com/workflow.html

y ver que las cosas que pongan se llegan por el navegador

-->


-   Para conocer el directorio de trabajo actual

```{r}
getwd()
```

- Inicialmente el directorio de trabajo es el directorio por defecto del usuario del SO ("\~"), donde "`/`" es el separador de directorios

    + en Windows: `C:/Users/nombre/Documents`
    + en MacOS: `/Users/nombre`
    + en Linux: `/home/nombre`

<!--
* Directorio actual en la Terminal: `pwd` (MacOS y Linux) o `cd` (Windows)
-->

* Windows usa la barra invertida "\\" ('backward slash' en lugar de 'forward slash') como **separador de directorio** en una ruta

<!--
    + (lo podemos ver si copiamos una ruta desde el Explorador de Archivos al Bloc de Notas)

    + (aunque también admite la barra "/" en la Terminal)
-->    

* PERO "\\" tiene una función "especial" para cadenas de caracteres en programación: denotar caracteres especiales ("escapar") 

<!--, especialmente en expresiones regulares.-->


* Si "insistimos" en usarla, será su versión "escapada": (`C:\\Usuarios\\nombre\\Mis Documentos`)

* En el explorador de archivos (de Windows y de MacOS) la ruta "\~"  está en castellano (p.e., `C:\Usuarios\nombre\Documentos`), pero internamente en inglés


:::

-  Desde el menú *File > New Proyect* o desde el icono, creamos un nuevo proyecto:

    + Podemos usar un *Nuevo Directorio* o elegir una ubicación ya existente
  
    + El **nombre del proyecto será el nombre del directorio**
    
    + También se crea un archivo con el mismo nombre y extensión ".Rproj"

- Al abrir RStudio, tenemos activo el último proyecto abierto: ej., ![](figure/openProject.png){width="10%" .center}

- Tanto desde el menú como desde el icono de gestión de proyectos, podemos 

    + cerrar el proyecto actual, *File > Close Projects*, 
    
    + abrir otros proyectos guardados: *File > Open Project* o *File > Recent Projects*
    

 <!-- ![](figure/newProject.png){width="20%" .center} -->
 
  <!--  ![](figure/existingDir.png){width="20%" .center} -->


<!--
## Directorio de Trabajo (cont.)

-   Cuando proporcionamos un nombre de fichero a R, podemos incluir

    + la ruta completa: `/Users/nombre/proyecto/datos/ola1.rdata`

    + la ruta relativa al directorio de trabajo: `proyecto/datos/ola1.rdata`

::: {.notes}

* La ruta completa en MacOS (por ejemplo) también sería  `~/miproyecto/datos/ola1.rdata`

* En el menú *Tools \> Global Options*, aparece inicialmente "\~"

:::

-   Establecemos un directorio de trabajo propio de cada proyecto para acceder fácilmente mediante rutas relativas a los archivos

-   Para establecerlo una vez (en la sesión actual, en este momento)

    ```{r eval=FALSE}
    setwd("C:/Users/usuario/Documents/miproyecto")
    ```

-   Se puede establecer de forma permanente (por defecto, para cada nueva sesión de RStudio) en el menú *Tools \> Global Options*: General

-->

## Proyectos (cont.) 

<!--
- Cuando cerramos y volvemos a abrir RStudio, tendremos activo el último proyecto abierto: ej., ![](figure/openProject.png){width="10%" .center}

- Tanto desde el menú como desde el icono de gestión de proyectos, podemos 

    + cerrar el proyecto actual, *File > Close Projects*, 
    
    + abrir otros proyectos guardados: *File > Open Project* o *File > Recent Projects*
-->

* Para trabajar <!--en  R--> con un archivo, usamos la **ruta relativa** al directorio de trabajo: 

    + si están en el raíz del directorio: `codigo.R`, `misdatos.Rdata`
    
    + si están en un subdirectorio, indicamos la ruta separando directorios por `/`: `datos/ventas.Rdata`, `datos/ano2020/ingresos.Rdata`

* La **pestaña** ![](figure/Files.jpg){width="7%"} en el cuadrante inferior-derecho ofrece una forma visual de <!-- realizar operaciones de archivos: --> abrir, crear, copiar, mover o eliminar archivos o directorios, etc.

<!--
    - Navegar por directorios: p.e., *Files \> More*: *Go to Working Directory*
-->

<!--
* Nota: para navegar fuera del directorio por defecto del usuario, "\~", pulsar en los tres puntos


* RStudio facilita el trabajo permitiendo realizar "gráficamente" algunas acciones equivalentes a comandos:

    + *Files \> More*: *Set as Working Directory*

* El comando equivalente aparece en la consola: debemos **acostumbrarnos a usar comandos**
-->

* <!--Nota: aunque no suele dar problemas, --> Evitad caracteres "raros" (acentos, espacios, etc.) en directorios y ficheros

* NOTA. El Explorador de Archivos de Windows y Finder de MacOS, no muestran defecto las extensiones de los archivos.

  + Puede ser confuso para distinguir entre dos archivos con el mismo nombre y diferente extensión: `proyecto.R` y `proyecto.Rproj`
  
  + Consultad cómo mostrarlas: p.e., para  [Windows](https://support.microsoft.com/es-es/windows/extensiones-de-nombre-de-archivo-comunes-en-windows-da4a4430-8e76-89c5-59f7-1cdbbc75cb01) y [MacOS](https://support.apple.com/es-es/guide/script-editor/scpedt1025/mac)

## Funciones en R 

-   Las expresiones que aceptan **argumentos** se denominan funciones.

```{r}
exp(2)
ceiling(5.2)
```

::: {.notes}
```{r}
#| echo: false

sin(pi/6)
floor(3.1)
```
:::

-   Algunos argumentos son obligatorios, otros tienen valores por defecto que se pueden omitir

-   Los argumentos se pueden especificar por nombre o por orden.

```{r}
log(2, base=2)
log(2, 10)
log(base = 10, x = 2)

```

-   ¿Cómo sabemos la manera de usar una función (ej. argumentos necesarios) o comando de R?

::: {.notes}

-   NO omitir los argumentos tiene ventajas

    1.  Claridad

    2.  Los argumentos no tienen que especificarse en orden (sin nombre del argumento debe seguirse el orden establecido)

:::


## Ayuda en R y RStudio 

-   RStudio tiene autocompletado y ayuda flotante para funciones y otros elementos de R

    -   P.e., si empezamos a escribir la función `log`, se muestra la forma esperada de trabajar con esa función

-   RStudio también tiene una **pestaña** para buscar ayuda

<!--
-   Se puede obtener ayuda también en la consola: `help(min)` o `?min`

```{r}
#| echo: false

help(min)
?min
```

-->

-   Las búsquedas online o las IAs (como chatGPT, Gemini o Copilot) pueden ser útiles.

-   PERO debemos tener un conocimiento mínimo para aprovechar realmente una solución

    + hay muchas formas de hacer lo mismo en R: una
    respuesta correcta puede no ajustarse a lo que ya sabemos

-   NO uséis copiar-pegar **sin entender** el código:
    copiar-pensar-adaptar

::: {.notes}

* Se puede usar `??` para buscar ayuda en la consola sobre algo de lo que se desconoce el nombre concreto de la función 

```{r}
#| echo: false

??minimize
```

<!--
-   Una buena fuente de ayuda online https://stackoverflow.com/
-->

1. NO siempre estará la solución exacta a nuestro problema

2. Las soluciones pueden utilizar enfoques que requieren conocer comandos de extensiones (bibliotecas) de R

:::


## El operador de asignación 

-   El operador `<-` almacena un contenido en un *objeto* con un nombre,^[También se puede asignar con `=`] que incluye letras, números y algunos carácteres especiales ("\.", "\_")

::: {.notes}

- `alt - = <- `

-   Un objeto es simplemente algo almacenado en la *memoria* de R

-  Importante: recordar almacenar nuestros cálculos y resultados en objetos para poder reutilizarlos. 

    - a menudo no es "recomendado", es una necesidad

:::

```{r}
x <- 2*3    # asignación, no muestra resultado
x           # ejecutamos mostrar la variable   
print(x)
(x <- 2)    # asignación e impresión a la vez
```

-   R es "case-sensitive": `x` y `X` son dos objetos distintos

-   Los objetos asignados pueden usarse posteriormente, p.e., para generar otros a partir de ellos

```{r}
y <- x + 5  # asignamos y a partir del VALOR de x
(x <- x*3)  # re-asignamos x a partir de ella misma
y           # NO cambia (en Excel, sí)
```


:::  {.notes}

* Se prefiere `<-` para diferenciar asignación de objetos (NO solo asignaremos números) del **concepto** de igualdad matemática

* Y se evita la confusión con `=` usado para dar valores a un argumento, `log(2, base=10)`, y con la igualdad en comparaciones (`==`) 

* También se puede mostrar con `print(x)` o con  `show(x)`

* Un error habitual: `object not found`. Porque hemos creado `x` y luego queremos usar `X`...

* Cuando se asigna a partir del objeto `x`, en la expresión aparece el contenido `x` en ese momento (no `x` propiamente dicho)

* En Excel, si cambia un valor en una celda, cambian aquellas que la referencian.

:::



## El Espacio de Trabajo en R <!-- y RStudio --> 

-   El espacio de trabajo es el conjunto de objetos activos en memoria, resultado de todos los comandos ejecutados previamente

-   En RStudio, la pestaña ![](figure/Environment.jpg){width="15%"} muestra los objetos y su valor

-   Las funciones `ls()` y `rm()` muestran y eliminan respectivamente objetos del espacio de trabajo

::: {.notes}

```{r}

#| echo: false
ls()        # mostrar objetos
rm(y)       # eliminar el objeto "y"
rm(a,b,c)   # eliminar varios objetos (separados por comas)
```

:::

-   Borramos *todos* los objetos con ![](figure/escoba.jpg){width="5%"} en el `Environment` <!--de RStudio--> o el comando

```{r}
rm( list=ls() )  # eliminar todos los objetos
rm(y, x)         # eliminar solo algunos objetos
```

-  Guardamos el contenido del entorno de trabajo con ![](figure/guardar.png){width="5%" .center} <!--en el `Environment`--> (o al cerrar RStudio), pero es **innecesario**: ejecutando los comandos guardados en  un archivo `.R` recuperamos los objetos

::: {.notes}

- Notar que el `Environment` también tiene una pestaña de `History` con todos los comandos ejecutados durante la sesión.

- Veremos cómo guardar datos en R con más detalle

:::


## Mensajes de "Error" y "Warning"  
<!--(Aviso/Advertencia)-->

* En programación, cometer **errores** es **normal**


* En muchos errores, R se "quejará" mostrando **mensajes** en rojo 

    -   *Aviso*: R ofrece un resultado (y continuará al siguiente comando), PERO indica que puede haber algo "no deseado"

    -   *Error*: para la ejecución, *sin resultado*, e "informa" de la razón    


- Algunos mensajes son claros, pero otros requieren más investigación

```{r}
#| echo: false

log(-1)                         # warning
seq(from = 10, to = 2, by = 1)  # error
```

-   Peor que un mensaje de error: escribimos (copiamos) un código que funciona pero no hace lo que queremos...


-   El ordenador NO se equivoca: hace lo que le pedimos  según unas reglas bien definidas por R, que *debemos conocer*

    -   Sed cuidadosos<!--, sistemáticos-->, pensad y **entended** cada paso del código 
    <!-- -  P.e., la elección de nombres de los objetos: es mala idea tener un objeto con el mismo nombre que un argumento (`from`) -->
 

```{r}
#| echo: false

from <- 4
seq(from == 1, to = 5, by = 1)   # ¿por qué?
```

::: {.notes}

-   Algunos mensajes son intimidantes (en rojo!) ... e indescifrables

+ Aviso: "He hecho lo que he podido para entender lo que pides (log. de un número negativo!), pero a lo mejor no es lo que quieres"

+ Conocer las "reglas"  es saber programar (hablar) en ese lenguaje

+ Como toda  convención, algunas reglas de R pueden ser "arbitrarias" 

    + p.e., `log(-1)` podría ser error y `seq(from = 10, to = 2, by = 1)` interpretado como una cuenta atrás

- R ha ejecutado lo que le decimos, cumpliendo sus reglas: 

    - el argumento `from` se puede omitir
    - todo en R es un objeto: podemos pasar al argumento `from` un número o un objeto que contenga un número
    - pasamos un objeto lógico (`from == 1`) y lo convierte a la clase esperada, entero

- Por eso es importante la diferencia entre `<-`, `=` y `==`

:::


# Objetos en R

<!--

## Tipos de Objetos en R

-  TODO en R es un objeto, cada uno con distintas propiedades y, por tanto, distintas formas de trabajar con él

::: {.notes}

- R es un lenguaje orientado a objetos

:::

$\Longrightarrow$ **Tipos primitivos** (elementales) de objetos: (son atómicos/indivisibles)

:::: {.columns}

::: {.column width="50%"}

* 
    1. entero
    2. numérico (números reales) (double, floating point representation)
    3. lógico (valores verdadero/falso)

:::

::: {.column width="50%"}

* 
    4. caracteres
    5. fechas
    6. funciones

:::

::::


$\Longrightarrow$ **Objetos con formas** (dimensiones)


:::: {.columns}

::: {.column width="50%"}

* 
    1. escalar
    2. vectores
    3. factores
    4. matrices (2 dimensiones)

:::

::: {.column width="50%"}

* 
    5. "arrays" (n dimensiones)
    6. listas
    7. conjunto de datos (*data frame*)
:::

::::



::: {.notes}

- Realmente los factores son vectores con propiedades adicionales

- Existen otros objetos que son variantes con propiedades adicionales (o restringidas o diferentes) de otros objetos

    - Los *data frames* son realmente listas y a su vez existen variantes de listas o *data frames* para almacenar datos rectangulars: *tibbles*, *data.table*


- Las listas son colecciones irregulares de cualquier tipo de objeto y pueden anidarse

- Las listas son un tipo de objeto "comodín" o "cajón desastre" que permiten definir nuevos objetos con diferentes "propiedades" o características

:::

-->


## Tipos de Objetos en R 

-  TODO en R es un objeto, cada uno con **distintas propiedades** y, por tanto, distintas formas de trabajar con él

::: {.notes}

- R es un lenguaje orientado a objetos

:::


* Además de las funciones, los principales objetos con los que trabajaremos son:

    1. vectores
    2. factores
    3. conjuntos de datos ("data frames")
    4. listas
    
* Estos objetos pueden contener varios tipos de datos o variables:


    + entero
    + numérico (números reales) <!--(double, floating point representation) -->
    + lógico (valores verdadero/falso)
    + caracteres
<!--    
    5. fechas
    6. funciones 
-->


## Vectores

-   Un vector es una secuencia de datos elementales, creados con el operador "`c()`" (combinar)

```{r}
x <- c(2.5,-4.1,6.4,8.2)           # vector numérico
y <- c(3,0,-1,2)                   # vector de enteros
w <- c("hola", 'adios')            # vector de caracteres 
z <- c(FALSE, TRUE, T, F)          # vector lógico
```

::: {.notes}

* Los caracteres puede ir entre comillas simples \` o dobles \"

*   `T` y `F` atajo para `TRUE` y `FALSE`

:::


-   Podemos crear vectores a partir de otros vectores o usando comandos 

```{r}
z <- c(x, y)
x <- rep(1, times=4)
y <- seq(from = 10, to = 1, by = -1)
z <- 1:10       # equivale a z <- seq(1,10,1)
```

<!--
:::: {.columns}

::: {.column width="32%"}

```{r}
#| echo: false

y <- c(1,3,5,7,9)
z <- c(x, y)
```
::: 

::: {.column width="8%"}

::: 

::: {.column width="60%"}

```{r}
x <- rep(1, times=4)
y <- seq(from = 10, to = 1, by = -1)
```
::: 

::::

-   Para incrementos unitarios consecutivos se usa `:`

```{r}
#| echo: false

z <- 1:10       # equivale a z <- seq(1,10,1)
```

-->


* Un vector sólo puede contener objetos de un **único tipo** elemental, que podemos conocer en el `Environment` o con `str()`


## Vectores (cont.)


- Si se mezclan tipos distintos, R busca una clase que "acomode" a todos

```{r}
vcr <- c("lunes", 2) 
```

-   Forzamos que un objeto sea tratado con una clase concreta, con
     `as.integer()`, `as.numeric()`, `as.character()` y `as.logical()`

    -   Si no se puede convertir a número, devuelve `NA` (con un "warning")

```{r}
#| echo: false
as.integer(c(TRUE, 3.2, -1, 4))
as.numeric( c("1", "2", "foo", "10", "bar") )
```



::: {.notes}

-   "lunes" no puede ser un número pero "2" sí se puede representar como carácter

    + el carácter "2" NO es lo mismo que el número 2: no se pueden hacer operaciones matemáticas


-   Las funciones `is.numeric()`, `is.numeric()`, `is.logical()` e `is.character()` comprueban si un objeto es del tipo indicado, devolviendo un valor lógico.


-   Debemos diferenciar entre la clase de un objeto y como se muestra (formatea): ver la función `format()` 
:::

-   NO se pueden realizar operaciones incompatibles entre clases

    -   Cuidado con las comillas: NO es lo mismo un objeto (su contenido) que el carácter de su nombre

```{r}
#| echo: false

2.5+"hola"
```
    
```{r}

a <- 4
c <- 'a' + 1
```


<!-- ## Clase de un vector -->

::: {.notes}

-   La clase de un objeto es *única* (solo un tipo de <!--objetos--> elementales) y puede conocerse <!--con `class()` o--> en el `Environment` <!-- de RStudio--> o con `str()`

```{r}

str(y)
```


* con `class()`
* También se puede conocer la clase/modo con `is()` o `mode()`

```{r}
#| echo: false

is(x)
class(y)
mode(z)
```

*  `str()` sirve para cualquier tipo de objeto: p.e., funciones: `str(log)`

:::


<!--
## Clase de un vector (cont.)

-   NO se pueden realizar operaciones incompatibles entre clases

```{r}

2.5+"hola"
```
-   Cuidado con las comillas: NO es lo mismo un objeto (su contenido) que el carácter de su nombre
```{r}

a <- 4
c <- 'a' + 1
```

-   También suele pasar cuando pasamos un objeto vector (o escalar) como argumento a una función

```{r}

mibase <- 10
log(5, base="mibase")
```

-->


<!-- ## Atributos de un objecto Vector -->

-   Los vectores pueden tener *nombres* (una "etiqueta" única para cada elemento): un vector de caracteres de la misma longitud
asignado con `names()`

::: {.notes}
-   Los nombres de un vector son un vector de caracteres de la misma
    longitud

```{r}
altura <- c(176, 165, 189, 155, 168)
altura
names(altura) <- c("Jose", "Maria", "Juan", "Elena", "Rosa")
names(altura)
altura
```

```{r}
#| echo: false
altura2 <- c(186, 154, 168, 175, 158)
nombres2 <- c("Juan", "Miguel", "Susana", "Gema", "Arturo")
names(altura2) <- nombres2
altura2
```

:::

::: {.notes}

+ Obviamente podemos asignar el vector creándolo con `c()` o a partir de un vector existente

+ Notad cómo cambian las propiedades (cómo se ve el vector) tras aplicarle un nombre

:::

<!--
## Funciones para vectores

```{r}

numeric(n)      # crea un vector con n ceros

length(x)   # longitud: número de elementos
sort(x)     # ordenar
 
max(x)      # máximo
min(x)      # mínimos
sum(x)      # suma de los elementos
prod(x)     # producto de los elementos

mean(x)     # media de los ementos
var(x)      # varianza
table(x)    # tabla de frecuencias

summary(x)  # estadísticos descriptivos
```
-->

<!--
## Operaciones con Vectores de caracteres

* También podemos usar la función "paste" para crear un nuevo carácter a partir de otros
```{r}
a <- "Universidad"; b <- "de"; c <- "Alicante"
d <- paste(a,b,c)
```

* Podemos especificar que un carácter aparezca entre las cadenas con la opción `sep`; la opción por defecto en `paste` es espacio en blanco " "
```{r}
d <- paste(a,b,c,sep=".")
d <- paste(a,b,c,sep=",")
```

* La función `paste0` equivale a `paste` sin carácter de separación (`sep=""`)
--->


## Aritmética de vectores

-   La mayoría de los operadores se aplican *elemento-a-elemento*


:::: {.columns}

::: {.column width="40%"}

```{r}
a <- seq(1,3,1)
b <- seq(6,8,1)
```
:::

::: {.column width="5%"}

:::

::: {.column width="40%"}
```{r}
a+b
a*b
```
:::

::::

-   Con diferentes longitudes, se repite el vector corto cuanto
    sea necesario

:::: {.columns}

::: {.column width="45%"}

```{r}
b <- 6:9
a + b
a + 1  # lo que queremos!
```

```{r}
#| echo: false
a * 2
```
:::

::: {.column width="5%"}

:::

::: {.column width="45%"}

<!--
- Si las dimensiones no son múltiplos exactos...
```{r}
b <- 1:12  
a+b   # Warning!     
```
-->

:::

::::


* Algunas **funciones** relevantes

<p>

:::: {.columns}

::: {.column width="45%"}

```{r}
length(x)   # longitud
sort(x)     # ordenar
max(x)      # máximo
min(x)      # mínimos
sum(x)      # suma 
prod(x)     # producto 
```
:::

::: {.column width="5%"}

:::

::: {.column width="45%"}

```{r}
mean(x)     # media 
var(x)      # varianza
table(x)    # frecuencias

summary(x)  # estadísticos 
```
:::

::::

::: {.notes}

* Es MUY CONVENIENTE revisar cuidadosamente las dimensiones de los vectores antes de una operación, aunque R va a proceder de una forma bien definida...

:::

## Vectores lógicos

-   Obtenemos  un objeto lógico  enunciando una relación<!--(con operadores lógicos básicos)--> que puede ser cierta <!--(`TRUE`)--> o falsa <!--(`FALSE`)-->, como comparaciones básicas de igualdad o desigualdad

:::: {.columns}

::: {.column width="40%"}
```{r}
#| echo: false
1 == 1  # igualdad
1 != 3  # NO igual
1 > 2   # mayor que
```

```{r}
1 == 1  # TRUE
1 != 3  # TRUE
1 > 2   # FALSE
```
:::

::: {.column width="5%"}

:::

::: {.column width="45%"}
```{r}
a <- 3 
a >= 3       # TRUE
a + 1 <= 10  # FALSE
```

```{r}
#| echo: false
3 >= 2     # mayor o igual
2 + 2 < 4  # menor que
4 - 2 <= 4 # menor o igual
```
:::

:::: 

* Combinamos varios enunciados con operadores Y (`&`), O (`|`) y NO (`!`)

<!--
*  Combinamos valores lógicos con operadores booleanos 


```{r}
#| echo: false
TRUE & TRUE  # Operador AND: A & B = T si ambas T
TRUE | FALSE # Operador OR:  A | B = T si al menos una T
!TRUE        # Operador NOT: !A = T si A=F y !A=F si A=T
```
-->

-   Para conjuntos, `x %in% Y` es cierto cuando `x` es un elemento de  `Y`

<!--
- CUIDADO: los caracteres también se comparan (lexicográficamente): `'hola' > 'adios'` es cierto
-->

::: {.notes}

- Notad la doble igualdad `==` para el operador lógico de igualdad


- Nuevamente podemos confundir los objetos `hola` y `adios` con sus caracteres
```{r}
#| echo: false

'cadena' == "cadena"
'hola' > 'adios'   
```

:::

<!-- * En vectores las operaciones son elemento a elemento -->

<!--
:::: {.columns}

::: {.column width="40%"}
```{r}
altura >= c(175,165,195,165,168)
altura == 155
altura > 160 & altura <= 180
```

:::

::: {.column width="5%"}

:::

::: {.column width="40%"}
```{r}
altura < 160 | altura >= 180

condicion <- !(altura <= 170)
```
:::

::::

-->

```{r}
altura <- c(176, 165, 189, 155, 168)

altura >= c(175, 165, 195, 165, 168)  # elemento a elemento
altura == 155                         # elemento a elemento
altura > 160 & altura <= 180
altura < 160 | altura >= 180
c(165,179) %in% altura
condicion <- !(altura <= 170)
```


::: {.notes}


- R ha ejecutado lo que le decimos, cumpliendo sus reglas: 

    - el argumento `from` se puede omitir
    - todo en R es un objeto: podemos pasar al argumento `from` un número o un objeto que contenga un número
    - pasamos un objeto lógico (`from == 1`) y lo convierte a la clase esperada, entero

- Por eso es importante la diferencia entre `<-`, `=` y `==`

* aprender lógico para selección: paro de hombre,paro de hombre jovenes

* condiciones compuesta: venta media de hombres de valencia y alicante en realidad es un enunciado formal  con OR

* (recordad que esto también pasaba en gretl y en general aprender lógica)

:::



<!--

## Vectores lógicos (cont.)

-   Por supuesto, todas las operaciones lógicas en vectores son elemento a elemento

:::: {.columns}

::: {.column width="40%"}
```{r}
x <- c(3,2,1,4,3)
y <- c(5,4,1,2,3)
```
::: 

::: {.column width="10%"}

::: 

::: {.column width="40%"}
```{r}
z <- x == y
!(x==1)
w <- (y == 4 | x == 4)
c(3,9) %in% x
```
::: 

::::

* Algunas funciones para vectores lógicos
```{r}

any(z)      # ¿algún elemento de "z" es T?          = max()
all(z)      # ¿todos los elementos de "z" son T?    = prod()
which(z)    # ¿qué elementos de "z" son Verdaderos?  
which(altura == 182)
which(altura > 180 | altura < 160)
```

::: {.notes}

+ `which(altura == c(182, 150) )`

+ Otras funciones relacionadas: 

    * `match(x , 4)`, `match(x , c(3,5))`

    * `which.min()`, `which.max()`
:::
-->

<!--
## Mensajes de "Error" y "Warning" (Aviso/Advertencia)

```{r}

log(-1)                         # warning
seq(from = 10, to = 2, by = 1)  # error
```

-   Aviso: R ofrece un resultado (y continuará al siguiente comando), PERO indica que puede haber algo "no deseado"

-   Error: para la ejecución, *sin resultado*, e "informa" de la razón

-   El ordenador NO se equivoca: hace lo que le pedimos  según unas reglas bien definidas por R, que debemos conocer

```{r}
from <- 4
seq(from == 1, to = 5, by = 1)   # ¿por qué?
```

-   Debemos ser cuidadosos, sistemáticos y pensar **cada paso** del código 
    -  P.e., la elección de nombres de los objetos: es mala idea tener un objeto con el mismo nombre que un argumento (`from`)

::: {.notes}

-   Algunos mensajes son intimidantes (en rojo!) ... e indescifrables

+ Aviso: "He hecho lo que he podido para entender lo que pides (log. de un número negativo!), pero a lo mejor no es lo que quieres"

+ Conocer las "reglas"  es saber programar (hablar) en ese lenguaje

+ Como toda  convención, algunas reglas de R pueden ser "arbitrarias" 

    + p.e., `log(-1)` podría ser error y `seq(from = 10, to = 2, by = 1)` interpretado como una cuenta atrás

- R ha ejecutado lo que le decimos, cumpliendo sus reglas: 

    - el argumento `from` se puede omitir
    - todo en R es un objeto: podemos pasar al argumento `from` un número o un objeto que contenga un número
    - pasamos un objeto lógico (`from == 1`) y lo convierte a la clase esperada, entero

- Por eso es importante la diferencia entre `<-`, `=` y `==`

:::

-->

## Acceso a los elementos de un vector

-   Se utiliza el operador `[]` (paréntesis cuadrado)^[También con `[[ ]]`] y

::: {.notes}
-   Con `[[ ]]` se enfatiza acceso a un elemento: esto es importante en otros objetos (listas, datos) pero no en vectores (ambas formas son equivalentes)
:::

1. **Posiciones** de los elementos, usando un vector de enteros
```{r}
#| echo: false 
altura[3]
altura[c(1,3,5)]
altura[2:4]

pos <- 2:4
altura[pos]
```

```{r}
altura[3]
altura[c(1,3,5)]
```

-   Con enteros negativos, indicamos posiciones que NO queremos
```{r}
altura[-c(2,4)] 
```

::: {.notes}

-   importa el orden de las posiciones: `altura[c(3,1)]` frente `altura[c(1,3)]`

:::

2. **Condición** que satisfacen los elementos, usando un vector lógico
```{r}
#| echo: false
altura[altura >= 165]

pos <- (altura > 180 | altura < 160)
altura[pos]
```

```{r}
altura[altura > 180 | altura < 160]
```


3. (Si lo tienen) **Nombres** de los elementos, usando un vector de caracteres

```{r}
#| echo: false
altura[ "Juan" ]
altura[ c("Jose", "Elena") ]

pos <- c("Jose", "Rosa")
altura[pos]
```

```{r}
#| echo: false
altura[ "Juan" ]
altura[ c("Jose", "Elena") ]
```


::: {.notes}

* error por comillas se puede hablar  diferencias de altura[pos] y altura["pos"] y altura["Juan"]: confusió de comillas y diferencia entre objeto y caracter de nombre de objeto

-   La función `which()` también puede ser útil para posiciones lógicas 

```{r}
#| echo: false

which(altura == 182)
pos <- which(altura > 180 | altura < 160)
altura[pos]
```

::: 


::: {.notes}

<!-- ## Acceso a los elementos de un vector (cont.) -->

-   Los vectores de selección pueden ser un objeto previamente asignado en los tres casos; p.e.,

```{r}
pos <- (altura > 180 | altura < 160)
altura[pos]
```

-   Podemos seleccionar un subconjunto del vector para trabajar con él

```{r}
alturaExtremo <- altura[pos]
mean(alturaExtremo)
```

-   Con la asignación se pueden cambiar elementos específicos de un
    vector (o añadir nuevos)

```{r}
altura[3] <- 196

altura[c("María", "Luis")] <- c(169, 175)

```

<!--
-   O añadir nuevos elementos

```{r}
#| echo: false
altura[length(altura)+1] <- 200     # altura <- c(altura,200)
```
-->

:::

<!--

## Recordatorio: Tipos de datos

1. Información cualitativa nominal: puede tomar un conjunto *no ordenado* de valores no numéricos

    + típicamente, un número finito de *categorías* (ej., género, región, tipo de producto, etc.)


2. Información cualitativa ordinal: puede tomar un conjunto ordenado de valores, como la valoración del cliente (positiva, neutra, negativa)

3. Información cuantitativa: toma valores en un *rango numérico* como altura, peso, renta, precios, etc.

    + tiene sentido hablar de diferencias (p.e., de un euro, siempre es lo mismo) y de ratios (doble renta, doble rico)

* La información cualitativa a veces se representa con valores numéricos (arbitrarios) PERO NO tiene interpretación numérica.

::: {.notes}

* En datos cualitativos nominales, también se podría tener un número arbitrario (potencialmente infinito): ej., nombres de personas

+ En datos cualitativos, incluso cuando existe orden, no tienen sentidos las diferencias ni los ratios de los valores:

    + pasar de valoración neutra a positiva NO tiene que significar lo mismo que de negativa a neutra
    
    + tener genero=2 NO significa ser el doble de genero=1

+ En los datos cuantitativos se consideran dos sub-tipos.

1. Escala de intervalo: elementos numéricos que pueden manipularse matemáticamente parcialmente como fechas, horas y temperatura

    * Las diferencias tienen sentido: 1º C más siempre es lo mismo
    
    * Pero no los ratios (ni existe un cero absoluto): 40º no es el doble de calor que 20º (no es el doble en otras escalas ºF o ºK)

 2. Escala de razón: tanto las diferencias como los ratios tienen sentido


:::
-->

<!--
## Errores sin error

```{r}
from <- 4
seq(from == 1, to = 5, by = 1)   # ¿por qué?
```

::: {.notes}

-   Algunos mensajes son intimidantes (en rojo!) ... e indescifrables

+ Aviso: "He hecho lo que he podido para entender lo que pides (log. de un número negativo!), pero a lo mejor no es lo que quieres"

+ Conocer las "reglas"  es saber programar (hablar) en ese lenguaje

+ Como toda  convención, algunas reglas de R pueden ser "arbitrarias" 

    + p.e., `log(-1)` podría ser error y `seq(from = 10, to = 2, by = 1)` interpretado como una cuenta atrás

- R ha ejecutado lo que le decimos, cumpliendo sus reglas: 

    - el argumento `from` se puede omitir
    - todo en R es un objeto: podemos pasar al argumento `from` un número o un objeto que contenga un número
    - pasamos un objeto lógico (`from == 1`) y lo convierte a la clase esperada, entero

- Por eso es importante la diferencia entre `<-`, `=` y `==`

:::
-->

## Factores

<!-- -   Los factores son un tipo de objeto de R específico para trabajar con **información cualitativa** -->

- La **información cualitativa** se suele codificar como texto o números, pero NO tiene sentido numérico (ni de "texto"): *representan* clases o **categorías**
  
<!-- -   Los datos originales pueden estar codificados de forma poco clara para el análisis (género como número o abreviatura) -->

- Para destacar la naturaleza distinta de estos datos, existe un tipo de objeto específico en R: los **factores**

- Además de otras ventajas que veremos, permiten separar la representación original de las categorías (niveles) de cómo queremos mostrarlas (etiquetas) 

<!-- -   Se usa `factor()` para crear un vector de tipo factor,  con argumentos para los niveles y sus etiquetas -->

```{r}
genero   <- c(2, 1, 2, 2, 2)
genero_f <- factor(genero, levels = c(1, 2), 
                           labels = c("Mujer", "Hombre"))
```

* Se asocia nivel 1 con "Mujer", 2 con "Hombre", etc.

- Las operaciones con factores se realiza con las etiquetas, no con los niveles

```{r}
genero_f == 1       # NO existe valor 1
genero_f == "Mujer"
```


::: {.notes}

* Notar que el comando `factor()` se extiende en el editor en varias lineas (no es "una" línea por comando)

* En la consola, se indica que sigue siendo el mismo comando en múltiples líneas con `+` en lugar de `>`

:::


## Factores (cont.)

- También podemos usar `as.factor()` para convertir un vector <!--existente--> en un factor

- PERO es conveniente especificar los niveles y las categorías porque si no, R los asigna alfabéticamente

```{r}
g <- factor(genero)  # as.factor(genero) hace lo mismo
g
```

* En este caso la etiqueta del primer nivel encontrado en los datos (el número 2) es "1" y la del siguiente nivel (el número 1) es "2"


-   También podemos tener factores con orden con la opción `order = TRUE` y enumerando los niveles  en orden


```{r}
satisf   <- c("A", "B", "A", "B", "M")
satisf_f <- factor(satisf, order = TRUE, 
                    levels = c("B", "M", "A"),
                    labels = c("Bajo", "Medio", "Alto"))
```

::: {.notes}

* Si etiquetas y niveles coinciden, no es necesario especificarlos

```{r}
satisf   <- c("Alto", "Bajo", "Alto", "Bajo", "Medio")
satisf_f <- factor(satisf, order = TRUE,
                        levels = c("Bajo", "Medio", "Alto"))
```


:::




<!--
## Factores (cont.)


-   Podemos crear un factor con orden 

```{r}
satisf   <- c("Alto", "Bajo", "Alto", "Bajo", "Medio")
satisf_f <- factor(satisf, order = TRUE,
                        levels = c("Bajo", "Medio", "Alto"))
```

-   Si no se especifican, los niveles se asignan por orden, alfabético o numérico: puede no ser deseable

```{r}
genero   <- c(1, 2, 2, 1, 1)
genero_f <- factor(genero, labels= c("Hombre", "Mujer"))
satisf   <- c("Alto", "Bajo", "Alto", "Bajo", "Medio")
satisf_f <- factor(satisf, order = TRUE)
```

```{r}
#| echo: false

genero   <- c("H", "M", "M", "H", "H")
genero_f <- factor(genero, labels= c("Hombre", "Mujer"))
```

::: {.notes}
-   La función `levels()` permite ver y cambiar los niveles de un factor

-   Luego, el orden en que se (re)asignan los niveles es importante.

`levels(factor_genero) <- c("Femenino", "Masculino")`

:::

-   Sólo con factores ordinales tienen sentido las comparaciones

:::: {.columns}

::: {.column width="45%"}
```{r}
satisf_f[2] > satisf_f[5]
```
::: 

::: {.column width="5%"}

::: 

::: {.column width="45%"}
```{r}
genero_f[2] > genero_f[4]
```
::: 
:::: 

-->

## "Resumiendo" un vector numérico o un factor

-   La función `summary()` devuelve los principales estadísticos
    descriptivos de un vector numérico

```{r}
summary(altura)
```

::: {.notes}
* El "resultado" de `summary()` también es un objeto de R: se puede asignar y trabajar con él

`a <- summary(altura)`

`str(a)`

`a[1:2]`


::: 

-   Para información cualitativa, la media y otros estadísticos no tienen sentido

```{r}
summary(genero)
genero  <- c(1, 20, 20, 1, 1)  # dos categorías igualmente
summary(genero)
```

- La función `summary()` ofrece resultados diferentes según el tipo de objeto (porque tiene distintas propiedades)

```{r}
summary(genero_f)
```

```{r}
#| echo: false

satisf   <- c(3, 1, 1, 1, 1, 1, 1, 1, 1)
satisf_f <- factor(satisfaccion, order = TRUE,
                    labels = c("Bajo", "Medio", "Alto"),
                    levels = c(1,2,3))
summary(satisf)
summary(satisf_f)

satisfaccion <- c(3000, 1, 1, 1, 1, 1, 1, 1, 1)
factor_satisfaccion <- factor(satisfaccion, order = TRUE,
                              labels = c("Bajo", "Medio", "Alto"),
                              levels = c(1,2,3000))
summary(satisfaccion)
summary(factor_satisfaccion)
```


:::: {.notes}

**Matrices**

-   Las matrices son una extensión de vectores a dos dimensiones. 

- Se pueden crear con `matrix(), a partir de un vector con todos los valores,  rellenando por columnas (argumento `byrow = FALSE`) y conocemos su dimensión con `dim()`

```{r}
#| echo: false
matrx <- matrix(data = c(100, 60, 55, 75, 110, 85), nrow = 2)
dim(matrx)
```
 
-  Se pueden crear con `matrix()` o <!--También se crear -->uniendo vectores filas o vectores []: # nas (de las mismas dimensiones) con `cbind()` y `rbind()`
 
:::: {.columns}
 
::: {.column width="40%"}
 
 
```{r}
r1 <- 1:4
r2 <- c(4, 8, 5, 10)
M1 <- rbind(r1, r2)
```
 
::: 
 
::: {.column width="5%"}
 
:::
 
::: {.column width="45%"}
 
```{r}
c1 <- 11:12
c2 <- 25:26
c3 <- c(14, 25)
M2 <- cbind(c1, c2, c3)
```
 
:::

::::
 
- Podemos usarlos para añadir nuevas filas, columnas u otra matriz
 
```{r}
#| echo: false

M1 <- cbind(matrx, c(90,95))          
M2 <- rbind(matrx, c(40, -20, 25))    

A <- cbind(c(40,30), c(70, 75))
cbind(M1, A)

B <- cbind(c(40, 2), c(-20, 1), c(25, 1))
rbind(matrx, B)
```
 
- Si no tienen dimensiones compatibles, R repetirá (como ya vimos en aritmética de vectores)
 
 `M1 <- cbind(matrx, c(90,95))`
 
 `M2 <- rbind(matrx, c(40, -20, 25))`
 
 
 `A <- cbind(c(40,30), c(70, 75))`
 
 `cbind(M1, A)`
 
 
 `B <- cbind(c(40, 2), c(-20, 1), c(25, 1))`
 
 `rbind(matrx, B)`
 
  -   Podemos dar nombres a columnas y filas 

```{r}
colnames(M2) <- c("ene", "feb", "mar")
rownames(M2) <- c("gast", "ingr")
```
 
 
**Podemos dar nombres a columnas y filas**
 
```{r}
#| echo: false
colnames(M2) <- c("ene", "feb", "mar")
rownames(M2) <- c("gast", "ingr")
```
 
-   Notad que NO podemos usar la función `names()` vista anteriormente
     porque solo aplica a vectores
 
-  También se puede especificar los nombres al crear con matrix con argumento `dimnames`
 
 `meses <- c("ene", "feb", "mar")`
 
 `matrx <- matrix(data = c(100, 60, 55, 75, 110, 85), `
 
 `           nrow = 2,dimnames=list(c("gast", "ingr"), meses))`

 -   Usamos los paréntesis cuadrados para acceder a los elementos (o una sub-matriz) por posición,  nombre o condición lógica
 
 
```{r}
#| echo: false
M2[4]   # posición total
M2[[4]] 
```
 
 
```{r}
#| echo: false
M2[1,3]                 
M2["ingr", "ene"]      
M2[c(1:2),c(1,3)]
```
 
 
:::: {.columns}
 
::: {.column width="40%"}
 
 
```{r}
M2[1,3]                 
M2["ingr", "ene"]      
M2[c(1:2),c(1,3)]
```
 
::: 
 
::: {.column width="5%"}
 
:::
 
::: {.column width="45%"}
 
```{r}
M2[2,]      # fila entera
M2[,"feb"]  # columna entera

```
 
:::
 
::::
 
 
+ Notad que en matrices tiene más sentido el doble paréntesis cuadrado `[[ ]]` (debería preferirse  para acceder a un elemento por su posición sobre el total)
 
-   También se pueden extraer filas o columnas enteras

 
```{r}
#| echo: false
M2[2,]      # por posición
M2[,"feb"]  # por nombre
```
 
**Aritmética de Matrices**
 
-   Las operaciones habituales son elemento a elemento: la matrices deben tener las mismas []: # siones (o R repetirá elementos)
 
 
:::: {.columns}

::: {.column width="40%"}
 
```{r}
matrx + M2
matrx * M2
```
 
::: 
 
::: {.column width="5%"}
 
:::
 
::: {.column width="45%"}
 
```{r}
#| echo: false
matrx - 3
matrx * 10 
matrx / 2
```
 
 
```{r}
matrx - 3
matrx * 10 
```
 
:::
 
::::
 
 
* Como en el caso de vectores, si las dimensiones no son iguales, se repiten elementos
 
* En las operaciones con escalares , realmente se han "expandido" los escalares a una matriz de []: ensiones equivalentes (una matriz con todos los elementos iguales al escalar)
 
 
-   Se pueden hacer todo tipo [operaciones matriciales con
     R](http://www.statmethods.net/advstats/matrix.html) como multiplicación matricial, `%*%`, []: # poner, `t(M1)`, invertir, `solve(A)`, etc.
 
-   También existen funciones para matrices: `diag()`, `rowSums()`, `colMeans()`, etc.
 

**Funciones para Matrices**
 
* Para crear la matriz identidad de dimensiones $n\times n$
```{r}

#| echo: false
diag(n)     
```
 
* Para crear un matriz con los elementos del vector `vec` en la diagonal
```{r}

#| echo: false
diag(vec)   
```
 
-   Se pueden calcular sumas o medias de las filas o columnas de una
     matriz
 
```{r}
#| echo: false
rowSums(M2)
colMeans(M2)
```
 
* Notar que `mean(matrx)` calcula la media de *todos* los elementos de la matriz (como si fuera un  vector)
 
-   También, se puede operar con un subconjunto de la matriz (que puede
     ser otra matriz o un vector)
 
```{r}
#| echo: false

colSums(M2[1:2,2:3])
mean(M2[3,2:3])
```
 

**"Arrays"**
 
* Un "Array" es un vector de "n" dimensiones. Se crea con la función `array`
```{r}
x <- array(c(1:8), dim =c(2,2,2) )
x
```
 
* Se puede acceder a los elementos con paréntesis cuadrados
```{r}
x[2,1,2]
x[,,1]
```
 
* Los nombres de todas las dimensiones de un "array" (includas matrices) se manejan con la función  `dimnames`, además de al crearlos.
 
     + Es un tipo de objetos nuevos conocidos como listas.

::::


## "Data Frames"

-   Es un tipo de objetos específico para facilitar el análisis de
    datos: una colección de variables por columnas y observaciones por
    filas.


<!-- -   Se pueden crear con `data.frame()` a partir de vectores existentes, dando nombres a las variables, o de matrices -->

<!--     + A diferencia de las matrices, las columnas pueden ser de tipo diferentes     -->

- Cada columna es un vector con un **nombre** y tipos de datos (quizás) diferentes

```{r}
#| echo: false

altura <- c(177, 178, 168, 164, 186, 162, 160)
peso   <- c(75, 85, 70, 60, 80, 65, 54)
genero_f <- factor(c(1,2,2,2,1,1,2), 
                labels = c("Mujer", "Hombre"))
datos <- data.frame("Altura"=altura, "Peso"=peso, "Genero"= genero)
class(datos) 
```


```{r}
altura <- c(177, 178, 168, 164, 186, 162, 160)
peso   <- c(75, 85, 70, 60, 80, 65, 54)
genero   <- c(2, 1, 2, 2, 2, 1, 1)
genero_f <- factor(genero, levels = c(1, 2), 
                           labels = c("Mujer", "Hombre"))
datos <- data.frame("Altura"=altura, "Peso"=peso, "Genero"= genero_f)
```


:::{.notes}

* Los "data frames" son una colección (técnicamente, una lista) de vectores que corresponde a cada variable.

* Por ser listas, pueden tener columnas de tipos de diferentes, a diferencia de las matrices



:::


<!--

## "Data Frames" (cont.)

* También se pueden crear  con `as.data.frame` a partir de matrices con columnas que tengan nombre

```{r}
#| echo: false
mat <- cbind(altura, peso, genero)  
colnames(mat) <- c("Altura", "Peso", "Genero")
datos <- as.data.frame(mat)
```

::: {.notes}

* Notar que el factor "genero" se convierte a numérico porque las matrices solo pueden ser un tipo: numérico


:::
-->

-   Se visualizan con `View(datos)` o en "Enviroment" o una parte con `head()` <!--y `tail()`-->


<!--

-   Se puede visualizar con `View(datos)` o en "Enviroment" de RStudio

```{r}
#| echo: false

View(datos)
```

-   O solo una parte de los datos con `head()` y `tail()`

```{r}
#| echo: false
head(datos)       # primeras 6 observaciones
tail(datos)       # últimas 6 observaciones
tail(datos, n=3)  # últimas 3 observaciones
```
-->

<!--
## Nombres y dimensiones de objetos en R

-   Funciones para conocer las dimensiones de distintos objetos en R

```{r}


length(x) # en matrices: total de elementos
          # en listas/data.frame: número de listas/variables
dim(data.frame)  #  solo objetos de dos dimensiones: 
nrow(data.frame) #     o data.frame o matrices
ncol(data.frame) #     pero no vectores o listas
```

-   Y también los nombres

```{r}


dimnames(data.frame)   # también matrices
colnames(data.frame)   # idem
rownames(data.frame)   # idem
names(vector)        # solo para vectores
```

::: {.notes}

* Solo para data.frame existe la función `row.names(datos)`

:::

-->

<!-- ## Acceso a los elementos del "Data Frames" -->

-   Seleccionamos columnas por nombre **con `$`** o por nombre o posición <!--de la columna--> **con \[\[ \]\]**


```{r}
vectAltura <- datos$Altura    # objeto resultante = vector
datos[[2]] == datos[["Peso"]]
```


## "Data Frames" (cont.)

<!--
- Un sub-componente de un "data frame" puede ser un objeto diferente
-->


<!-- -   Seleccionamos columnas por nombre **con `$`** o por nombre o posición <!--de la columna--> <!--**con \[\[ \]\]** -->

<!--
-   Manejamos cada variable como hemos visto con vectores
-->

```{r}
#| echo: false

vectAltura <- datos$Altura    # objeto resultante = vector
datos[[2]] == datos[["Peso"]]
```

::: {.notes}

* notar 

`altura_vect[1] == datos$altura[1]`

`datos[[2]][1] == datos[["peso"]][1]`

:::


<!-- -   También se puede usar **notación de matrices**. <!--OJO: el resultado puede ser un vector o un conunto de datos--> 

```{r}
#| echo: false
datos[,1]           # 1ª columna  = vector
datos[1,c("Altura", "Genero")]   # data frame
datos[1:3,1:2]                   # data frame
```

```{r}
#| echo: false
datos[,1]           # 1ª columna  = vector
datos[2,]           # 2ª fila    = vector
datos[3,"Altura"]   # 3ª fila de variable "Altura" = escalar
datos[1,c("Altura", "Genero")]   # data frame
datos[1:3,1:2]                   # data frame
```

```{r}
#| echo: false
datos[3,2]            # 3ª fila, 2ª columna = vector (escalar)
```

<!--
## Acceso a los elementos del "Data Frames" (cont.)
-->

<!-- -   Podemos usar todos los tipos de accesos y filtros basados en condiciones de sus elementos que ya hemos visto -->

<!-- -  También seleccionamos usando filtros basados en condiciones lógicas -->

* También podemos usar `[]` para seleccionar filas y columnas por posición, nombre y/o condición lógica


```{r}
#| echo: false
d1 <- datos[datos$Altura > 165,]                    # data.frame
d2 <- datos[datos$Altura %in% c(177,178), "Altura"] # vector
d3 <- datos[datos$Genero == "Hombre", 2]         
```

```{r}
datos1 <- datos[datos$Genero == "Hombre", 1:2]  # Altura y Peso de hombres        
```


::: {.notes}

```{r}
#| echo: false

datos1 <- datos[datos$Genero == "Hombre", 1:2]  # Altura y Peso de hombres        
datos1 <- datos[datos$Genero == "Hombre", c("Altura", "Peso")] 

```

:::

<!-- -   Generar nueva variable -->

```{r}
#| echo: false
datos$Altura_m <- datos$Altura / 100
```

```{r}
#| echo: false

datos$IMC <- datos$Peso / datos$Altura_m^2
```


<!-- ## Trabajando con "Data Frames" (cont.) -->

<!-- * La función `subset()` extrae parte de los datos, basado en una condición lógica; devuelve siempre un "data frame" -->

<!-- -  La función `subset()` extrae parte de los datos, basado en una condición lógica; devuelve siempre un "data frame" -->

- Suele ser mejor usar `subset()` que devuelve siempre un "data frame"


```{r}
D1 <- subset(datos, Altura > 165)   
D2 <- subset(datos, subset = Altura %in% c(177,178),
                    select = c(Altura, Peso)) 
```

-   Generamos nuevas variables con el vector de asignación

```{r}
datos$Altura_m <- datos$Altura / 100
```


<!-- * Con las funciomes `with()` y `within()` evitamos tener que repetir el nombre de un conjunto de datos cuando realizamos operaciones con él -->

```{r}
#| echo: false
with(datos, mean(Peso / (Altura/100)^2))
within(datos,  IMC <-Peso / (Altura/100)^2 )
datos <- within(datos, {
                  peso2 <- Peso^2
                  altura2 <-Altura^2
                })
```

::: {.notes}

* También se puede usar (pero NO recomendable) `attach()`: carga un objeto en el "Global Environment" y no es necesario poner su nombre para acceder a las variables con `$`

```{r}
#| echo: false

search()           # (ver también en RStudio)
head(age)          # no se encuentra
head(Affairs$age)
attach(Affairs)
search()
head(age)
```

* Útil con solo un conjunto de datos o si no hay lugar de confusión (no hay el mismo nombre de variable en diferentes conjuntos de datos)

* Se deja de vincular con `detach()`

```{r}
#| echo: false

detach(Affairs)
```

<!--
* Para generar varias variables, tambien `transform()` y, de la biblioteca `Hmisc`, la función `upData()` (que permite incluir metadata como unidades y etiquetas)
-->


* Para ordenar un conjunto de datos por una variable, `order()` crea un vector de posiciones de orden

```{r}
#| echo: false

pos <- order(datos$Altura)
datos[pos,]
```

:::

<!-- * En general, no generaremos nuestros conjuntos de datos sino que los incorporaremos como objetos a R de varias formas. -->


<!-- * En general, incorporaremos los datos como objetos a R de varias formas.  -->

* Se pueden añadir filas y columnas a un *data frame* con `rbind()` y `cbind()`, respectivamente, a partir de vectores u otros *data frames*

## Listas

<!-- -   Una lista es una colección <!--genérica--> <!--de objetos de distinto tipo. Es *similar* a un vectores, pero los objetos pueden ser de distintos tipos -->

-   Una lista es una colección <!--genérica--> de objetos de distinto tipo (a diferencia de un vector)

<!--
```{r}
#| echo: false
x <- 1:30
miLista <- list("hola", x, list(1:4, "X"))
miLista
```

-   La función `str` también se puede usar para listas

```{r}
str(miLista)
```

-->

::: {.notes}
-   Veremos que muchos objetos de R son listas

-   También vemos las propiedades del objeto en el `Environment`
:::

<!-- -   Podemos añadir nombres a los elementos de una lista o dáreselos al generarla: -->

```{r}
#| echo: false
miLista <- list("hola", x, list(1:4, "X"))
names(miLista) <- c("saludo", "vec", "lista")
miLista <- list(saludo="hola", vec=x, lista=list(1:4, "X"))
```

* Los elementos de una lista suelen tener nombres

```{r}
miLista <- list(saludo="hola", vec=x, lista=list(1:4, "X"), 
                datos=datos)
```


<!-- ## Listas (cont.) -->

<!-- -   Con `[]` extraemos elementos por posición o por nombre, como listas -->

<!-- ```{r} -->
<!--  -->
<!-- class(miLista["vec"]) -->
<!-- miLista[2] + 2     # operación incompatible entre clases -->
<!-- ``` -->

-   Con `[[ ]]` (por posición o por nombre) o con `$`(solo por nombre) extraemos los elementos en su clase original


```{r}
miLista$vec
miLista[[2]] + 3
```


<!-- :::: {.columns} -->

<!-- ::: {.column width="40%"} -->

<!-- ```{r} -->
<!-- class(miLista$"vec") -->
<!-- ``` -->

<!-- ::: -->

<!-- ::: {.column width="10%"} -->


<!-- ::: -->

<!-- ::: {.column width="40%"} -->
<!-- ```{r} -->
<!-- class(miLista[[2]]) -->
<!-- miLista[["vec"]] + 2 -->
<!-- ``` -->
<!-- ::: -->

<!-- :::: -->

* También podemos usar `[]`, pero devuelve una lista

:::{.notes}

* Nota: el uso de `[ ]` y `[[ ]]` también se aplica a "data frames"

* Es importante entender el tipo de objeto de obtenemos con una forma de acceso u otra, por las operaciones que podemos realizar y por las transformaciones que se permiten

-   P.e., podemos acceder a elementos individuales de la (sub-)lista con `[[ ]]`, pero no con `[ ]`:

```{r}
#| echo: false

miLista[[2]][2]

miLista[2][2]   # lista de longitud 1
```

`miLista[[2]][2]`

`miLista[2][2]   # lista de longitud 1`


:::

-    `unlist()` convierte una lista en vector, usando la clase que pueda ajustarse a todos los objetos (elementales) <!-- típicamente, caracteres -->





# Extendiendo R

## Bibliotecas ("libraries")

-   Una biblioteca contiene nuevos objetos de R: funciones, datos, etc.

-   Para instalar una nueva biblioteca (se hace **una vez**), en <!-- el menú --> *Tools \> Install packages* o en <!--la pestaña --> ![](figure/Packages.jpg){width="12%"} o con el comando <!-- `install.packages()`-->


```{r}
install.packages("AER")
```

- Mantenemos actualizados los paquetes, en el menú *Tools* o en ![](figure/Packages.jpg){width="9%"}

-   La biblioteca solo está disponible si se carga en la *sesión actual* 

```{r}
library(AER)
```

- Nota: en adelante, la bibliotecas que carguemos se suponen instaladas

- En ![](figure/Packages.jpg){width="12%"} vemos las bibliotecas instaladas y las cargadas aparecen marcadas ![](figure/librerias.jpg){width="10%"}


::: {.notes}

* R puede extenderse con capacidades adicionales instalando paquetes con bibliotecas

* Se instala UNA VEZ, se carga en cada sesión que se usa

* Podemos ver las bibliotecas cargadas en ![Global Environment](figure/GlobalEnvironment.jpg){width="20%"}

    + mirarlo antes y después de `library(AER)`
    + o por línea de comandos
    
```{r}
#| echo: false

search()
library(AER)
search()
```

-   La ayuda contiene información sobre las funciones de una biblioteca, incluyendo ejemplos de uso ("vignettes") en algunos casos

```{r}
#| echo: false
library(help=utils)      # Ayuda para una biblioteca concreta
```

`library(help=utils)`

+ Podemos descargar una biblioteca de memoria con `detach()`

+ La función `require()` es "similar" a `library()`

:::

## Bibliotecas (cont.)


-   El nombre completo de un objeto es `biblioteca::nombre`
  
    + La nombre de la biblioteca solo es necesaria si no se ha cargado o dos objetos diferentes tienen el mismo nombre en bibliotecas distintas

:::: {.columns}

::: {.column width="40%"}
```{r}
base::log(1)
log(1)
```

:::

::: {.column width="20%"}


:::

::: {.column width="40%"}
```{r}
library(Hmisc)
find("units")
```


:::

::::


::: {.notes}

* En la Ayuda, vemos la biblioteca a la que pertenece una función (entre llaves)

* El nombre completo es necesario si hay  conflicto entre bibliotecas: contienen objetos con el mismo nombre


```{r}
#| echo: false
find("units")
library(Hmisc)
find("units")
```

* También se usa nombre completo si no se ha cargado la biblioteca

:::


-   Para mostrar todos los datos de las bibliotecas cargadas

```{r}
data()
```

-  Los podemos cargar en el "Environment" y obtener información detallada en la ayuda (ej., nombre de variables)

```{r}
data("Affairs")
help("Affairs")
```


## Datos "nativos" en R

-   Guardamos objetos del espacio de trabajo con `save()` (en una ruta relativa al directorio de trabajo)

```{r}
x <- 1:20
y <- 2 * x ^ 2 + 1
save(x, file="x.RData")      # un objeto, o varios
save(x, y, file="data/xy.RData")  #   separados por comas
```

::: {.notes}

-   Extensiones .RData, .rda, .rds, ...

-   O todo el workspace con `save.image()` (= icono
    ![Guardar](figure/guardar.png){width="7%" .center})
:::

-   Para cargar datos al espacio de trabajo, con `load()` (= icono
    ![Cargar_Load](figure/Cargar.jpg){width="7%"})

```{r}
#| echo: false
rm( list=ls() )
```

```{r}
load("data/xy.RData")
```

-   En la pestaña de ![](figure/Files.jpg){width="8%"}: doble-clic carga un archivo de datos

-  Nota: este tipo de archivo puede contener varios objetos, incluidas varios conjuntos de datos

::: {.notes}

+ Es posible cargar directamente desde internet:

`load(url("https://github.com/albarran/BigDataEcon/raw/main/data/altura.RData"))`

- También se eliminan archivos con la función  `unlink()`

```{r}
#| echo: false
unlink("xy.RData")
```
:::


## Datos en otros formatos externos a R

-   Varias bibliotecas permiten trabajar con distintos <!--tipos de archivos--> formatos de datos, p.e.:

    1. Texto, con delimitadores o de ancho fijo: `utils` (R base), `readr`
    2. Hojas de cálculo: `readxl`, `openxlsx` <!-- `gdata` (solo .xls), `XLConnect` (lectura y escritura, pero requiere Java)-->
    3. Formatos de software estadístico: `haven`, `foreign`
    
    <!--4. Google Sheets, bases de datos SQL, etc.-->

::: {.notes}

+ Dos bibliotecas a veces ofrecen comandos distintos que hacen lo mismo

+ Pero tienen distintas opciones y sus opciones por defecto son diferentes (p.e., cómo tratan los caracteres: ¿se convierten a factores?)

:::

-   Descargad estos ejemplos (UA cloud): [renta.txt](https://raw.githubusercontent.com/albarran/00datos/main/renta.txt), [sex_data.csv](https://raw.githubusercontent.com/albarran/00datos/main/sex_data.csv), [beauty.xls](https://raw.githubusercontent.com/albarran/00datos/main/beauty.xls), [nsw.dta](https://raw.githubusercontent.com/albarran/00datos/main/nsw.dta)

- En ![Import Dataset](figure/Import.jpg){width="15%"} de RStudio, tenemos acceso visual para cargar algunos formatos (con la biblioteca necesaria instalada)

- `rio` es un meta-paquete (instala otras bibliotecas) para importar y exportar varios formatos de datos de forma sencilla

    + A partir de la extensión del archivo, detecta  el formato y, por tanto, la biblioteca necesaria

<!--
## Comentarios sobre los datos en el disco duro

-   Recordad haber fijado un directorio de trabajo y decidid donde tener vuestros datos

    - En estas transparencias asumo que en un sub-directorio llamado "data

-   Descargad los datos de la web
    ([aquí](https://github.com/albarran/BigDataEcon/raw/main/data.zip)) y descomprimidlos en ese lugar

-   Todos las direcciones son *relativas* al directorio de trabajo para no  escribir la dirección completa `"C:/Users/usuario/Documents/curso/data/misdatos.RData"`: solo `data/misdatos.RData`
-->

<!--
## Archivos de texto simple

-  Los archivos de texto son una forma sencilla de almacenar datos e intercambiarlos entre programas (y usuarios)

    -   Las extensiones habituales son `.txt`, `.csv`, `.raw`

    -   La primera línea puede contener el nombre de las variables
    
    -   En el resto del archivo, están los datos: una línea por caso

    -   Las variables de caracteres, con valores entre comillas

    -  Las columnas (variables) están separadas por un delimitador (ej., coma, espacio,...)  (espacio, tabulador, coma, punto y coma)  
    o tienen un ancho fijo 
    

-   Se pueden leer en un editor, por ejemplo, el de RStudio: en ![Files](figure/Files.jpg){width="8%"} encontrar, p.e., `sex_data.csv`, hacer clic y elegir *View File* <!--![View File](figure/ViewFile.jpg){width="15%"}
-->

<!--
## Archivos de texto (cont.)

-   `read.table()` de `utils` carga el contenido de un archivo de texto en una *data frame*

```{r}
datos <- read.table("data/sex_data.csv", header=T, sep =",")
```

-   Con argumentos opcionales, controlamos (entre otras cosas) si el nombre de variables en la primera línea, el tipo de separador o si tenemos coma en lugar de punto decimal (`dec=","`)

::: {.notes}

-   Se puede especificar nombres de columnas (si no están en la primera fila), saltar filas, cuántas filas leer, etc.

```{r}
#| echo: false
sexdata <- read.table("data/sex_data.csv",
                      header=F, sep=",",
                      col.names = c("valor", "fecha", "otra", as.character(4:25)),
                      colClasses = c(rep("character",25)))
```

```{r}
#| echo: false
sexdata <- read.table("data/sex_data.csv", 
                      header=F, sep=",",   
                      col.names = c("valor", "fecha", "otra", as.character(4:25)), 
                      colClasses = c(rep("character",25))) 
```


:::

-   Otros comandos de `utils` importan datos de texto, con distintos argumentos por defecto: `read.csv()`, `read.delim()`, ...

-  En el formato de ancho fijo (`renta.txt`), cada variable ocupa un número fijo de columnas que debemos especificar 
en el comando `read.fwf()`


```{r}
x <- read.fwf(file="data/renta.txt", widths=c(3, 7, 10, 9))
```


## Archivos de texto (y 3)

-   La biblioteca `readr` tiene comandos similares (`read_table()`, `read_csv()`, `read_fwf()`, ...) con distintos argumentos, etc.


```{r}
library(readr)
datos <- read_csv(file = "data/sex_data.csv")
```

::: {.notes}


-   Funciones: `read_csv2()` (";" como separador), `read_tsv()`, `read_delim()`

-   Ayuda adicional en la "viñeta"
    ([vignette](https://cran.r-project.org/web/packages/readr/vignettes/readr.html))  de `readr`

-   Las funciones de `readr` devuelven un "tibble" (un tipo de *data frame* con propiedades diferentes)

```{r}
#| echo: false
nombres <- c("area", "temperatura", "tamaño", "almacenaje", "método",
                "textura", "sabor", "humedad")
arch <- "data/potatoes.csv"
patatas <- read_csv(arch, col_names = nombres, skip = 1,  n_max = 15)
```

```{r}
#| echo: false
arch <- file.path("data", "sex_data.csv")
```

-   También se puede especificar el tipo de datos de cada columna (ver Ayuda)

```{r}
#| echo: false
perritos <- read_delim("data/hotdogs.txt", delim = "\t",
                           col_names = c("tipo", "calorias", "sodio"),
                           col_types = "fii")
```
-->

<!--
ver ayuda: para tipo columnas también

fac <- col_factor(levels = c("Beef", "Meat", "Poultry"))
int <- col_integer()

list(fac, int, int)
-->

<!--
```{r}
#| echo: false
x <- read_fwf(file="data/renta.txt", skip = 1, 
              fwf_cols(edad = 3, genero = 7, renta = 10, educacion = 9 )
              )
```

:::

-   La Ayuda nos muestra los argumentos y sus valores por defecto para ambas bibliotecas

-   En ![Import dataset](figure/ImportDataset.jpg){width="20%"}, podemos importar con ambas bibliotecas de forma visual

-   Se puede guardar un conjunto de datos como un archivo de datos de texto con los comandos `write.table()`, `write.csv()`, ... o `write_delim()`, `write_csv()`, etc.

::: {.notes}

-   Múltiples opciones: empezar a escribir `write` en la Ayuda

sink(file= , split=TRUE)

:::
-->

<!--
## Formato de hoja de cálculo

-   La biblioteca `readxl` trabaja con .xls y .xlsx; se usa para importar visualmente en ![](figure/ImportDataset.jpg){width="20%"}

-   Incluye funciones tanto para leer el archivo como para conocer información sobre él (ej., nombres de las hojas) y leerlos

```{r}
#| echo: false
library(readxl)
excel_sheets("data/urbanpop.xlsx")                   # nombres de las hojas
pop_1 <- read_excel("data/urbanpop.xlsx", sheet = 1)
pop_2 <- read_excel("data/urbanpop.xlsx", sheet = "1975-2011")
```

```{r}
library(readxl)
excel_sheets("data/beauty.xls")       # nombres de las hojas
dat_1 <- read_excel("data/beauty.xls", sheet = 1)
dat_2 <- read_excel("data/beauty.xls", sheet = "beauty")
```

-  Ver Ayuda para opciones adicionales

::: {.notes}

-   Se puede especificar varias opciones: elegir una selección, qué
    representa missing si no es celda en blanco, etc

```{r}
#| echo: false
urbanpop_sel <- read_excel("data/urbanpop.xlsx", sheet = 2, 
                           col_names = FALSE, skip = 21)
```

:::
-->

<!--
## Bibliotecas para otros formatos

* Tanto `haven` como `foreign` tienen comandos para importar datos de los formatos de sofware estadísticos Stata, SAS y SPSS

    + En la Ayuda tenemos información sobre sus argumentos y opciones por defecto

    + También importamos visualmente en ![](figure/ImportDataset.jpg){width="20%"} (usa `haven`)

-   [`googlesheets4`](https://github.com/tidyverse/googlesheets4) importa hojas de cálculo online de Google (p.e., de encuestas realizadas con Google Forms)

-   [`qualtRics`](https://cran.r-project.org/web/packages/qualtRics/vignettes/qualtRics.html) trabaja con software de encuestas `qualtrics`

-   `DBI` accede con Bases de Datos relaciones (SQL) 

 muy usado, en particular en el contexto empresarial:
    

- `jsonlite` se usa para leer datos en el formato JSON, de datos no relaciones (usado en páginas web) 
-->

## Importar y exportar con `rio`

<!--
* `rio` permite trabajar con varios formatos de forma **simple** y unificada (el mismo comando para todos) 

    + P.e., datos nativos de R, archivos de texto (también comprimidos), hojas de cálculo, formatos de software estadístico, Google Sheets, json
-->

* `rio` permite trabajar con el **mismo comando** para todos los formatos, pero las opciones por defecto pueden no ser adecuadas

    + En la Ayuda se incluye una presentación completa del paquete
  
    <!-- + Las opciones por defecto para un archivo pueden no ser adecuadas -->

* El comando `import()` se usa para leer los datos

```{r}
library(rio)
sex   <- import("data/sex_data.csv")
renta <- import("data/renta.txt")
beauty <- import("data/beauty.xls")
nsw    <- import("data/nsw.dta")    # formato Stata
```


<!--
## Importar y exportar con `rio` (cont.)

* Las opciones por defecto para un archivo pueden no ser adecuadas (p.e., el tipo de separador con .csv)

* La Ayuda describe los argumentos para cambiarlas

  + a veces, pasando argumentos del comando de la biblioteca original

-->

* Podemos exportar datos a un tipo de formato con `export()`


```{r}
export(nsw, "data/nsw.csv")
```

* O convertir un archivo del disco a otro formato con `convert()`

## Otras fuentes de datos


-   Bibliotecas con datos muy utilizados: `pwt` ("Penn World
    Tables")

-   Bibliotecas con funciones para obtener datos online
    (con
    [APIs](https://es.wikipedia.org/wiki/Interfaz_de_programaci%C3%B3n_de_aplicaciones) públicas)

    -   datos de las `OECD` y `eurostat`
        (incluye datos del INE español)

    -   `rdbnomics` para los datos gratuitos de
        <https://db.nomics.world/>

    -   datos económicos y financieros con `quantmod` y `tidyquant`
    
    -   [`quandl`](https://www.rdocumentation.org/packages/Quandl/versions/2.11.0)
        (de pago)

    
    <!-- -  `MicroDatosEs` con microdatos del INE (ej., EPA) -->

-   [`qualtRics`](https://cran.r-project.org/web/packages/qualtRics/vignettes/qualtRics.html) trabaja con software de encuestas `qualtrics`

-   Descarga de páginas web y *webscraping* con las bibliotecas `rvest` y `httr` (función `GET()`)

-   [`googlesheets4`](https://github.com/tidyverse/googlesheets4)

-   `DBI` accede con Bases de Datos relaciones (SQL) 

    

<!--
## Formatos de software estadístico con `haven`

-   Usando en ![](figure/ImportDataset.jpg){width="10%"} para importar formatos de SAS,
    STATA y SPSS

```{r}
library(haven)
sales <- read_sas("./data/sales.sas7bdat")  # no convierte caracteres a factores
```

-   Las variables se importan como vectores con etiquetas.

-   Es conveniente convertir a una estructura propia de R como factores

```{r}
sugar <- read_stata("./data/trade.dta")        # read_dta() es lo mismo
sugar$Date <- as.Date(as_factor(sugar$Date))

work <- read_sav("./data/employee.sav")        # formata SPSS
work$GENDER <- as_factor(work$GENDER)
```

-   También `read_por()` para otro tipo de fichero de SPSS

-   Más detalles y opciones en la Ayuda

## Formatos de software estadístico con `foreign`

-   Importa archivo de STATA y .sav de SPSS

-   Por defecto intenta convertir las clases de variables, que no
    siempre es conveniente

-   Entre otras opciones para .dta: `convert.dates`, `convert.factors`,
    `missing.type`, etc.

```{r}
library(foreign)
read.dta("./data/nsw.dta", convert.factors=F)
```

-   Para .sav, la opción `use.value.labels` establece si las variables
    con etiquetas en SPSS se convierten a factores

```{r}
earn <- read.spss("data/earnings_data.sav",
                  to.data.frame=TRUE, use.value.labels=FALSE)
```

## Más formatos

-   [`googlesheets4`](https://github.com/tidyverse/googlesheets4) de
    `tidyverse` accede a archivos de hojas de cálculo online de Google

    -   permite trabajar fácilmente con encuestas realizadas con Google
        Forms

```{=html}
https://www.garrickadenbuie.com/blog/use-google-forms-and-r-to-track-data-easily/

https://www.r-bloggers.com/2016/05/5-min-how-to-on-new-google-forms/

https://datascienceplus.com/how-to-use-googlesheets-to-connect-r-to-google-sheets/

<https://beanumber.github.io/mdsr2e/ch-dataII.html#tidy-data>

https://raw.githubusercontent.com/rstudio/cheatsheets/master/data-import.pdf

```

-   [`qualtRics`](https://cran.r-project.org/web/packages/qualtRics/vignettes/qualtRics.html)
    permite trabajar con el software de encuestas `qualtrics`

-   Para trabajar con Bases de Datos relaciones
    (SQL), muy usado, en particular en el contexto empresarial:
    `DBI`

-   Para trabajar con el formato JSON (usado en páginas web): `jsonlite`

    -   Más adelante veremos formas de obtener datos de páginas Web.

-   La biblioteca `httr` tiene la función `GET()` para descargar una
    página web 


```{=html}
        ver datacamp

        url <- "http://www.example.com/"
        resp <- GET(url)
```
-   NOTA: se puede acceder directamente a ficheros (sin descarga) o

    descargarlos con `download.file()`

```{r echo=F, eval=F}
url_rdata <- "https://s3.amazonaws.com/assets.datacamp.com/production/course_1478/datasets/wine.RData"
download.file(url_rdata, destfile = "wine_local.RData")
```

## Otras fuentes de datos

-   Bibliotecas con datos utilizados frecuentemente: `pwt` ("Penn World
    Tables")

-   Bibliotecas con funciones puede acceder directamente a datos online
    (con
    [APIs](https://es.wikipedia.org/wiki/Interfaz_de_programaci%C3%B3n_de_aplicaciones)
    públicos)

    -   `rdbnomics` para los datos gratuitos de
        <https://db.nomics.world/>

    -   `OECD` para los datos de la OCDE

    -   `eurostat`
        (incluye datos del INE español)

    -   [`quandl`](https://www.rdocumentation.org/packages/Quandl/versions/2.11.0)
        (de pago)

    -   `quantmod`

```{r}
library(quantmod)
help(quantmod)
help(getSymbols)
```

```{=html}

<https://www.r-bloggers.com/reproduce-economic-indicators-from-the-economist/> <https://www.r-bloggers.com/2020/10/access-the-free-economic-database-dbnomics-with-r-4/>
<https://raw.githubusercontent.com/rstudio/cheatsheets/master/eurostat.pdf>
```
## `quantmod`: datos macroeconómicos

-   En [FRED](https://fred.stlouisfed.org/) se puede acceder a datos
    macroeconomicos de muchos países

1.  Se busca un dato (concreto) de, por ejemplo, inflación en España

    -   "Inflation, consumer prices for Spain; Percent, Annual, Not
        Seasonally Adjusted"

2.  Averiguamos el "symbol" o nombre interno de la variable

```{r}
getSymbols("FPCPITOTLZGESP",src='FRED')
plot(FPCPITOTLZGESP)

str(FPCPITOTLZGESP)

plot(FPCPITOTLZGESP[1:20,])
```

## `quantmod`: datos Financieros

-   Se pueden obtener datos de [Yahoo
    Finance](https://es.finance.yahoo.com/)

-   Averiguamos el símbolo de una acción: ej., "Telefonica, Equity -
    NYQ"

```{r}
getSymbols('TEF',src='yahoo')
dim(TEF)
plot(TEF$TEF.Close)
```

-   Incluye funciones específicas de análisis, p.e., gráficos

```{r}
candleChart(TEF[-(1:3650),], up.col = "black", dn.col = "red",
            theme = "white")

```

```{r}
#| echo: false
getSymbols('^IBEX',src='yahoo')
candleChart(IBEX[1:20,], up.col = "black", dn.col = "red", theme = "white")

candleChart(IBEX[-(1:3150),], up.col = "black", dn.col = "red", theme = "white")
```
-->

<!--
## Más análisis con `quantmod`

* Conviene renombrar las variables para que sean más descriptivas

```{r}
getSymbols('MKTGDPESA646NWDB',
           src='FRED')        #  Gross Domestic Product for Spain
                              # Current U.S. Dollars, Annual, Not Seasonally Adjusted

inf <- FPCPITOTLZGESP
gdp <- MKTGDPESA646NWDB       # rm(FPCPITOTLZGESP, MKTGDPESA646NWDB)
```

* Podemos hacer estadísticas descriptivas

```{r}
cor(inf, gdp)
```

* Cuidado con NAs y que las longitudes de los vectores sean iguales

```{r}
dim(inf)
dim(gdp)
cor(inf[1:56,], gdp[1:56,])

plot(as.numeric(inf), as.numeric(gdp))
```

```{r}
#| echo: false

# tidyquant: https://github.com/business-science/tidyquant  ver video.

getSymbols("GDP", src = "FRED")
getSymbols("MEHOINUSA672N", src = "FRED")


gdp <- tq_get("GDP")   # esto es una acciónr
gdp <- tq_get("GDP", get = "economic.data")


plot(as.numeric(inf), as.numeric(gdp))

#data <- as.data.frame(cbind(inf,gdp))
data <- tibble(x = x, y = y)
data <- cbind(x,y) %>% as_tibble()
plot(x = data[1:56,1], y = data[1:56,2])

#data <- as_data_frame(bind_cols(inf,gdp))
#plot(data[1:56,"...1"], data[1:56,"...2"])

#ggplot(data = data) +
#  geom_point(aes(y = ...1, x = ...2))

# https://datos.gob.es/es
```

```{r eval=F, echo=F}
cor(inf[1:10], gdp[1:10])

cor(inf[1:10], gdp[2:11]) # misma dimension,
                          # cuidado porque es correlación retardos


```

-->

## Gráficos Básicos

-   Podemos representar gráficos de dos variables o funciones

:::: {.columns}

::: {.column width="45%"}

```{r}
x <- c(3, 4, 5, 6, 7, 8)
y <- c(5, 3, 7, 7, 5, 10)
```


:::

::: {.column width="5%"}


:::

::: {.column width="45%"}

```{r}
#| echo: false
plot(x,y)
curve(x^2, from=-2, to=2)
```

```{r}
plot(x,y)
```

:::

::::


-   El resultado aparece en la pestaña *Plots* de RStudio


::: {.notes}
```{r}
#| echo: false
plot(sin, -pi, 2*pi)
plot(log, 1, 10)

a <- 1:10
plot(a)    # a frente a un índice
```

:::

- Podemos cambiar opciones (ver Ayuda de `plot.default`) como *type* (puntos, líneas, etc.), símbolo de punto (*pch*), tipo de línea (*lty*), ancho de línea (*lwd*), color (*col*), título, etiquetas de los ejes, etc.

```{r}
plot(x, y, type="b", pch=3)
plot(x, y, type="l", lty=2, lwd=2)
plot(x, y, xlab="Eje X", ylab="Eje Y", main="Mi título")
```

* Se pueden cambiar más opciones con `par()`, combinar gráficos, añadir líneas, texto, etc. y exportar los gráficos

<!--
* También se pueden cambiar estas y otras opciones con el comando `par()`, *antes* del gráfico

## Gráficos Básicos (cont.)

- Podemos tener gráficos superpuestos con  `add=TRUE` (ejecutando todas las líneas juntas) e incluir leyendas con `legend()`

```{r}
curve(dnorm(x, 0, 1), -10, 10 , lwd=1, lty=1 )
curve(dnorm(x, 0, 2), add=TRUE, lwd=2, lty=2 )
curve(dnorm(x, 0, 3), add=TRUE, lwd=3, lty=3 )
legend(legend=c("sigma=1", "sigma=2", "sigma=3"),
        x="topright", lwd=1:3, lty=1:3)
```

-  También se pueden añadir elementos como puntos (con `points()`), líneas (con `lines()` o `abline()`), texto y flechas

```{r}
plot(x,y)
abline(a=3.57, b=0.64, lty=2)
text(6,6, "atípico", pos=3)
arrows(6.5,6,7,5)
```

```{r}
#| echo: false
plot(x,y)
points(7,5)                   
abline(a=3.57, b=0.64, lty=2)
text(6,6, "atípico", pos=3)
arrows(6.5,6,7,5)
```


:::{.notes}

- También se pueden tener gráficos supuestos con `matplot()`: representa una variable (eje x) frente a las columnas de una matriz (eje y)

```{r}
#| echo: false
year <- 2011:2015
producto1 <- c(12, 15, 14, 16, 17)
producto2 <- c(9, 10, 11, 14, 14)
producto3 <- c(14, 15, 12, 14, 17)
ventas <- cbind(producto1, producto2, producto3)
matplot(year, ventas, type="b", lwd = c(1, 2, 3))
```


-   La leyenda y el texto pueden incluir expresiones con letras griegas con el comando `expression()` (ver Ayuda de `plotmath`)

```{r}
#| echo: false
# en el gráfico anterior de distribuciones
legend(position="topright", 
        legend=c("sigma==1", "sigma==2", "sigma==3"),
        lwd=1:3, lty=1:3)
text(6,.3,
     expression(f(x))==frac(1,sqrt(2*pi)*sigma)*e^(-frac(x^2,2*sigma^2)))
```


:::

##  Exportar un gráfico

-   Exportamos un gráfico con distintas funciones según el formato: `pdf()`, `png()`, `jpeg()`, etc.

-   Esa función debe ir **antes** de los comandos del gráfico y se indica el final de estos con `dev.off()`

```{r}
pdf(file="figure/distrib.pdf", width = 4, height = 3)
curve(dnorm(x, 0, 1), -10, 10 , lwd=1, lty=1 )
curve(dnorm(x, 0, 2), add=TRUE, lwd=2, lty=2 )
curve(dnorm(x, 0, 3), add=TRUE, lwd=3, lty=3 )
dev.off()
```

- También se puede exportar (o copiar al portapapeles) desde la pestaña *Plots*

-->

# R para análisis de datos

## Estadísticos descriptivos: variables discretas

-   Para variables discretas (factores), `table()` calcula distribuciones de frecuencias de una variable o conjuntas: el resultado es un **objeto**

```{r}
data("PSID1982", package = "AER")
(frec  <- table(PSID1982$occupation) )
(frec2 <- table(PSID1982$occupation, PSID1982$ethnicity))
```

::: {.notes}

-   El objeto es una "tabla" es una variante de vector o matrices con nombres

-  Se podría opera con él: `table(PSID1982$occupation) / sum(table(PSID1982$occupation))`)

:::

-   Podemos mostrar frecuencias relativas con `prop.table()`

:::: {.columns}

::: {.column width="35%"}
```{r}
prop.table(frec)
prop.table(frec2)
```


:::

::: {.column width="5%"}

:::

::: {.column width="55%"}

```{r}
prop.table(frec2, margin = 1)
prop.table(frec2, margin = 2)
```


:::
::::

::: {.notes}

- Recordad: conceptos de distribución marginal (probabilidad de un valor en X), distribución conjunta (prob. de un valor de X Y uno de Y ) y distribución condicional (prob. de Y dado un valor de X)

- (In)dependencia y distribuciones conjunta y marginal: p.e., la distribución de trabajos es distinta en general o condicional a ser afroamericano

  - sabiendo que una persona es afroamericano, es más probable que sea cualificado (mayor renta, etc.)
  

:::

-   También es informativa su representación con gráficos de barras

<!--
:::: {.columns}

::: {.column width="28%"}
```{r}
barplot(frec)
barplot(frec, horiz = T)
```


:::

::: {.column width="3%"}

:::

::: {.column width="65%"}

```{r}
barplot(prop.table(frec2), beside = T)
```


:::
::::

-->

```{r}
barplot(frec, horiz = T)
barplot(prop.table(frec2), beside = T)
```


::: {.notes}

- `barplot(prop.table(frec2))` en otros casos puede ser más informativo que aquí

- También se puede representar con gráficos de tarta: `pie(frec)`

- Los gráficos admiten (casi) todas las opciones de `plot()` como títulos, etc. y otras específicas

:::

## Estadísticos descriptivos: variables continuas

```{r}
#| echo: false
library(wooldridge)
```

```{r}
data(ceosal1, package='wooldridge')
```

* Ya hemos visto funciones de estadísticos como `mean()`, `var()`, etc.

<!--
:::: {.columns}

::: {.column width="40%"}
```{r}
mean(ceosal1$salary)
median(ceosal1$salary)
```


:::

::: {.column width="8%"}

:::

::: {.column width="40%"}

```{r}
sd(ceosal1$salary)
var(ceosal1$salary)
```

:::

::::
-->

```{r}
median(ceosal1$salary)
var(ceosal1$salary)
```

```{r}
quantile(ceosal1$salary, 
         probs=c(0.25, 0.75) ) # 1er y 3er cuartil

summary(ceosal1$salary)  # de una variable (vector)
summary(ceosal1)         # de todo el conjunto de datos  

cov(ceosal1$salary, ceosal1$roe)  # covarianza
cor(ceosal1$salary, ceosal1$roe)  # correlación
```


::: {.notes}

* Recordad el tratamiento diferente de factores en `summary()`

*  Otras funciones de estadísticos: `min()`, `max()`, `range()`, `sum()`

:::

<!--
* ¿Cómo obtendríamos la moda? Tu respuesta [aquí](https://docs.google.com/forms/d/e/1FAIpQLSc2dYxHSuTLF-aGuVkusM3UevEKkCu6Iky2HC7aL6wkcP3r0g/viewform)

```{r}
#| echo: false
# Pensamiento algoritmico
# 2. moda(x) = valor más frecuente de la distribución de x
# 3-4.
# a calcular la distribcion
# tabla <- table(wage); tabla
# b. calcular el máximo
# ma <- max(tabla); ma
# c. seleccionar valor cuya freq es igual a maxima
# m <- tabla[tabla==ma]; str(m); m
# m <- which(tabla==ma); str(m); m
# alternativa:
# b'. ordenar freq descendientes
# tabla.ord <- sort(tabla, decreasing = T)
# c'. seleccionar primer elemento
# m2 <- tabla.ord[1]
#
# moda <- as. numeric(names(m)); moda
#
# 6. tabla[tabla==max(tabla)]

```{r}
#| echo: false
# https://stackoverflow.com/questions/2547402/is-there-a-built-in-function-for-finding-the-mode
Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}
```
-->

## Estadísticos descriptivos: variables continuas (cont.)

-   Para variables continuas, las frecuencias de valores en un *intervalo* se pueden tabular o graficar en un histograma 

:::{.notes}

- En teoría, cada obervación de una variable continua tiene valores distinto; en la práctica se repiten pero no tanto como en las discretas
:::

```{r}
hist(ceosal1$roe)   # intervalos automáticos
hist(ceosal1$roe, freq=F,       # densidad, no casos
     breaks=c(0,5,10,20,30,60)) # intervalos explícitos
```

-   O la densidad (versión suavizada del histograma)

```{r}
plot(density(ceosal1$roe))
```


:::{.notes}

- Se pueden combinar histograma y densidad ejecutando `hist(x)` y luego `lines(density(x))`

```{r}
#| echo: false
hist(ceosal1$roe, breaks=c(0,5,10,20,30,60) )
lines(density(ceosal1$roe))
```

- La función de distribución acumulada empírica es otra representación de la distribución de una variable (en especial, continua)

`plot(ecdf(ceosal1$roe))`

-   La definición de valor atípico/extremo es "arbitraria". Aquí es 1.5 veces el rango intercuartículo por encima/debajo de la caja.

:::

- Un gráfico de caja ofrece información resumida de la distribución: mediana, 1er y 3er cuartil, y valores "extremos"

```{r}
boxplot(ceosal1$roe, horizontal=T)
boxplot(ceosal1$roe~ceosal1$consprod)
```

:::{.notes}

- El símbolo `\~` en R indica que una variable es función de otras: en este caso, la distribución de `roe` se reprensenta en función de los valores de otra

:::


## Valores ausentes ("missing values"): `NA`

-   Muchos conjuntos de datos tienen valores ausentes de ciertas observaciones para algunas variables: ej., descargad (UA Cloud) [earn.RData](https://raw.githubusercontent.com/albarran/00datos/main/earn.RData)

<!-- En R se representan con `NA` -->
-   Sabemos si una observación es `NA` y la frecuencia total: 

:::: {.columns}

::: {.column width="40%"}

```{r}
load("data/earn.RData")
x <- earn$earnings
```
:::

::: {.column width="10%"}

:::

::: {.column width="45%"}

```{r}
is.na(x)
table(is.na(x))
```
:::

::::

:::{.notes}
- Recordemos también `any(is.na(x))`  (hay algun NAs?) o `which(is.na(x))` (qué elementos son NA)
:::

-   Por defecto en R, un cálculo con `NA`s es `NA`: debemos decir que los elimine  explícitamente (y ser conscientes de lo que implica)

:::: {.columns}
::: {.column width="25%"}
```{r}
mean(x)
```
:::

::: {.column width="5%"}

:::


::: {.column width="60%"}

```{r}
mean(x, na.rm=TRUE)
```
:::
::::

:::{.notes}

- `sum()`, `quantile()` y otras tienen la opción de `na.rm=TRUE`
- en `cor()` la opción es diferente: `cor(x, earn$age, use="complete.obs")`

:::

-   `na.omit()` elimina observaciones con `NA`s de una o varias variables
```{r}
earn2 <- na.omit(earn)
```

-  ¿Cómo tratar los `NA`s? Eliminarlos implica selección muestral y la alternativa de imputar valores implica supuestos sobre éstos

::: {.notes}

-  También podemos filtrar `y <- x[!is.na(x)]` u otras formas

-  Otra función útil `complete.cases()`

`s <- complete.cases(x)`

`earnComplete <- earn[s,]`

-  Para reemplazar valores (si pensamos que tiene sentido): `y <- replace(x, which(is.na(x)), -1)`

- Los estadísticos con la muestra sin `NA` pueden no ser representativos de la población total: solo muestrear en barrio pobre es igual de poco representativo que haya menos respuestas en el barrio rico

- suponer que podemos imputar renta solo con edad, genero y educación es restrictivo...

:::

<!--
## El meta-paquete `tidyverse`

-   Muchos datos de ejemplo están ya preparados para el análisis. 

-   En la vida real, los datos se tiene que recolectar, unir, limpiar, recodificar, etc.

-   `tidyverse` incluye una colección de biblitecas para todo el proceso "tratamiento de datos" y su visualización (para obtener información)

-   El núcleo de `tidyverse` lo componen (una descripción [aquí](https://www.tidyverse.org/packages/)):

:::: {.columns}

::: {.column width="40%"}
-   `readr`
-   `tibble`
-   `ggplot2`
-   `tidyr`
-   `purrr`
-   `dplyr`

::: 
::: {.column width="40%"}

![](figure/tidyverse_full.jpg){width="70%"}
:::
::::

::: {.notes}

- En Econometría II, los datos de ejemplo ya están limpios y preparados

- Para trabajar en la vida real, conviene aprender `tidyverse`

:::
-->

<!--
## *data frame* (R `base`) vs *tibble* (`tidyverse`)

::: {.notes} 

- https://blog.rstudio.com/2016/03/24/tibble-1-0-0/#tibbles-vs-data-frames

-   Es un ejemplo de una biblioteca ofreciendo objetos o funciones ya existentes, pero modificados/mejorados

:::

-   Los `tibbles` son *data frames* con propiedades mejoradas, especialmente para conjuntos de datos grandes: p.e., su visualización

:::: {.columns}

::: {.column width="40%"}
```{r}
library(tidyverse)
```

:::

::: {.column width="20%"}

:::

::: {.column width="40%"}
```{r}
mtcars
as_tibble(mtcars)
```

:::

::::


::: {.notes}

- Algunas mejoras ya se incorporan en R `base`: p.e., el uso de `[[]]` antes solo existía en `tibbles`, no en *data frames*

- También distintos comportamiento: 

  + en *data frames*,  df[,1] y df[[1]] son vectores y df[1] es un data frame
  
  + en *tibbles*, solo df[[1]] es vector, df[,1] y df[1] son tibbles

- `median(iris[,1])` ok, median espera vector, pero no si tibble

:::

-   Se pueden crear con la función `tibble()`

```{r}
tibble(x = 1:5, y = 1, z = x ^ 2 + y)
```

::: {.notes}

- Notar que `tibble()` no usa comillas para generar los nombres

- Tampoco convierte caracteres a factores por defecto (r4ds)

- Para crear por filas, ver `tribble()`

- tibble es un data frame que permite complejos listas en las columnas ver nest() unnest()
:::

-->

<!--

## Estadísticas por grupos: `aggregate`

* Para obtener estadísticas de una variable por grupos definidos por otra, podemos filtrar los datos

```{r}
#| echo: false
mean(ceosal1$roe[ceosal1$indus==1])
with(subset(ceosal1, indus==0), mean(roe))
```

```{r}
mean(ceosal1$roe[ceosal1$indus==1])
mean(subset(ceosal1, indus==0)$roe)
```


* Pero la función `aggregate()` lo hace más sencillo y devuelve un *data frame*

```{r}
aggregate(roe ~ indus, data=ceosal1,  FUN=mean)
```

- También en función de varias variables

```{r}
aggregate(roe ~ indus + finance, data=ceosal1,  FUN=mean)
```

- Notar la notación de formulas en R: `~` indica "en función de", separando las variables con `+` 

::: {.notes}

-     PREGUNTA: cómo se haría con regresión?

`lm(data=ceosal1, roe ~ indus)`

- También `aggregate(ceosal1$roe, by=list(ceosal1$indus), FUN=mean)`

- Variaas variables en función de otra: 

`aggregate( cbind(earnings, age) ~ year, data=earn2, FUN=mean )`

-   O de varias variables en función de varias variables

`a <- aggregate( cbind(earnings, age) ~ year + degree, data=earnComplete, mean )`

`str(a) # 'a' es un data frame!`
:::


## Funciones para distribuciones de probabilidad

- Densidad (variables continuas) o de masa (variables discretas) de probabilidad de un valor `x`:
  - `dbinom()`, `dunif()`, `dlogis()`, `dnorm()`, `dchisq()`, `dt()`, `dF()`
  
:::{.notes}
- Para una variabla discreto la fmp da la probabilidad de la variable aleatoria `X` tome exactamente el valor `x`

`x <- 0:10`

`fx <- dbinom(x, 10, 0.2)`

`plot(x,fx)`

- `curve(dnorm(x), -5, 5)`: un punto de la campana


:::
  
- Distribución acumulada por debajo de `x`

    + `pbinom()`, `punif()`, `plogis()`, `pnorm()`, `pchisq()`, `pt()`, `pF()`

:::{.notes}

-todo el área acumlada por debajo de un valor en la campana normal
- `pnorm(1.96)-pnorm(-1.96)` = 0.95 : 

- notar que `pnorm(1.96)=0.975` y qnorm(0.975)=1.96

:::

-  Valor cuya probabilidad acumulada es el cuartil `q`

    + `qbinom()`, `qunif()`, `qlogis()`, `qnorm()`, `qchisq()`, `qt()`, `qF()`

-  Generador de números (pseudo)aleatorios:

    + `rbinom()`, `runif()`, `rlogis()`, `rnorm()`, `rchisq()`, `rt()`, `rF()`

```{r}
set.seed(7675)
rnorm(5)
```


:::{.notes}

- Un ordenador (no cuántico) ofrece números de un secuencia determinista tan compleja que no es distinguible de la aleatoriedad
:::

<!--
## Inferencia Estadística

-   Intervalos de confianza (para una media)

:::: {.columns}

::: {.column width="40%"}
```{r}
data("audit", package='wooldridge')
(medy <- mean(audit$y))
(n    <- length(audit$y))
(sdy  <- sd(audit$y))
```


:::
::: {.column width="10%"}


:::
::: {.column width="40%"}
```{r}
(se   <- sdy/sqrt(n))
(c    <- qnorm(.975))

medy + c * c(-se,+se)
```


:::
::::

- Contraste de la t para $H_0: \mu=0$

```{r}
(t <- medy/se)
alpha.una.cola = c(0.1, 0.05, 0.025, 0.01, 0.005, .001)
VC <- -qt(1-alpha.una.cola, n-1) # valores críticos n-1 g.l.
cbind(alpha.una.cola, VC)
```

- p-valor: `p <- pt(t,240)`

:::{.notes}

-   probabilidad de que, bajo los supuestos con los que se deriva la distribución del estadístico de contraste ($H_0$), una muestra aleatoria diferente genere valores más extremos del estadístico
:::


## Inferencia Estadística (cont.)

- El comando `t.test()` ofrece todo lo anterior:

```{r}
t.test(audit$y)                     # dos colas
t.test(audit$y, alternative="less") # una cola
```

- El resultado es un objeto de tipo lista que puede guardarse y acceder a cada elemento

```{r}
testres <- t.test(audit$y)
testres
names(testres)
testres$p.value
```

-->


## Nota sobre programación "avanzada"

-   Como en todo lenguaje de programación R, tiene funciones para

    - Ejecución condicional `if()`: una parte del código se ejecuta solo si se cumple una condición
    
    - Bucles `for()`: se repite un mismo bloque de código mientras se itera por los valores de vector
    
    - Crear funciones propias con `function()`


-   Una variante de la ejecución condicional, solo para crear variables según una condición

```{r}
data("Affairs", package = "AER")
Affairs$univers <- ifelse(Affairs$education>15, 1, 0)
```


:::{.notes}
```{r}
#| echo: false
if (p<=0.05) {
  decision <- "Rechazar H0"
} else {
  decision <- "NO Rechazar H0"
}
```

- Tanto if-else como for pueden escribirse en una sola línea sin `\{` si solo incluye un comando en el bloque entre llaves:

`if (p<=0.05) decision <- "Rechazar H0" else decision <- "NO Rechazar H0"`

- Pueden anidarse `if-else`, `for` y ambos

- Otros comandos de bucles: `while`, `repeat`, `replicate`, `apply`, `lapply`, y otros (`map`) en bibliotecas adicionales 

:::


<!--

## Simulaciones

- En la realidad, los datos se consideran una muestra de una población con parámetros desconocidos: estimamos para inferir sus valores

- Un ordenador permite razonar "a la inversa": fijar los parámetros de la población, generar una muestra aleatoria de esa distribución y estimar

- "Vemos" la variabilidad muestral de los estimadores: p.e., las medias de muestras obtenidas de la *misma* distribución son distintas

:::: {.columns}

::: {.column width="40%"}

```{r}
set.seed(543210)
sample1 <- rnorm(100,10,2)
mean(sample1)
```


:::

::: {.column width="5%"}


:::

::: {.column width="45%"}

```{r}
#
sample2 <- rnorm(100,10,2)
mean(sample2)
```
:::
::::

- No debe sorprendernos y, de hecho, sabemos cómo es esa variabilidad: si $Y_i \sim N(\mu, \sigma^2)$, entonces $\bar{Y}=\frac{1}{n} \sum_{i=1}^n Y_i \sim N(\mu, \frac{\sigma^2}{n})$

## Simulaciones (cont.)

- Los bucles `for` permiten repetir el proceso muchas veces

:::: {.columns}

::: {.column width="35%"}
```{r}
set.seed(123456)
r <- 10000
ybar <- numeric(r)
```
:::


::: {.column width="4%"}

:::

::: {.column width="50%"}
```{r}
for (j in 1:r) {
  sample <- rnorm(100,10,2)
  ybar[j] <- mean(sample)
}
```
:::
::::

- Y comprobar si se cumple la teoría estadística

:::: {.columns}

::: {.column width="35%"}
```{r}
ybar[1:20]
mean(ybar)
var(ybar)
```
:::


::: {.column width="4%"}

:::

::: {.column width="50%"}
```{r}
plot(density(ybar))
curve(dnorm(x,10, 2/sqrt(100)), 
       add=TRUE,lty=2)
```

:::
::::

## Propiedades asintóticas

-   El análisis asintótico se ocupa del comportamiento de los estimadores cuando el tamaño muestral es grande

- Para una muestra de tamaño $n$ de una población (de **"cualquier" distribución**) $Y\sim (\mu, \sigma^2)$, 

  - según la ley de los grandes números, $E(\bar{Y}) \to \mu$  cuando $n \to \infty$ 

  - según el teorema central del límite, $\bar{Y} \overset{a}{\sim} N(\mu, \sigma^2/n)$

:::: {.columns}

::: {.column width="40%"}
```{r}
set.seed(123456)
r <- 10000
ybar <- numeric(r) 
n <- 10  # 10, 50, 100, 1000
```

:::

::: {.column width="5%"}

::: 

::: {.column width="40%"}

```{r}
for (j in 1:r) {  
  sample <- rchisq(n,1) 
  ybar[j] <- mean(sample) 
}
plot(density(ybar))
```

:::

::::

-   Más ejemplos en [esta aplicación](https://gallery.shinyapps.io/CLT_mean/_w_f533c061/) escrita totalmente en R

::: {.notes}

- segun LGN, también  $Var(\bar{Y})\to 0$

:::

<!--

## Regresión en R

-   La función `lm()` usa la notación de fórmula en R para crear un objeto de regresión: una lista con varios resultados almacenados

-   Usamos `summary()` para obtener la representación habitual

:::: {.columns}

::: {.column width="40%"}
```{r}
data(PSID1982, package="AER")
res <- lm(data=PSID1982, 
          wage ~ experience)
```
:::

::: {.column width="10%"}

:::

::: {.column width="40%"}
```{r}
summary(res)
resum  <- summary(res) 
resum$r.squared
```
:::

::::

::: {.notes}
- summary(res) tambien es una lista
:::

-   En regresión múltiple, incluimos variables separadas por `+`

```{r}
summary(lm(data=PSID1982, wage ~ experience + gender))
```

-   Se pueden incluir directamente transformaciones de las variables:

```{r}
summary(lm(data=PSID1982, 
 log(wage)~experience+I(experience^2)+education*gender))
```

::: {.notes}

-   Otra forma de escribir polinomios: 
`summary(lm(data=PSID1982, wage ~ poly(experience,2) + gender))`

pero estandariza los polinomios (los coefcientes son diferentes)

:::


## Regresión en R (cont.)

-   Ya sabemos que es importante tratar la información cualitativa adecuadamente: la interpretación es distinta

```{r}
data("Affairs", package = "AER")
summary(lm(data=Affairs, 
           affairs ~ yearsmarried + religiousness ))
Affairs$relig_f <- as.factor(Affairs$religiousness)
summary(lm(data=Affairs, affairs ~ yearsmarried + relig_f))
```

::: {.notes}

- NO hay un efecto linea de "religiosidad": un aumento de un punto no siempre tiene el mismo efecto

:::

- Cambiamos el grupo de referencia en un factor con `relevel()`, con la opción `ref` igual al nuevo nivel o la nueva etiqueta de referencia

```{r}
Affairs$relig_f <- relevel(Affairs$relig_f, ref = 5)
summary(lm(data=Affairs, affairs ~ yearsmarried + relig_f))
```

::: {.notes}

`Affairs$gender2 <- relevel(Affairs$gender, ref = "female")`

:::
-->

